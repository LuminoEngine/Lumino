#include "Common.hpp"
#include <LuminoCore/Text/EncodingConverter.hpp>


class Test_Text_EncodingConverter : public ::testing::Test {};

TEST_F(Test_Text_EncodingConverter, AsciiCode) {
    EncodingConversionOptions options;
    options.NullTerminated = true;
    EncodingConverter convAsciiToUtf16;
    convAsciiToUtf16.getSourceEncoding(TextEncoding::systemMultiByteEncoding());
    convAsciiToUtf16.setDestinationEncoding(TextEncoding::utf16Encoding());
    convAsciiToUtf16.setConversionOptions(options);
    const ByteBuffer& buf = convAsciiToUtf16.convert("ab", 2);
    const UTF16* utf16 = (const UTF16*)buf.data();
    ASSERT_EQ('a', utf16[0]);
    ASSERT_EQ('b', utf16[1]);
    ASSERT_EQ(0x00, utf16[2]);
}



#ifdef _WIN32
#include "../src/Text/Win32CodePageEncoding.hpp"

// Confirmed fix for crash on 1024Byte boundary.
TEST_F(Test_Text_EncodingConverter, Issue1) {
    auto encoding = makeRef<Win32CodePageEncoding>(932);

    EncodingConversionOptions options;
    options.NullTerminated = true;
    EncodingConverter convAsciiToUtf;
    convAsciiToUtf.getSourceEncoding(encoding);
    convAsciiToUtf.setDestinationEncoding(TextEncoding::utf32Encoding());
    convAsciiToUtf.setConversionOptions(options);

    const char* narrowStr = "123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890";
    const ByteBuffer& buf = convAsciiToUtf.convert(narrowStr, 1024);

    const UTF32* utf16 = (const UTF32*)buf.data();
    ASSERT_EQ('1', utf16[0]);
    ASSERT_EQ('2', utf16[1]);
}
#endif
