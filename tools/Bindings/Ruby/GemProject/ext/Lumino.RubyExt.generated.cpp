
#include <ruby.h>
#include "LuminoRubyRuntimeManager.h"
#include "FlatC.generated.h"



#define LN_TO_RUBY_FUNC(f) reinterpret_cast<VALUE(__cdecl *)(...)>(f)

inline VALUE LNI_TO_RUBY_VALUE(const char* v)   { return rb_str_new2(v); }
inline VALUE LNI_TO_RUBY_VALUE(LNBool v)        { return (v != LN_FALSE) ? Qtrue : Qfalse; }
inline VALUE LNI_TO_RUBY_VALUE(uint8_t v)       { return INT2FIX(v); }
inline VALUE LNI_TO_RUBY_VALUE(int v)           { return INT2NUM(v); }
inline VALUE LNI_TO_RUBY_VALUE(uint32_t v)      { return INT2NUM(v); }
inline VALUE LNI_TO_RUBY_VALUE(int64_t v)       { return INT2NUM(v); }
inline VALUE LNI_TO_RUBY_VALUE(uint64_t v)      { return INT2NUM(v); }
inline VALUE LNI_TO_RUBY_VALUE(float v)         { return DBL2NUM(v); }
inline VALUE LNI_TO_RUBY_VALUE(double v)        { return DBL2NUM(v); }

inline bool LNRB_VALUE_IS_OBJECT(VALUE v) { return (TYPE(v) == T_DATA) || (v == Qnil); }
inline bool LNRB_VALUE_IS_NUMBER(VALUE v) { return (TYPE(v) == T_FIXNUM || TYPE(v) == T_BIGNUM) || (v == Qnil); }
inline bool LNRB_VALUE_IS_FLOAT(VALUE v) { return (TYPE(v) == T_FLOAT) || (LNRB_VALUE_IS_NUMBER(v)) || (v == Qnil); }
inline bool LNRB_VALUE_IS_STRING(VALUE v) { return (TYPE(v) == T_STRING) || (v == Qnil); }
inline bool LNRB_VALUE_IS_BOOL(VALUE v) { return (TYPE(v) == T_FALSE || TYPE(v) == T_TRUE) || (v == Qnil); }

inline int LNRB_VALUE_TO_NUMBER(VALUE v) { return FIX2INT(v); }
inline float LNRB_VALUE_TO_FLOAT(VALUE v) { return (float)NUM2DBL(v); }
inline double LNRB_VALUE_TO_DOUBLE(VALUE v) { return NUM2DBL(v); }
inline const char* LNRB_VALUE_TO_STRING(VALUE v) { return StringValuePtr(v); }
inline LNBool LNRB_VALUE_TO_BOOL(VALUE v) { return (TYPE(v) == T_TRUE) ? LN_TRUE : LN_FALSE; }

extern "C" void InitLuminoRubyRuntimeManager();



VALUE g_enum_EncodingType;
VALUE g_enum_Keys;
VALUE g_enum_MouseButtons;
VALUE g_enum_SoundFadeBehavior;
VALUE g_enum_GraphicsAPI;
VALUE g_enum_PixelFormat;
VALUE g_enum_TextureFormat;
VALUE g_enum_DepthBufferFormat;
VALUE g_enum_ShadingModel;
VALUE g_enum_BlendMode;
VALUE g_enum_SceneClearMode;
VALUE g_enum_AnimationWrapMode;
VALUE g_enum_HierarchicalAnimationMode;
VALUE g_enum_TangentMode;
VALUE g_enum_ParticleEmitterShapeType;
VALUE g_enum_ParticleGeometryDirection;
VALUE g_enum_LevelTransitionEffectMode;
VALUE g_enum_UILayoutOrientation;
VALUE g_enum_UIVisibility;
VALUE g_enum_UIColorHues;
VALUE g_enum_UIVAlignment;
VALUE g_enum_UIHAlignment;
VALUE g_enum_UIInlinePlacement;
VALUE g_enum_UIListSubmitMode;

VALUE g_rootModule;
VALUE g_class_Object;
VALUE g_class_EventConnection;
VALUE g_class_PromiseFailureDelegate;
VALUE g_class_Variant;
VALUE g_class_ZVTestDelegate1;
VALUE g_class_ZVTestDelegate2;
VALUE g_class_ZVTestDelegate3;
VALUE g_class_ZVTestEventHandler1;
VALUE g_class_ZVTestEventHandler2;
VALUE g_class_ZVTestPromise1;
VALUE g_class_ZVTestPromise2;
VALUE g_class_ZVTestClass1;
VALUE g_class_ZVTestEventArgs1;
VALUE g_class_Serializer2;
VALUE g_class_AssetObject;
VALUE g_class_AssetImportSettings;
VALUE g_class_AssetModel;
VALUE g_class_Assets;
VALUE g_class_Sound;
VALUE g_class_Audio;
VALUE g_class_Texture2DDelegate;
VALUE g_class_Texture2DPromise;
VALUE g_class_Graphics;
VALUE g_class_Texture;
VALUE g_class_Texture2D;
VALUE g_class_Shader;
VALUE g_class_RenderView;
VALUE g_class_Material;
VALUE g_class_MeshNode;
VALUE g_class_AnimationController;
VALUE g_class_MeshModel;
VALUE g_class_MeshImportSettings;
VALUE g_class_SkinnedMeshModel;
VALUE g_class_CollisionShape;
VALUE g_class_BoxCollisionShape;
VALUE g_class_AnimationCurve;
VALUE g_class_KeyFrameAnimationCurve;
VALUE g_class_AnimationClip;
VALUE g_class_AnimationState;
VALUE g_class_EffectResource;
VALUE g_class_ParticleEmitterModel;
VALUE g_class_ParticleModel;
VALUE g_class_Component;
VALUE g_class_VisualComponent;
VALUE g_class_SpriteComponent;
VALUE g_class_CollisionEventHandler;
VALUE g_class_CharacterController;
VALUE g_class_World;
VALUE g_class_ComponentList;
VALUE g_class_WorldObject;
VALUE g_class_VisualObject;
VALUE g_class_Camera;
VALUE g_class_EnvironmentLight;
VALUE g_class_DirectionalLight;
VALUE g_class_PointLight;
VALUE g_class_SpotLight;
VALUE g_class_TestDelegate;
VALUE g_class_Sprite;
VALUE g_class_CameraOrbitControlComponent;
VALUE g_class_Raycaster;
VALUE g_class_RaycastResult;
VALUE g_class_WorldRenderView;
VALUE g_class_BoxMesh;
VALUE g_class_PlaneMesh;
VALUE g_class_StaticMesh;
VALUE g_class_StaticMeshComponent;
VALUE g_class_SkinnedMeshComponent;
VALUE g_class_Collision;
VALUE g_class_TriggerBodyComponent;
VALUE g_class_ParticleEmitter;
VALUE g_class_Scene;
VALUE g_class_Level;
VALUE g_class_UIColors;
VALUE g_class_UIEventArgs;
VALUE g_class_UIGeneralEventHandler;
VALUE g_class_UIEventHandler;
VALUE g_class_UILayoutElement;
VALUE g_class_UIElement;
VALUE g_class_UITextBlock;
VALUE g_class_UISprite;
VALUE g_class_UIIcon;
VALUE g_class_UIMessageTextArea;
VALUE g_class_UI;
VALUE g_class_UILayoutPanel;
VALUE g_class_UIBoxLayout;
VALUE g_class_UIStackLayout;
VALUE g_class_UIGridLayout;
VALUE g_class_UIControl;
VALUE g_class_UIButtonBase;
VALUE g_class_UIButton;
VALUE g_class_UIWindow;
VALUE g_class_UIListItem;
VALUE g_class_UIListItemsControl;
VALUE g_class_UIListBoxItem;
VALUE g_class_UIListBox;
VALUE g_class_InputGesture;
VALUE g_class_KeyGesture;
VALUE g_class_Input;
VALUE g_class_Mouse;
VALUE g_class_InterpreterCommand;
VALUE g_class_InterpreterCommandList;
VALUE g_class_InterpreterCommandDelegate;
VALUE g_class_Interpreter;
VALUE g_class_EngineSettings;
VALUE g_class_Engine;
VALUE g_class_Application;
VALUE g_class_Debug;
VALUE g_class_ObjectSerializeHandler;
VALUE g_class_EventConnectionSerializeHandler;
VALUE g_class_VariantSerializeHandler;
VALUE g_class_ZVTestClass1SerializeHandler;
VALUE g_class_ZVTestEventArgs1SerializeHandler;
VALUE g_class_Serializer2SerializeHandler;
VALUE g_class_AssetObjectSerializeHandler;
VALUE g_class_AssetImportSettingsSerializeHandler;
VALUE g_class_AssetModelSerializeHandler;
VALUE g_class_SoundSerializeHandler;
VALUE g_class_TextureSerializeHandler;
VALUE g_class_Texture2DSerializeHandler;
VALUE g_class_ShaderSerializeHandler;
VALUE g_class_RenderViewSerializeHandler;
VALUE g_class_MaterialSerializeHandler;
VALUE g_class_MeshNodeSerializeHandler;
VALUE g_class_AnimationControllerSerializeHandler;
VALUE g_class_MeshModelSerializeHandler;
VALUE g_class_MeshImportSettingsSerializeHandler;
VALUE g_class_SkinnedMeshModelSerializeHandler;
VALUE g_class_CollisionShapeSerializeHandler;
VALUE g_class_BoxCollisionShapeSerializeHandler;
VALUE g_class_AnimationCurveSerializeHandler;
VALUE g_class_KeyFrameAnimationCurveSerializeHandler;
VALUE g_class_AnimationClipSerializeHandler;
VALUE g_class_AnimationStateSerializeHandler;
VALUE g_class_EffectResourceSerializeHandler;
VALUE g_class_ParticleEmitterModelSerializeHandler;
VALUE g_class_ParticleModelSerializeHandler;
VALUE g_class_ComponentSerializeHandler;
VALUE g_class_VisualComponentSerializeHandler;
VALUE g_class_SpriteComponentSerializeHandler;
VALUE g_class_CharacterControllerSerializeHandler;
VALUE g_class_WorldSerializeHandler;
VALUE g_class_ComponentListSerializeHandler;
VALUE g_class_WorldObjectSerializeHandler;
VALUE g_class_WorldObjectPreUpdateHandler;
VALUE g_class_WorldObjectUpdateHandler;
VALUE g_class_VisualObjectSerializeHandler;
VALUE g_class_VisualObjectPreUpdateHandler;
VALUE g_class_VisualObjectUpdateHandler;
VALUE g_class_CameraSerializeHandler;
VALUE g_class_CameraPreUpdateHandler;
VALUE g_class_CameraUpdateHandler;
VALUE g_class_EnvironmentLightSerializeHandler;
VALUE g_class_EnvironmentLightPreUpdateHandler;
VALUE g_class_EnvironmentLightUpdateHandler;
VALUE g_class_DirectionalLightSerializeHandler;
VALUE g_class_DirectionalLightPreUpdateHandler;
VALUE g_class_DirectionalLightUpdateHandler;
VALUE g_class_PointLightSerializeHandler;
VALUE g_class_PointLightPreUpdateHandler;
VALUE g_class_PointLightUpdateHandler;
VALUE g_class_SpotLightSerializeHandler;
VALUE g_class_SpotLightPreUpdateHandler;
VALUE g_class_SpotLightUpdateHandler;
VALUE g_class_SpriteSerializeHandler;
VALUE g_class_SpritePreUpdateHandler;
VALUE g_class_SpriteUpdateHandler;
VALUE g_class_CameraOrbitControlComponentSerializeHandler;
VALUE g_class_RaycasterSerializeHandler;
VALUE g_class_RaycastResultSerializeHandler;
VALUE g_class_WorldRenderViewSerializeHandler;
VALUE g_class_BoxMeshSerializeHandler;
VALUE g_class_BoxMeshPreUpdateHandler;
VALUE g_class_BoxMeshUpdateHandler;
VALUE g_class_PlaneMeshSerializeHandler;
VALUE g_class_PlaneMeshPreUpdateHandler;
VALUE g_class_PlaneMeshUpdateHandler;
VALUE g_class_StaticMeshSerializeHandler;
VALUE g_class_StaticMeshPreUpdateHandler;
VALUE g_class_StaticMeshUpdateHandler;
VALUE g_class_StaticMeshComponentSerializeHandler;
VALUE g_class_SkinnedMeshComponentSerializeHandler;
VALUE g_class_CollisionSerializeHandler;
VALUE g_class_TriggerBodyComponentSerializeHandler;
VALUE g_class_ParticleEmitterSerializeHandler;
VALUE g_class_ParticleEmitterPreUpdateHandler;
VALUE g_class_ParticleEmitterUpdateHandler;
VALUE g_class_LevelSerializeHandler;
VALUE g_class_LevelStartHandler;
VALUE g_class_LevelStopHandler;
VALUE g_class_LevelPauseHandler;
VALUE g_class_LevelResumeHandler;
VALUE g_class_LevelUpdateHandler;
VALUE g_class_UIEventArgsSerializeHandler;
VALUE g_class_UILayoutElementSerializeHandler;
VALUE g_class_UIElementSerializeHandler;
VALUE g_class_UITextBlockSerializeHandler;
VALUE g_class_UISpriteSerializeHandler;
VALUE g_class_UIIconSerializeHandler;
VALUE g_class_UIMessageTextAreaSerializeHandler;
VALUE g_class_UILayoutPanelSerializeHandler;
VALUE g_class_UIBoxLayoutSerializeHandler;
VALUE g_class_UIStackLayoutSerializeHandler;
VALUE g_class_UIGridLayoutSerializeHandler;
VALUE g_class_UIControlSerializeHandler;
VALUE g_class_UIButtonBaseSerializeHandler;
VALUE g_class_UIButtonSerializeHandler;
VALUE g_class_UIWindowSerializeHandler;
VALUE g_class_UIListItemSerializeHandler;
VALUE g_class_UIListItemsControlSerializeHandler;
VALUE g_class_UIListBoxItemSerializeHandler;
VALUE g_class_UIListBoxSerializeHandler;
VALUE g_class_InputGestureSerializeHandler;
VALUE g_class_KeyGestureSerializeHandler;
VALUE g_class_InterpreterCommandSerializeHandler;
VALUE g_class_InterpreterCommandListSerializeHandler;
VALUE g_class_InterpreterSerializeHandler;
VALUE g_class_InterpreterUpdateWaitHandler;
VALUE g_class_ApplicationSerializeHandler;
VALUE g_class_ApplicationInitHandler;
VALUE g_class_ApplicationUpdateHandler;


//==============================================================================
// ln::Vector3

VALUE g_class_Vector3;

void LNVector3_delete(LNVector3* obj)
{
    free(obj);
}

VALUE LNVector3_allocate( VALUE klass )
{
    VALUE obj;
    LNVector3* internalObj;

    internalObj = (LNVector3*)malloc(sizeof(LNVector3));
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVector3_allocate" );
    obj = Data_Wrap_Struct(klass, NULL, LNVector3_delete, internalObj);
    
    memset(internalObj, 0, sizeof(LNVector3));

    return obj;
}

static VALUE Wrap_LNVector3_GetX(int argc, VALUE* argv, VALUE self)
{
    LNVector3* selfObj;
    Data_Get_Struct(self, LNVector3, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->x);
    }
    rb_raise(rb_eArgError, "ln::Vector3::getX - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector3_SetX(int argc, VALUE* argv, VALUE self)
{
    LNVector3* selfObj;
    Data_Get_Struct(self, LNVector3, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->x = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Vector3::setX - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector3_GetY(int argc, VALUE* argv, VALUE self)
{
    LNVector3* selfObj;
    Data_Get_Struct(self, LNVector3, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->y);
    }
    rb_raise(rb_eArgError, "ln::Vector3::getY - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector3_SetY(int argc, VALUE* argv, VALUE self)
{
    LNVector3* selfObj;
    Data_Get_Struct(self, LNVector3, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->y = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Vector3::setY - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector3_GetZ(int argc, VALUE* argv, VALUE self)
{
    LNVector3* selfObj;
    Data_Get_Struct(self, LNVector3, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->z);
    }
    rb_raise(rb_eArgError, "ln::Vector3::getZ - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector3_SetZ(int argc, VALUE* argv, VALUE self)
{
    LNVector3* selfObj;
    Data_Get_Struct(self, LNVector3, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->z = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Vector3::setZ - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector3_Set(int argc, VALUE* argv, VALUE self)
{
    LNVector3* selfObj;
    Data_Get_Struct(self, LNVector3, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNVector3_SetZeros(selfObj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (3 <= argc && argc <= 3) {
        VALUE x;
        VALUE y;
        VALUE z;
        rb_scan_args(argc, argv, "3", &x, &y, &z);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(z))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _z = LNRB_VALUE_TO_FLOAT(z);
            LNResult errorCode = LNVector3_Set(selfObj, _x, _y, _z);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Vector3::Vector3 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector3_Get(int argc, VALUE* argv, VALUE self)
{
    LNVector3* selfObj;
    Data_Get_Struct(self, LNVector3, selfObj);
    if (3 <= argc && argc <= 3) {
        VALUE outX;
        VALUE outY;
        VALUE outZ;
        rb_scan_args(argc, argv, "3", &outX, &outY, &outZ);
        if (LNRB_VALUE_IS_FLOAT(outX) && LNRB_VALUE_IS_FLOAT(outY) && LNRB_VALUE_IS_FLOAT(outZ))
        {
            float _outX = LNRB_VALUE_TO_FLOAT(outX);
            float _outY = LNRB_VALUE_TO_FLOAT(outY);
            float _outZ = LNRB_VALUE_TO_FLOAT(outZ);
            LNResult errorCode = LNVector3_Get(selfObj, &_outX, &_outY, &_outZ);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Vector3::get - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector3_Length(int argc, VALUE* argv, VALUE self)
{
    LNVector3* selfObj;
    Data_Get_Struct(self, LNVector3, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNVector3_Length(selfObj, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Vector3::length - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector3_LengthSquared(int argc, VALUE* argv, VALUE self)
{
    LNVector3* selfObj;
    Data_Get_Struct(self, LNVector3, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNVector3_LengthSquared(selfObj, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Vector3::lengthSquared - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector3_MutatingNormalize(int argc, VALUE* argv, VALUE self)
{
    LNVector3* selfObj;
    Data_Get_Struct(self, LNVector3, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNVector3_MutatingNormalize(selfObj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Vector3::mutatingNormalize - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector3_Normalize(int argc, VALUE* argv, VALUE self)
{
    if (3 <= argc && argc <= 3) {
        VALUE x;
        VALUE y;
        VALUE z;
        rb_scan_args(argc, argv, "3", &x, &y, &z);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(z))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _z = LNRB_VALUE_TO_FLOAT(z);
            LNVector3 _outReturn;
            LNResult errorCode = LNVector3_NormalizeXYZ(_x, _y, _z, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNVector3_allocate(g_class_Vector3);
            *((LNVector3*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    if (1 <= argc && argc <= 1) {
        VALUE vec;
        rb_scan_args(argc, argv, "1", &vec);
        if (LNRB_VALUE_IS_OBJECT(vec))
        {
            LNVector3* tmp__vec; Data_Get_Struct(vec, LNVector3, tmp__vec);LNVector3& _vec = *tmp__vec;
            LNVector3 _outReturn;
            LNResult errorCode = LNVector3_Normalize(&_vec, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNVector3_allocate(g_class_Vector3);
            *((LNVector3*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::Vector3::normalize - wrong argument type.");
    return Qnil;
}

//==============================================================================
// ln::Vector4

VALUE g_class_Vector4;

void LNVector4_delete(LNVector4* obj)
{
    free(obj);
}

VALUE LNVector4_allocate( VALUE klass )
{
    VALUE obj;
    LNVector4* internalObj;

    internalObj = (LNVector4*)malloc(sizeof(LNVector4));
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVector4_allocate" );
    obj = Data_Wrap_Struct(klass, NULL, LNVector4_delete, internalObj);
    
    memset(internalObj, 0, sizeof(LNVector4));

    return obj;
}

static VALUE Wrap_LNVector4_GetX(int argc, VALUE* argv, VALUE self)
{
    LNVector4* selfObj;
    Data_Get_Struct(self, LNVector4, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->x);
    }
    rb_raise(rb_eArgError, "ln::Vector4::getX - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector4_SetX(int argc, VALUE* argv, VALUE self)
{
    LNVector4* selfObj;
    Data_Get_Struct(self, LNVector4, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->x = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Vector4::setX - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector4_GetY(int argc, VALUE* argv, VALUE self)
{
    LNVector4* selfObj;
    Data_Get_Struct(self, LNVector4, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->y);
    }
    rb_raise(rb_eArgError, "ln::Vector4::getY - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector4_SetY(int argc, VALUE* argv, VALUE self)
{
    LNVector4* selfObj;
    Data_Get_Struct(self, LNVector4, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->y = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Vector4::setY - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector4_GetZ(int argc, VALUE* argv, VALUE self)
{
    LNVector4* selfObj;
    Data_Get_Struct(self, LNVector4, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->z);
    }
    rb_raise(rb_eArgError, "ln::Vector4::getZ - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector4_SetZ(int argc, VALUE* argv, VALUE self)
{
    LNVector4* selfObj;
    Data_Get_Struct(self, LNVector4, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->z = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Vector4::setZ - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector4_GetW(int argc, VALUE* argv, VALUE self)
{
    LNVector4* selfObj;
    Data_Get_Struct(self, LNVector4, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->w);
    }
    rb_raise(rb_eArgError, "ln::Vector4::getW - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector4_SetW(int argc, VALUE* argv, VALUE self)
{
    LNVector4* selfObj;
    Data_Get_Struct(self, LNVector4, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->w = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Vector4::setW - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVector4_Set(int argc, VALUE* argv, VALUE self)
{
    LNVector4* selfObj;
    Data_Get_Struct(self, LNVector4, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNVector4_SetZeros(selfObj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (4 <= argc && argc <= 4) {
        VALUE x;
        VALUE y;
        VALUE z;
        VALUE w;
        rb_scan_args(argc, argv, "4", &x, &y, &z, &w);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(z) && LNRB_VALUE_IS_FLOAT(w))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _z = LNRB_VALUE_TO_FLOAT(z);
            float _w = LNRB_VALUE_TO_FLOAT(w);
            LNResult errorCode = LNVector4_Set(selfObj, _x, _y, _z, _w);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Vector4::Vector4 - wrong argument type.");
    return Qnil;
}

//==============================================================================
// ln::Quaternion

VALUE g_class_Quaternion;

void LNQuaternion_delete(LNQuaternion* obj)
{
    free(obj);
}

VALUE LNQuaternion_allocate( VALUE klass )
{
    VALUE obj;
    LNQuaternion* internalObj;

    internalObj = (LNQuaternion*)malloc(sizeof(LNQuaternion));
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNQuaternion_allocate" );
    obj = Data_Wrap_Struct(klass, NULL, LNQuaternion_delete, internalObj);
    
    memset(internalObj, 0, sizeof(LNQuaternion));

    return obj;
}

static VALUE Wrap_LNQuaternion_GetX(int argc, VALUE* argv, VALUE self)
{
    LNQuaternion* selfObj;
    Data_Get_Struct(self, LNQuaternion, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->x);
    }
    rb_raise(rb_eArgError, "ln::Quaternion::getX - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNQuaternion_SetX(int argc, VALUE* argv, VALUE self)
{
    LNQuaternion* selfObj;
    Data_Get_Struct(self, LNQuaternion, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->x = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Quaternion::setX - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNQuaternion_GetY(int argc, VALUE* argv, VALUE self)
{
    LNQuaternion* selfObj;
    Data_Get_Struct(self, LNQuaternion, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->y);
    }
    rb_raise(rb_eArgError, "ln::Quaternion::getY - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNQuaternion_SetY(int argc, VALUE* argv, VALUE self)
{
    LNQuaternion* selfObj;
    Data_Get_Struct(self, LNQuaternion, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->y = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Quaternion::setY - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNQuaternion_GetZ(int argc, VALUE* argv, VALUE self)
{
    LNQuaternion* selfObj;
    Data_Get_Struct(self, LNQuaternion, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->z);
    }
    rb_raise(rb_eArgError, "ln::Quaternion::getZ - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNQuaternion_SetZ(int argc, VALUE* argv, VALUE self)
{
    LNQuaternion* selfObj;
    Data_Get_Struct(self, LNQuaternion, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->z = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Quaternion::setZ - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNQuaternion_GetW(int argc, VALUE* argv, VALUE self)
{
    LNQuaternion* selfObj;
    Data_Get_Struct(self, LNQuaternion, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->w);
    }
    rb_raise(rb_eArgError, "ln::Quaternion::getW - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNQuaternion_SetW(int argc, VALUE* argv, VALUE self)
{
    LNQuaternion* selfObj;
    Data_Get_Struct(self, LNQuaternion, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->w = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Quaternion::setW - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNQuaternion_Set(int argc, VALUE* argv, VALUE self)
{
    LNQuaternion* selfObj;
    Data_Get_Struct(self, LNQuaternion, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNQuaternion_SetZeros(selfObj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (4 <= argc && argc <= 4) {
        VALUE x;
        VALUE y;
        VALUE z;
        VALUE w;
        rb_scan_args(argc, argv, "4", &x, &y, &z, &w);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(z) && LNRB_VALUE_IS_FLOAT(w))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _z = LNRB_VALUE_TO_FLOAT(z);
            float _w = LNRB_VALUE_TO_FLOAT(w);
            LNResult errorCode = LNQuaternion_Set(selfObj, _x, _y, _z, _w);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 2) {
        VALUE axis;
        VALUE r;
        rb_scan_args(argc, argv, "2", &axis, &r);
        if (LNRB_VALUE_IS_OBJECT(axis) && LNRB_VALUE_IS_FLOAT(r))
        {
            LNVector3* tmp__axis; Data_Get_Struct(axis, LNVector3, tmp__axis);LNVector3& _axis = *tmp__axis;
            float _r = LNRB_VALUE_TO_FLOAT(r);
            LNResult errorCode = LNQuaternion_SetFromAxis(selfObj, &_axis, _r);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Quaternion::Quaternion - wrong argument type.");
    return Qnil;
}

//==============================================================================
// ln::Matrix

VALUE g_class_Matrix;

void LNMatrix_delete(LNMatrix* obj)
{
    free(obj);
}

VALUE LNMatrix_allocate( VALUE klass )
{
    VALUE obj;
    LNMatrix* internalObj;

    internalObj = (LNMatrix*)malloc(sizeof(LNMatrix));
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMatrix_allocate" );
    obj = Data_Wrap_Struct(klass, NULL, LNMatrix_delete, internalObj);
    
    memset(internalObj, 0, sizeof(LNMatrix));

    return obj;
}

static VALUE Wrap_LNMatrix_GetRow0(int argc, VALUE* argv, VALUE self)
{
    LNMatrix* selfObj;
    Data_Get_Struct(self, LNMatrix, selfObj);
    if (argc == 0) {
        VALUE retObj = LNVector4_allocate(g_class_Vector4);
        *((LNVector4*)DATA_PTR(retObj)) = selfObj->row0;
        return retObj;

    }
    rb_raise(rb_eArgError, "ln::Matrix::getRow0 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMatrix_SetRow0(int argc, VALUE* argv, VALUE self)
{
    LNMatrix* selfObj;
    Data_Get_Struct(self, LNMatrix, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value)) {
            LNVector4* tmp__value; Data_Get_Struct(value, LNVector4, tmp__value);LNVector4& _value = *tmp__value;
            selfObj->row0 = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Matrix::setRow0 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMatrix_GetRow1(int argc, VALUE* argv, VALUE self)
{
    LNMatrix* selfObj;
    Data_Get_Struct(self, LNMatrix, selfObj);
    if (argc == 0) {
        VALUE retObj = LNVector4_allocate(g_class_Vector4);
        *((LNVector4*)DATA_PTR(retObj)) = selfObj->row1;
        return retObj;

    }
    rb_raise(rb_eArgError, "ln::Matrix::getRow1 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMatrix_SetRow1(int argc, VALUE* argv, VALUE self)
{
    LNMatrix* selfObj;
    Data_Get_Struct(self, LNMatrix, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value)) {
            LNVector4* tmp__value; Data_Get_Struct(value, LNVector4, tmp__value);LNVector4& _value = *tmp__value;
            selfObj->row1 = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Matrix::setRow1 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMatrix_GetRow2(int argc, VALUE* argv, VALUE self)
{
    LNMatrix* selfObj;
    Data_Get_Struct(self, LNMatrix, selfObj);
    if (argc == 0) {
        VALUE retObj = LNVector4_allocate(g_class_Vector4);
        *((LNVector4*)DATA_PTR(retObj)) = selfObj->row2;
        return retObj;

    }
    rb_raise(rb_eArgError, "ln::Matrix::getRow2 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMatrix_SetRow2(int argc, VALUE* argv, VALUE self)
{
    LNMatrix* selfObj;
    Data_Get_Struct(self, LNMatrix, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value)) {
            LNVector4* tmp__value; Data_Get_Struct(value, LNVector4, tmp__value);LNVector4& _value = *tmp__value;
            selfObj->row2 = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Matrix::setRow2 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMatrix_GetRow3(int argc, VALUE* argv, VALUE self)
{
    LNMatrix* selfObj;
    Data_Get_Struct(self, LNMatrix, selfObj);
    if (argc == 0) {
        VALUE retObj = LNVector4_allocate(g_class_Vector4);
        *((LNVector4*)DATA_PTR(retObj)) = selfObj->row3;
        return retObj;

    }
    rb_raise(rb_eArgError, "ln::Matrix::getRow3 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMatrix_SetRow3(int argc, VALUE* argv, VALUE self)
{
    LNMatrix* selfObj;
    Data_Get_Struct(self, LNMatrix, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value)) {
            LNVector4* tmp__value; Data_Get_Struct(value, LNVector4, tmp__value);LNVector4& _value = *tmp__value;
            selfObj->row3 = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Matrix::setRow3 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMatrix_Set(int argc, VALUE* argv, VALUE self)
{
    LNMatrix* selfObj;
    Data_Get_Struct(self, LNMatrix, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNMatrix_SetZeros(selfObj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (16 <= argc && argc <= 16) {
        VALUE m11;
        VALUE m12;
        VALUE m13;
        VALUE m14;
        VALUE m21;
        VALUE m22;
        VALUE m23;
        VALUE m24;
        VALUE m31;
        VALUE m32;
        VALUE m33;
        VALUE m34;
        VALUE m41;
        VALUE m42;
        VALUE m43;
        VALUE m44;
        rb_scan_args(argc, argv, "16", &m11, &m12, &m13, &m14, &m21, &m22, &m23, &m24, &m31, &m32, &m33, &m34, &m41, &m42, &m43, &m44);
        if (LNRB_VALUE_IS_FLOAT(m11) && LNRB_VALUE_IS_FLOAT(m12) && LNRB_VALUE_IS_FLOAT(m13) && LNRB_VALUE_IS_FLOAT(m14) && LNRB_VALUE_IS_FLOAT(m21) && LNRB_VALUE_IS_FLOAT(m22) && LNRB_VALUE_IS_FLOAT(m23) && LNRB_VALUE_IS_FLOAT(m24) && LNRB_VALUE_IS_FLOAT(m31) && LNRB_VALUE_IS_FLOAT(m32) && LNRB_VALUE_IS_FLOAT(m33) && LNRB_VALUE_IS_FLOAT(m34) && LNRB_VALUE_IS_FLOAT(m41) && LNRB_VALUE_IS_FLOAT(m42) && LNRB_VALUE_IS_FLOAT(m43) && LNRB_VALUE_IS_FLOAT(m44))
        {
            float _m11 = LNRB_VALUE_TO_FLOAT(m11);
            float _m12 = LNRB_VALUE_TO_FLOAT(m12);
            float _m13 = LNRB_VALUE_TO_FLOAT(m13);
            float _m14 = LNRB_VALUE_TO_FLOAT(m14);
            float _m21 = LNRB_VALUE_TO_FLOAT(m21);
            float _m22 = LNRB_VALUE_TO_FLOAT(m22);
            float _m23 = LNRB_VALUE_TO_FLOAT(m23);
            float _m24 = LNRB_VALUE_TO_FLOAT(m24);
            float _m31 = LNRB_VALUE_TO_FLOAT(m31);
            float _m32 = LNRB_VALUE_TO_FLOAT(m32);
            float _m33 = LNRB_VALUE_TO_FLOAT(m33);
            float _m34 = LNRB_VALUE_TO_FLOAT(m34);
            float _m41 = LNRB_VALUE_TO_FLOAT(m41);
            float _m42 = LNRB_VALUE_TO_FLOAT(m42);
            float _m43 = LNRB_VALUE_TO_FLOAT(m43);
            float _m44 = LNRB_VALUE_TO_FLOAT(m44);
            LNResult errorCode = LNMatrix_Set(selfObj, _m11, _m12, _m13, _m14, _m21, _m22, _m23, _m24, _m31, _m32, _m33, _m34, _m41, _m42, _m43, _m44);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Matrix::Matrix - wrong argument type.");
    return Qnil;
}

//==============================================================================
// ln::Color

VALUE g_class_Color;

void LNColor_delete(LNColor* obj)
{
    free(obj);
}

VALUE LNColor_allocate( VALUE klass )
{
    VALUE obj;
    LNColor* internalObj;

    internalObj = (LNColor*)malloc(sizeof(LNColor));
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNColor_allocate" );
    obj = Data_Wrap_Struct(klass, NULL, LNColor_delete, internalObj);
    
    memset(internalObj, 0, sizeof(LNColor));

    return obj;
}

static VALUE Wrap_LNColor_GetR(int argc, VALUE* argv, VALUE self)
{
    LNColor* selfObj;
    Data_Get_Struct(self, LNColor, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->r);
    }
    rb_raise(rb_eArgError, "ln::Color::getR - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColor_SetR(int argc, VALUE* argv, VALUE self)
{
    LNColor* selfObj;
    Data_Get_Struct(self, LNColor, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->r = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Color::setR - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColor_GetG(int argc, VALUE* argv, VALUE self)
{
    LNColor* selfObj;
    Data_Get_Struct(self, LNColor, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->g);
    }
    rb_raise(rb_eArgError, "ln::Color::getG - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColor_SetG(int argc, VALUE* argv, VALUE self)
{
    LNColor* selfObj;
    Data_Get_Struct(self, LNColor, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->g = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Color::setG - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColor_GetB(int argc, VALUE* argv, VALUE self)
{
    LNColor* selfObj;
    Data_Get_Struct(self, LNColor, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->b);
    }
    rb_raise(rb_eArgError, "ln::Color::getB - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColor_SetB(int argc, VALUE* argv, VALUE self)
{
    LNColor* selfObj;
    Data_Get_Struct(self, LNColor, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->b = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Color::setB - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColor_GetA(int argc, VALUE* argv, VALUE self)
{
    LNColor* selfObj;
    Data_Get_Struct(self, LNColor, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->a);
    }
    rb_raise(rb_eArgError, "ln::Color::getA - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColor_SetA(int argc, VALUE* argv, VALUE self)
{
    LNColor* selfObj;
    Data_Get_Struct(self, LNColor, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->a = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Color::setA - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColor_Set(int argc, VALUE* argv, VALUE self)
{
    LNColor* selfObj;
    Data_Get_Struct(self, LNColor, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNColor_SetZeros(selfObj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (3 <= argc && argc <= 4) {
        VALUE r_;
        VALUE g_;
        VALUE b_;
        VALUE a_;
        rb_scan_args(argc, argv, "31", &r_, &g_, &b_, &a_);
        if (LNRB_VALUE_IS_FLOAT(r_) && LNRB_VALUE_IS_FLOAT(g_) && LNRB_VALUE_IS_FLOAT(b_) && LNRB_VALUE_IS_FLOAT(a_))
        {
            float _r_ = LNRB_VALUE_TO_FLOAT(r_);
            float _g_ = LNRB_VALUE_TO_FLOAT(g_);
            float _b_ = LNRB_VALUE_TO_FLOAT(b_);
            float _a_ = (a_ != Qnil) ? LNRB_VALUE_TO_FLOAT(a_) : 1.000000;
            LNResult errorCode = LNColor_Set(selfObj, _r_, _g_, _b_, _a_);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Color::Color - wrong argument type.");
    return Qnil;
}

//==============================================================================
// ln::ColorTone

VALUE g_class_ColorTone;

void LNColorTone_delete(LNColorTone* obj)
{
    free(obj);
}

VALUE LNColorTone_allocate( VALUE klass )
{
    VALUE obj;
    LNColorTone* internalObj;

    internalObj = (LNColorTone*)malloc(sizeof(LNColorTone));
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNColorTone_allocate" );
    obj = Data_Wrap_Struct(klass, NULL, LNColorTone_delete, internalObj);
    
    memset(internalObj, 0, sizeof(LNColorTone));

    return obj;
}

static VALUE Wrap_LNColorTone_GetR(int argc, VALUE* argv, VALUE self)
{
    LNColorTone* selfObj;
    Data_Get_Struct(self, LNColorTone, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->r);
    }
    rb_raise(rb_eArgError, "ln::ColorTone::getR - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColorTone_SetR(int argc, VALUE* argv, VALUE self)
{
    LNColorTone* selfObj;
    Data_Get_Struct(self, LNColorTone, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->r = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ColorTone::setR - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColorTone_GetG(int argc, VALUE* argv, VALUE self)
{
    LNColorTone* selfObj;
    Data_Get_Struct(self, LNColorTone, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->g);
    }
    rb_raise(rb_eArgError, "ln::ColorTone::getG - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColorTone_SetG(int argc, VALUE* argv, VALUE self)
{
    LNColorTone* selfObj;
    Data_Get_Struct(self, LNColorTone, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->g = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ColorTone::setG - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColorTone_GetB(int argc, VALUE* argv, VALUE self)
{
    LNColorTone* selfObj;
    Data_Get_Struct(self, LNColorTone, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->b);
    }
    rb_raise(rb_eArgError, "ln::ColorTone::getB - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColorTone_SetB(int argc, VALUE* argv, VALUE self)
{
    LNColorTone* selfObj;
    Data_Get_Struct(self, LNColorTone, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->b = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ColorTone::setB - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColorTone_GetS(int argc, VALUE* argv, VALUE self)
{
    LNColorTone* selfObj;
    Data_Get_Struct(self, LNColorTone, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->s);
    }
    rb_raise(rb_eArgError, "ln::ColorTone::getS - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColorTone_SetS(int argc, VALUE* argv, VALUE self)
{
    LNColorTone* selfObj;
    Data_Get_Struct(self, LNColorTone, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->s = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ColorTone::setS - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNColorTone_Set(int argc, VALUE* argv, VALUE self)
{
    LNColorTone* selfObj;
    Data_Get_Struct(self, LNColorTone, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNColorTone_SetZeros(selfObj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (4 <= argc && argc <= 4) {
        VALUE r_;
        VALUE g_;
        VALUE b_;
        VALUE s_;
        rb_scan_args(argc, argv, "4", &r_, &g_, &b_, &s_);
        if (LNRB_VALUE_IS_FLOAT(r_) && LNRB_VALUE_IS_FLOAT(g_) && LNRB_VALUE_IS_FLOAT(b_) && LNRB_VALUE_IS_FLOAT(s_))
        {
            float _r_ = LNRB_VALUE_TO_FLOAT(r_);
            float _g_ = LNRB_VALUE_TO_FLOAT(g_);
            float _b_ = LNRB_VALUE_TO_FLOAT(b_);
            float _s_ = LNRB_VALUE_TO_FLOAT(s_);
            LNResult errorCode = LNColorTone_Set(selfObj, _r_, _g_, _b_, _s_);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ColorTone::ColorTone - wrong argument type.");
    return Qnil;
}

//==============================================================================
// ln::Point

VALUE g_class_Point;

void LNPoint_delete(LNPoint* obj)
{
    free(obj);
}

VALUE LNPoint_allocate( VALUE klass )
{
    VALUE obj;
    LNPoint* internalObj;

    internalObj = (LNPoint*)malloc(sizeof(LNPoint));
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPoint_allocate" );
    obj = Data_Wrap_Struct(klass, NULL, LNPoint_delete, internalObj);
    
    memset(internalObj, 0, sizeof(LNPoint));

    return obj;
}

static VALUE Wrap_LNPoint_GetX(int argc, VALUE* argv, VALUE self)
{
    LNPoint* selfObj;
    Data_Get_Struct(self, LNPoint, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->x);
    }
    rb_raise(rb_eArgError, "ln::Point::getX - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPoint_SetX(int argc, VALUE* argv, VALUE self)
{
    LNPoint* selfObj;
    Data_Get_Struct(self, LNPoint, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->x = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Point::setX - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPoint_GetY(int argc, VALUE* argv, VALUE self)
{
    LNPoint* selfObj;
    Data_Get_Struct(self, LNPoint, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->y);
    }
    rb_raise(rb_eArgError, "ln::Point::getY - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPoint_SetY(int argc, VALUE* argv, VALUE self)
{
    LNPoint* selfObj;
    Data_Get_Struct(self, LNPoint, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->y = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Point::setY - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPoint_Set(int argc, VALUE* argv, VALUE self)
{
    LNPoint* selfObj;
    Data_Get_Struct(self, LNPoint, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNPoint_SetZeros(selfObj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 2) {
        VALUE x_;
        VALUE y_;
        rb_scan_args(argc, argv, "2", &x_, &y_);
        if (LNRB_VALUE_IS_FLOAT(x_) && LNRB_VALUE_IS_FLOAT(y_))
        {
            float _x_ = LNRB_VALUE_TO_FLOAT(x_);
            float _y_ = LNRB_VALUE_TO_FLOAT(y_);
            LNResult errorCode = LNPoint_Set(selfObj, _x_, _y_);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Point::Point - wrong argument type.");
    return Qnil;
}

//==============================================================================
// ln::Size

VALUE g_class_Size;

void LNSize_delete(LNSize* obj)
{
    free(obj);
}

VALUE LNSize_allocate( VALUE klass )
{
    VALUE obj;
    LNSize* internalObj;

    internalObj = (LNSize*)malloc(sizeof(LNSize));
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSize_allocate" );
    obj = Data_Wrap_Struct(klass, NULL, LNSize_delete, internalObj);
    
    memset(internalObj, 0, sizeof(LNSize));

    return obj;
}

static VALUE Wrap_LNSize_GetWidth(int argc, VALUE* argv, VALUE self)
{
    LNSize* selfObj;
    Data_Get_Struct(self, LNSize, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->width);
    }
    rb_raise(rb_eArgError, "ln::Size::getWidth - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSize_SetWidth(int argc, VALUE* argv, VALUE self)
{
    LNSize* selfObj;
    Data_Get_Struct(self, LNSize, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->width = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Size::setWidth - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSize_GetHeight(int argc, VALUE* argv, VALUE self)
{
    LNSize* selfObj;
    Data_Get_Struct(self, LNSize, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->height);
    }
    rb_raise(rb_eArgError, "ln::Size::getHeight - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSize_SetHeight(int argc, VALUE* argv, VALUE self)
{
    LNSize* selfObj;
    Data_Get_Struct(self, LNSize, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->height = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Size::setHeight - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSize_Set(int argc, VALUE* argv, VALUE self)
{
    LNSize* selfObj;
    Data_Get_Struct(self, LNSize, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNSize_SetZeros(selfObj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 2) {
        VALUE w;
        VALUE h;
        rb_scan_args(argc, argv, "2", &w, &h);
        if (LNRB_VALUE_IS_FLOAT(w) && LNRB_VALUE_IS_FLOAT(h))
        {
            float _w = LNRB_VALUE_TO_FLOAT(w);
            float _h = LNRB_VALUE_TO_FLOAT(h);
            LNResult errorCode = LNSize_Set(selfObj, _w, _h);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Size::Size - wrong argument type.");
    return Qnil;
}

//==============================================================================
// ln::Rect

VALUE g_class_Rect;

void LNRect_delete(LNRect* obj)
{
    free(obj);
}

VALUE LNRect_allocate( VALUE klass )
{
    VALUE obj;
    LNRect* internalObj;

    internalObj = (LNRect*)malloc(sizeof(LNRect));
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNRect_allocate" );
    obj = Data_Wrap_Struct(klass, NULL, LNRect_delete, internalObj);
    
    memset(internalObj, 0, sizeof(LNRect));

    return obj;
}

static VALUE Wrap_LNRect_GetX(int argc, VALUE* argv, VALUE self)
{
    LNRect* selfObj;
    Data_Get_Struct(self, LNRect, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->x);
    }
    rb_raise(rb_eArgError, "ln::Rect::getX - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNRect_SetX(int argc, VALUE* argv, VALUE self)
{
    LNRect* selfObj;
    Data_Get_Struct(self, LNRect, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->x = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Rect::setX - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNRect_GetY(int argc, VALUE* argv, VALUE self)
{
    LNRect* selfObj;
    Data_Get_Struct(self, LNRect, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->y);
    }
    rb_raise(rb_eArgError, "ln::Rect::getY - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNRect_SetY(int argc, VALUE* argv, VALUE self)
{
    LNRect* selfObj;
    Data_Get_Struct(self, LNRect, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->y = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Rect::setY - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNRect_GetWidth(int argc, VALUE* argv, VALUE self)
{
    LNRect* selfObj;
    Data_Get_Struct(self, LNRect, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->width);
    }
    rb_raise(rb_eArgError, "ln::Rect::getWidth - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNRect_SetWidth(int argc, VALUE* argv, VALUE self)
{
    LNRect* selfObj;
    Data_Get_Struct(self, LNRect, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->width = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Rect::setWidth - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNRect_GetHeight(int argc, VALUE* argv, VALUE self)
{
    LNRect* selfObj;
    Data_Get_Struct(self, LNRect, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->height);
    }
    rb_raise(rb_eArgError, "ln::Rect::getHeight - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNRect_SetHeight(int argc, VALUE* argv, VALUE self)
{
    LNRect* selfObj;
    Data_Get_Struct(self, LNRect, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->height = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Rect::setHeight - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNRect_Set(int argc, VALUE* argv, VALUE self)
{
    LNRect* selfObj;
    Data_Get_Struct(self, LNRect, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNRect_SetZeros(selfObj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (4 <= argc && argc <= 4) {
        VALUE x;
        VALUE y;
        VALUE width;
        VALUE height;
        rb_scan_args(argc, argv, "4", &x, &y, &width, &height);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(width) && LNRB_VALUE_IS_FLOAT(height))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _width = LNRB_VALUE_TO_FLOAT(width);
            float _height = LNRB_VALUE_TO_FLOAT(height);
            LNResult errorCode = LNRect_Set(selfObj, _x, _y, _width, _height);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Rect::Rect - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNRect_GetLeft(int argc, VALUE* argv, VALUE self)
{
    LNRect* selfObj;
    Data_Get_Struct(self, LNRect, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNRect_GetLeft(selfObj, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Rect::getLeft - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNRect_SetSize(int argc, VALUE* argv, VALUE self)
{
    LNRect* selfObj;
    Data_Get_Struct(self, LNRect, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE size;
        rb_scan_args(argc, argv, "1", &size);
        if (LNRB_VALUE_IS_OBJECT(size))
        {
            LNSize* tmp__size; Data_Get_Struct(size, LNSize, tmp__size);LNSize& _size = *tmp__size;
            LNResult errorCode = LNRect_SetSize(selfObj, &_size);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Rect::setSize - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNRect_GetSize(int argc, VALUE* argv, VALUE self)
{
    LNRect* selfObj;
    Data_Get_Struct(self, LNRect, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNSize _outReturn;
            LNResult errorCode = LNRect_GetSize(selfObj, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNSize_allocate(g_class_Size);
            *((LNSize*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::Rect::getSize - wrong argument type.");
    return Qnil;
}

//==============================================================================
// ln::Thickness

VALUE g_class_Thickness;

void LNThickness_delete(LNThickness* obj)
{
    free(obj);
}

VALUE LNThickness_allocate( VALUE klass )
{
    VALUE obj;
    LNThickness* internalObj;

    internalObj = (LNThickness*)malloc(sizeof(LNThickness));
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNThickness_allocate" );
    obj = Data_Wrap_Struct(klass, NULL, LNThickness_delete, internalObj);
    
    memset(internalObj, 0, sizeof(LNThickness));

    return obj;
}

static VALUE Wrap_LNThickness_GetLeft(int argc, VALUE* argv, VALUE self)
{
    LNThickness* selfObj;
    Data_Get_Struct(self, LNThickness, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->left);
    }
    rb_raise(rb_eArgError, "ln::Thickness::getLeft - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNThickness_SetLeft(int argc, VALUE* argv, VALUE self)
{
    LNThickness* selfObj;
    Data_Get_Struct(self, LNThickness, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->left = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Thickness::setLeft - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNThickness_GetTop(int argc, VALUE* argv, VALUE self)
{
    LNThickness* selfObj;
    Data_Get_Struct(self, LNThickness, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->top);
    }
    rb_raise(rb_eArgError, "ln::Thickness::getTop - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNThickness_SetTop(int argc, VALUE* argv, VALUE self)
{
    LNThickness* selfObj;
    Data_Get_Struct(self, LNThickness, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->top = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Thickness::setTop - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNThickness_GetRight(int argc, VALUE* argv, VALUE self)
{
    LNThickness* selfObj;
    Data_Get_Struct(self, LNThickness, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->right);
    }
    rb_raise(rb_eArgError, "ln::Thickness::getRight - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNThickness_SetRight(int argc, VALUE* argv, VALUE self)
{
    LNThickness* selfObj;
    Data_Get_Struct(self, LNThickness, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->right = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Thickness::setRight - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNThickness_GetBottom(int argc, VALUE* argv, VALUE self)
{
    LNThickness* selfObj;
    Data_Get_Struct(self, LNThickness, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->bottom);
    }
    rb_raise(rb_eArgError, "ln::Thickness::getBottom - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNThickness_SetBottom(int argc, VALUE* argv, VALUE self)
{
    LNThickness* selfObj;
    Data_Get_Struct(self, LNThickness, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->bottom = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Thickness::setBottom - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNThickness_Set(int argc, VALUE* argv, VALUE self)
{
    LNThickness* selfObj;
    Data_Get_Struct(self, LNThickness, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNThickness_SetZeros(selfObj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (4 <= argc && argc <= 4) {
        VALUE left_;
        VALUE top_;
        VALUE right_;
        VALUE bottom_;
        rb_scan_args(argc, argv, "4", &left_, &top_, &right_, &bottom_);
        if (LNRB_VALUE_IS_FLOAT(left_) && LNRB_VALUE_IS_FLOAT(top_) && LNRB_VALUE_IS_FLOAT(right_) && LNRB_VALUE_IS_FLOAT(bottom_))
        {
            float _left_ = LNRB_VALUE_TO_FLOAT(left_);
            float _top_ = LNRB_VALUE_TO_FLOAT(top_);
            float _right_ = LNRB_VALUE_TO_FLOAT(right_);
            float _bottom_ = LNRB_VALUE_TO_FLOAT(bottom_);
            LNResult errorCode = LNThickness_Set(selfObj, _left_, _top_, _right_, _bottom_);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Thickness::Thickness - wrong argument type.");
    return Qnil;
}

//==============================================================================
// ln::CornerRadius

VALUE g_class_CornerRadius;

void LNCornerRadius_delete(LNCornerRadius* obj)
{
    free(obj);
}

VALUE LNCornerRadius_allocate( VALUE klass )
{
    VALUE obj;
    LNCornerRadius* internalObj;

    internalObj = (LNCornerRadius*)malloc(sizeof(LNCornerRadius));
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCornerRadius_allocate" );
    obj = Data_Wrap_Struct(klass, NULL, LNCornerRadius_delete, internalObj);
    
    memset(internalObj, 0, sizeof(LNCornerRadius));

    return obj;
}

static VALUE Wrap_LNCornerRadius_GetTopleft(int argc, VALUE* argv, VALUE self)
{
    LNCornerRadius* selfObj;
    Data_Get_Struct(self, LNCornerRadius, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->topLeft);
    }
    rb_raise(rb_eArgError, "ln::CornerRadius::getTopleft - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCornerRadius_SetTopleft(int argc, VALUE* argv, VALUE self)
{
    LNCornerRadius* selfObj;
    Data_Get_Struct(self, LNCornerRadius, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->topLeft = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CornerRadius::setTopleft - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCornerRadius_GetTopright(int argc, VALUE* argv, VALUE self)
{
    LNCornerRadius* selfObj;
    Data_Get_Struct(self, LNCornerRadius, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->topRight);
    }
    rb_raise(rb_eArgError, "ln::CornerRadius::getTopright - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCornerRadius_SetTopright(int argc, VALUE* argv, VALUE self)
{
    LNCornerRadius* selfObj;
    Data_Get_Struct(self, LNCornerRadius, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->topRight = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CornerRadius::setTopright - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCornerRadius_GetBottomright(int argc, VALUE* argv, VALUE self)
{
    LNCornerRadius* selfObj;
    Data_Get_Struct(self, LNCornerRadius, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->bottomRight);
    }
    rb_raise(rb_eArgError, "ln::CornerRadius::getBottomright - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCornerRadius_SetBottomright(int argc, VALUE* argv, VALUE self)
{
    LNCornerRadius* selfObj;
    Data_Get_Struct(self, LNCornerRadius, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->bottomRight = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CornerRadius::setBottomright - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCornerRadius_GetBottomleft(int argc, VALUE* argv, VALUE self)
{
    LNCornerRadius* selfObj;
    Data_Get_Struct(self, LNCornerRadius, selfObj);
    if (argc == 0) {
        return LNI_TO_RUBY_VALUE(selfObj->bottomLeft);
    }
    rb_raise(rb_eArgError, "ln::CornerRadius::getBottomleft - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCornerRadius_SetBottomleft(int argc, VALUE* argv, VALUE self)
{
    LNCornerRadius* selfObj;
    Data_Get_Struct(self, LNCornerRadius, selfObj);
    if (argc == 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value)) {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            selfObj->bottomLeft = _value;
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CornerRadius::setBottomleft - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCornerRadius_Set(int argc, VALUE* argv, VALUE self)
{
    LNCornerRadius* selfObj;
    Data_Get_Struct(self, LNCornerRadius, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNCornerRadius_SetZeros(selfObj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (4 <= argc && argc <= 4) {
        VALUE topLeft;
        VALUE topRight;
        VALUE bottomRight;
        VALUE bottomLeft;
        rb_scan_args(argc, argv, "4", &topLeft, &topRight, &bottomRight, &bottomLeft);
        if (LNRB_VALUE_IS_FLOAT(topLeft) && LNRB_VALUE_IS_FLOAT(topRight) && LNRB_VALUE_IS_FLOAT(bottomRight) && LNRB_VALUE_IS_FLOAT(bottomLeft))
        {
            float _topLeft = LNRB_VALUE_TO_FLOAT(topLeft);
            float _topRight = LNRB_VALUE_TO_FLOAT(topRight);
            float _bottomRight = LNRB_VALUE_TO_FLOAT(bottomRight);
            float _bottomLeft = LNRB_VALUE_TO_FLOAT(bottomLeft);
            LNResult errorCode = LNCornerRadius_Set(selfObj, _topLeft, _topRight, _bottomRight, _bottomLeft);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CornerRadius::CornerRadius - wrong argument type.");
    return Qnil;
}

//==============================================================================
// ln::Object

struct Wrap_Object
    : public Wrap_RubyObject
{

    Wrap_Object()
    {}
};

static void LNObject_delete(Wrap_Object* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNObject_mark(Wrap_Object* obj)
{
	

}

static VALUE LNObject_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Object* internalObj;

    internalObj = new Wrap_Object();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNObject_allocate");
    obj = Data_Wrap_Struct(klass, LNObject_mark, LNObject_delete, internalObj);

    return obj;
}

static VALUE LNObject_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Object* internalObj;

    internalObj = new Wrap_Object();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNObject_allocate");
    obj = Data_Wrap_Struct(klass, LNObject_mark, LNObject_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNObject_OnSerialize(int argc, VALUE* argv, VALUE self)
{
    Wrap_Object* selfObj;
    Data_Get_Struct(self, Wrap_Object, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE ar;
        rb_scan_args(argc, argv, "1", &ar);
        if (LNRB_VALUE_IS_OBJECT(ar))
        {
            LNHandle _ar = LuminoRubyRuntimeManager::instance->getHandle(ar);
            LNResult errorCode = LNObject_OnSerialize_CallOverrideBase(selfObj->handle, _ar);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Object::onSerialize - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNObject_Release(int argc, VALUE* argv, VALUE self)
{
    Wrap_Object* selfObj;
    Data_Get_Struct(self, Wrap_Object, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNObject_Release(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Object::release - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNObject_Retain(int argc, VALUE* argv, VALUE self)
{
    Wrap_Object* selfObj;
    Data_Get_Struct(self, Wrap_Object, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNObject_Retain(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Object::retain - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNObject_GetReferenceCount(int argc, VALUE* argv, VALUE self)
{
    Wrap_Object* selfObj;
    Data_Get_Struct(self, Wrap_Object, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            int _outReturn;
            LNResult errorCode = LNObject_GetReferenceCount(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Object::getReferenceCount - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNObject_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::EventConnection

struct Wrap_EventConnection
    : public Wrap_Object
{

    Wrap_EventConnection()
    {}
};

static void LNEventConnection_delete(Wrap_EventConnection* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNEventConnection_mark(Wrap_EventConnection* obj)
{
	

}

static VALUE LNEventConnection_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_EventConnection* internalObj;

    internalObj = new Wrap_EventConnection();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEventConnection_allocate");
    obj = Data_Wrap_Struct(klass, LNEventConnection_mark, LNEventConnection_delete, internalObj);

    return obj;
}

static VALUE LNEventConnection_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_EventConnection* internalObj;

    internalObj = new Wrap_EventConnection();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEventConnection_allocate");
    obj = Data_Wrap_Struct(klass, LNEventConnection_mark, LNEventConnection_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNEventConnection_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::PromiseFailureDelegate

struct Wrap_PromiseFailureDelegate
    : public Wrap_Object
{

    VALUE m_proc = Qnil;
    Wrap_PromiseFailureDelegate()
    {}
};

static void LNPromiseFailureDelegate_delete(Wrap_PromiseFailureDelegate* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNPromiseFailureDelegate_mark(Wrap_PromiseFailureDelegate* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNPromiseFailureDelegate_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_PromiseFailureDelegate* internalObj;

    internalObj = new Wrap_PromiseFailureDelegate();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPromiseFailureDelegate_allocate");
    obj = Data_Wrap_Struct(klass, LNPromiseFailureDelegate_mark, LNPromiseFailureDelegate_delete, internalObj);

    return obj;
}

static VALUE LNPromiseFailureDelegate_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_PromiseFailureDelegate* internalObj;

    internalObj = new Wrap_PromiseFailureDelegate();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPromiseFailureDelegate_allocate");
    obj = Data_Wrap_Struct(klass, LNPromiseFailureDelegate_mark, LNPromiseFailureDelegate_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNPromiseFailureDelegate_PromiseFailureDelegate_ProcCaller(LNHandle promisefailuredelegate)
{
    Wrap_PromiseFailureDelegate* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(promisefailuredelegate), Wrap_PromiseFailureDelegate, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 0, );
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNPromiseFailureDelegate_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_PromiseFailureDelegate* selfObj;
    Data_Get_Struct(self, Wrap_PromiseFailureDelegate, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNPromiseFailureDelegate_Create(Wrap_LNPromiseFailureDelegate_PromiseFailureDelegate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ln::PromiseFailureDelegate::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::Variant

struct Wrap_Variant
    : public Wrap_Object
{

    Wrap_Variant()
    {}
};

static void LNVariant_delete(Wrap_Variant* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNVariant_mark(Wrap_Variant* obj)
{
	

}

static VALUE LNVariant_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Variant* internalObj;

    internalObj = new Wrap_Variant();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVariant_allocate");
    obj = Data_Wrap_Struct(klass, LNVariant_mark, LNVariant_delete, internalObj);

    return obj;
}

static VALUE LNVariant_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Variant* internalObj;

    internalObj = new Wrap_Variant();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVariant_allocate");
    obj = Data_Wrap_Struct(klass, LNVariant_mark, LNVariant_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNVariant_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_Variant* selfObj;
    Data_Get_Struct(self, Wrap_Variant, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNVariant_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Variant::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVariant_SetInt(int argc, VALUE* argv, VALUE self)
{
    Wrap_Variant* selfObj;
    Data_Get_Struct(self, Wrap_Variant, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            int _value = LNRB_VALUE_TO_NUMBER(value);
            LNResult errorCode = LNVariant_SetInt(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Variant::setInt - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVariant_GetInt(int argc, VALUE* argv, VALUE self)
{
    Wrap_Variant* selfObj;
    Data_Get_Struct(self, Wrap_Variant, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            int _outReturn;
            LNResult errorCode = LNVariant_GetInt(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Variant::getInt - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNVariant_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::ZVTestDelegate1

struct Wrap_ZVTestDelegate1
    : public Wrap_Object
{

    VALUE m_proc = Qnil;
    Wrap_ZVTestDelegate1()
    {}
};

static void LNZVTestDelegate1_delete(Wrap_ZVTestDelegate1* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNZVTestDelegate1_mark(Wrap_ZVTestDelegate1* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNZVTestDelegate1_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ZVTestDelegate1* internalObj;

    internalObj = new Wrap_ZVTestDelegate1();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestDelegate1_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestDelegate1_mark, LNZVTestDelegate1_delete, internalObj);

    return obj;
}

static VALUE LNZVTestDelegate1_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ZVTestDelegate1* internalObj;

    internalObj = new Wrap_ZVTestDelegate1();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestDelegate1_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestDelegate1_mark, LNZVTestDelegate1_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNZVTestDelegate1_ZVTestDelegate1_ProcCaller(LNHandle zvtestdelegate1, int p1)
{
    Wrap_ZVTestDelegate1* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(zvtestdelegate1), Wrap_ZVTestDelegate1, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNI_TO_RUBY_VALUE(p1));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNZVTestDelegate1_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestDelegate1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestDelegate1, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNZVTestDelegate1_Create(Wrap_LNZVTestDelegate1_ZVTestDelegate1_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ln::ZVTestDelegate1::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::ZVTestDelegate2

struct Wrap_ZVTestDelegate2
    : public Wrap_Object
{

    VALUE m_proc = Qnil;
    Wrap_ZVTestDelegate2()
    {}
};

static void LNZVTestDelegate2_delete(Wrap_ZVTestDelegate2* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNZVTestDelegate2_mark(Wrap_ZVTestDelegate2* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNZVTestDelegate2_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ZVTestDelegate2* internalObj;

    internalObj = new Wrap_ZVTestDelegate2();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestDelegate2_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestDelegate2_mark, LNZVTestDelegate2_delete, internalObj);

    return obj;
}

static VALUE LNZVTestDelegate2_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ZVTestDelegate2* internalObj;

    internalObj = new Wrap_ZVTestDelegate2();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestDelegate2_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestDelegate2_mark, LNZVTestDelegate2_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNZVTestDelegate2_ZVTestDelegate2_ProcCaller(LNHandle zvtestdelegate2, int p1, int p2, int* outReturn)
{
    Wrap_ZVTestDelegate2* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(zvtestdelegate2), Wrap_ZVTestDelegate2, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNI_TO_RUBY_VALUE(p1), LNI_TO_RUBY_VALUE(p2));
    *outReturn = LNRB_VALUE_TO_NUMBER(retval);
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNZVTestDelegate2_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestDelegate2* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestDelegate2, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNZVTestDelegate2_Create(Wrap_LNZVTestDelegate2_ZVTestDelegate2_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ln::ZVTestDelegate2::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::ZVTestDelegate3

struct Wrap_ZVTestDelegate3
    : public Wrap_Object
{

    VALUE m_proc = Qnil;
    Wrap_ZVTestDelegate3()
    {}
};

static void LNZVTestDelegate3_delete(Wrap_ZVTestDelegate3* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNZVTestDelegate3_mark(Wrap_ZVTestDelegate3* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNZVTestDelegate3_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ZVTestDelegate3* internalObj;

    internalObj = new Wrap_ZVTestDelegate3();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestDelegate3_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestDelegate3_mark, LNZVTestDelegate3_delete, internalObj);

    return obj;
}

static VALUE LNZVTestDelegate3_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ZVTestDelegate3* internalObj;

    internalObj = new Wrap_ZVTestDelegate3();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestDelegate3_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestDelegate3_mark, LNZVTestDelegate3_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNZVTestDelegate3_ZVTestDelegate3_ProcCaller(LNHandle zvtestdelegate3, LNHandle p1)
{
    Wrap_ZVTestDelegate3* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(zvtestdelegate3), Wrap_ZVTestDelegate3, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(p1));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNZVTestDelegate3_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestDelegate3* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestDelegate3, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNZVTestDelegate3_Create(Wrap_LNZVTestDelegate3_ZVTestDelegate3_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ln::ZVTestDelegate3::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::ZVTestEventHandler1

struct Wrap_ZVTestEventHandler1
    : public Wrap_Object
{

    VALUE m_proc = Qnil;
    Wrap_ZVTestEventHandler1()
    {}
};

static void LNZVTestEventHandler1_delete(Wrap_ZVTestEventHandler1* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNZVTestEventHandler1_mark(Wrap_ZVTestEventHandler1* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNZVTestEventHandler1_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ZVTestEventHandler1* internalObj;

    internalObj = new Wrap_ZVTestEventHandler1();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestEventHandler1_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestEventHandler1_mark, LNZVTestEventHandler1_delete, internalObj);

    return obj;
}

static VALUE LNZVTestEventHandler1_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ZVTestEventHandler1* internalObj;

    internalObj = new Wrap_ZVTestEventHandler1();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestEventHandler1_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestEventHandler1_mark, LNZVTestEventHandler1_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNZVTestEventHandler1_ZVTestEventHandler1_ProcCaller(LNHandle zvtesteventhandler1)
{
    Wrap_ZVTestEventHandler1* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(zvtesteventhandler1), Wrap_ZVTestEventHandler1, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 0, );
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNZVTestEventHandler1_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestEventHandler1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestEventHandler1, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNZVTestEventHandler1_Create(Wrap_LNZVTestEventHandler1_ZVTestEventHandler1_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ln::ZVTestEventHandler1::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::ZVTestEventHandler2

struct Wrap_ZVTestEventHandler2
    : public Wrap_Object
{

    VALUE m_proc = Qnil;
    Wrap_ZVTestEventHandler2()
    {}
};

static void LNZVTestEventHandler2_delete(Wrap_ZVTestEventHandler2* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNZVTestEventHandler2_mark(Wrap_ZVTestEventHandler2* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNZVTestEventHandler2_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ZVTestEventHandler2* internalObj;

    internalObj = new Wrap_ZVTestEventHandler2();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestEventHandler2_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestEventHandler2_mark, LNZVTestEventHandler2_delete, internalObj);

    return obj;
}

static VALUE LNZVTestEventHandler2_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ZVTestEventHandler2* internalObj;

    internalObj = new Wrap_ZVTestEventHandler2();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestEventHandler2_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestEventHandler2_mark, LNZVTestEventHandler2_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNZVTestEventHandler2_ZVTestEventHandler2_ProcCaller(LNHandle zvtesteventhandler2, LNHandle p1)
{
    Wrap_ZVTestEventHandler2* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(zvtesteventhandler2), Wrap_ZVTestEventHandler2, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(p1));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNZVTestEventHandler2_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestEventHandler2* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestEventHandler2, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNZVTestEventHandler2_Create(Wrap_LNZVTestEventHandler2_ZVTestEventHandler2_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ln::ZVTestEventHandler2::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::ZVTestPromise1

struct Wrap_ZVTestPromise1
    : public Wrap_Object
{

    Wrap_ZVTestPromise1()
    {}
};

static void LNZVTestPromise1_delete(Wrap_ZVTestPromise1* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNZVTestPromise1_mark(Wrap_ZVTestPromise1* obj)
{
	

}

static VALUE LNZVTestPromise1_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ZVTestPromise1* internalObj;

    internalObj = new Wrap_ZVTestPromise1();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestPromise1_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestPromise1_mark, LNZVTestPromise1_delete, internalObj);

    return obj;
}

static VALUE LNZVTestPromise1_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ZVTestPromise1* internalObj;

    internalObj = new Wrap_ZVTestPromise1();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestPromise1_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestPromise1_mark, LNZVTestPromise1_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNZVTestPromise1_ThenWith(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestPromise1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestPromise1, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE callback;
        rb_scan_args(argc, argv, "1", &callback);
        if (LNRB_VALUE_IS_OBJECT(callback))
        {
            LNHandle _callback = LuminoRubyRuntimeManager::instance->getHandle(callback);
            LNResult errorCode = LNZVTestPromise1_ThenWith(selfObj->handle, _callback);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_ZVTestDelegate3, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult result = LNZVTestPromise1_ThenWith(selfObj->handle, _value);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestPromise1::thenWith - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestPromise1_CatchWith(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestPromise1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestPromise1, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE callback;
        rb_scan_args(argc, argv, "1", &callback);
        if (LNRB_VALUE_IS_OBJECT(callback))
        {
            LNHandle _callback = LuminoRubyRuntimeManager::instance->getHandle(callback);
            LNResult errorCode = LNZVTestPromise1_CatchWith(selfObj->handle, _callback);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_PromiseFailureDelegate, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult result = LNZVTestPromise1_CatchWith(selfObj->handle, _value);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestPromise1::catchWith - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::ZVTestPromise2

struct Wrap_ZVTestPromise2
    : public Wrap_Object
{

    Wrap_ZVTestPromise2()
    {}
};

static void LNZVTestPromise2_delete(Wrap_ZVTestPromise2* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNZVTestPromise2_mark(Wrap_ZVTestPromise2* obj)
{
	

}

static VALUE LNZVTestPromise2_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ZVTestPromise2* internalObj;

    internalObj = new Wrap_ZVTestPromise2();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestPromise2_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestPromise2_mark, LNZVTestPromise2_delete, internalObj);

    return obj;
}

static VALUE LNZVTestPromise2_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ZVTestPromise2* internalObj;

    internalObj = new Wrap_ZVTestPromise2();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestPromise2_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestPromise2_mark, LNZVTestPromise2_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNZVTestPromise2_ThenWith(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestPromise2* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestPromise2, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE callback;
        rb_scan_args(argc, argv, "1", &callback);
        if (LNRB_VALUE_IS_OBJECT(callback))
        {
            LNHandle _callback = LuminoRubyRuntimeManager::instance->getHandle(callback);
            LNResult errorCode = LNZVTestPromise2_ThenWith(selfObj->handle, _callback);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_ZVTestDelegate1, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult result = LNZVTestPromise2_ThenWith(selfObj->handle, _value);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestPromise2::thenWith - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestPromise2_CatchWith(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestPromise2* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestPromise2, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE callback;
        rb_scan_args(argc, argv, "1", &callback);
        if (LNRB_VALUE_IS_OBJECT(callback))
        {
            LNHandle _callback = LuminoRubyRuntimeManager::instance->getHandle(callback);
            LNResult errorCode = LNZVTestPromise2_CatchWith(selfObj->handle, _callback);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_PromiseFailureDelegate, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult result = LNZVTestPromise2_CatchWith(selfObj->handle, _value);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestPromise2::catchWith - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::ZVTestClass1

struct Wrap_ZVTestClass1
    : public Wrap_Object
{

    Wrap_ZVTestClass1()
    {}
};

static void LNZVTestClass1_delete(Wrap_ZVTestClass1* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNZVTestClass1_mark(Wrap_ZVTestClass1* obj)
{
	

}

static VALUE LNZVTestClass1_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ZVTestClass1* internalObj;

    internalObj = new Wrap_ZVTestClass1();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestClass1_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestClass1_mark, LNZVTestClass1_delete, internalObj);

    return obj;
}

static VALUE LNZVTestClass1_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ZVTestClass1* internalObj;

    internalObj = new Wrap_ZVTestClass1();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestClass1_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestClass1_mark, LNZVTestClass1_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNZVTestClass1_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNZVTestClass1_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestClass1_SetTestDelegate1(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult errorCode = LNZVTestClass1_SetTestDelegate1(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_ZVTestDelegate1, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult result = LNZVTestClass1_SetTestDelegate1(selfObj->handle, _value);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::setTestDelegate1 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestClass1_SetTestDelegate2(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult errorCode = LNZVTestClass1_SetTestDelegate2(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_ZVTestDelegate2, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult result = LNZVTestClass1_SetTestDelegate2(selfObj->handle, _value);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::setTestDelegate2 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestClass1_SetTestDelegate3(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult errorCode = LNZVTestClass1_SetTestDelegate3(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_ZVTestDelegate3, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult result = LNZVTestClass1_SetTestDelegate3(selfObj->handle, _value);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::setTestDelegate3 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestClass1_CallTestDelegate1(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE a;
        rb_scan_args(argc, argv, "1", &a);
        if (LNRB_VALUE_IS_NUMBER(a))
        {
            int _a = LNRB_VALUE_TO_NUMBER(a);
            LNResult errorCode = LNZVTestClass1_CallTestDelegate1(selfObj->handle, _a);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::callTestDelegate1 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestClass1_CallTestDelegate2(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1, selfObj);
    if (2 <= argc && argc <= 2) {
        VALUE a;
        VALUE b;
        rb_scan_args(argc, argv, "2", &a, &b);
        if (LNRB_VALUE_IS_NUMBER(a) && LNRB_VALUE_IS_NUMBER(b))
        {
            int _a = LNRB_VALUE_TO_NUMBER(a);
            int _b = LNRB_VALUE_TO_NUMBER(b);
            int _outReturn;
            LNResult errorCode = LNZVTestClass1_CallTestDelegate2(selfObj->handle, _a, _b, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::callTestDelegate2 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestClass1_CallTestDelegate3(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNZVTestClass1_CallTestDelegate3(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::callTestDelegate3 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestClass1_LoadAsync(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE filePath;
        rb_scan_args(argc, argv, "1", &filePath);
        if (LNRB_VALUE_IS_STRING(filePath))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNHandle _outReturn;
            LNResult errorCode = LNZVTestClass1_LoadAsyncA(_filePath, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::loadAsync - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestClass1_ExecuteAsync(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNZVTestClass1_ExecuteAsync(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::executeAsync - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestClass1_GetFilePath(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            const char* _outReturn;
            LNResult errorCode = LNZVTestClass1_GetFilePathA(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::filePath - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestClass1_ConnectOnEvent1(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE handler;
        rb_scan_args(argc, argv, "1", &handler);
        if (LNRB_VALUE_IS_OBJECT(handler))
        {
            LNHandle _handler = LuminoRubyRuntimeManager::instance->getHandle(handler);
            LNHandle _outReturn;
            LNResult errorCode = LNZVTestClass1_ConnectOnEvent1(selfObj->handle, _handler, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_ZVTestEventHandler1, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNHandle _outReturn;
            LNResult result = LNZVTestClass1_ConnectOnEvent1(selfObj->handle, _value, &_outReturn);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::connectOnEvent1 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestClass1_RaiseEvent1(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNZVTestClass1_RaiseEvent1(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::raiseEvent1 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestClass1_ConnectOnEvent2(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE handler;
        rb_scan_args(argc, argv, "1", &handler);
        if (LNRB_VALUE_IS_OBJECT(handler))
        {
            LNHandle _handler = LuminoRubyRuntimeManager::instance->getHandle(handler);
            LNHandle _outReturn;
            LNResult errorCode = LNZVTestClass1_ConnectOnEvent2(selfObj->handle, _handler, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_ZVTestEventHandler2, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNHandle _outReturn;
            LNResult result = LNZVTestClass1_ConnectOnEvent2(selfObj->handle, _value, &_outReturn);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::connectOnEvent2 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestClass1_RaiseEvent2(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNZVTestClass1_RaiseEvent2(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestClass1::raiseEvent2 - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNZVTestClass1_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::ZVTestEventArgs1

struct Wrap_ZVTestEventArgs1
    : public Wrap_Object
{

    Wrap_ZVTestEventArgs1()
    {}
};

static void LNZVTestEventArgs1_delete(Wrap_ZVTestEventArgs1* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNZVTestEventArgs1_mark(Wrap_ZVTestEventArgs1* obj)
{
	

}

static VALUE LNZVTestEventArgs1_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ZVTestEventArgs1* internalObj;

    internalObj = new Wrap_ZVTestEventArgs1();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestEventArgs1_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestEventArgs1_mark, LNZVTestEventArgs1_delete, internalObj);

    return obj;
}

static VALUE LNZVTestEventArgs1_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ZVTestEventArgs1* internalObj;

    internalObj = new Wrap_ZVTestEventArgs1();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestEventArgs1_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestEventArgs1_mark, LNZVTestEventArgs1_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNZVTestEventArgs1_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestEventArgs1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestEventArgs1, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNZVTestEventArgs1_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (1 <= argc && argc <= 1) {
        VALUE v;
        rb_scan_args(argc, argv, "1", &v);
        if (LNRB_VALUE_IS_NUMBER(v))
        {
            int _v = LNRB_VALUE_TO_NUMBER(v);
            LNResult errorCode = LNZVTestEventArgs1_CreateWithValue(_v, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestEventArgs1::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNZVTestEventArgs1_GetValue(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestEventArgs1* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestEventArgs1, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            int _outReturn;
            LNResult errorCode = LNZVTestEventArgs1_GetValue(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::ZVTestEventArgs1::value - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNZVTestEventArgs1_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::Serializer2

struct Wrap_Serializer2
    : public Wrap_Object
{

    Wrap_Serializer2()
    {}
};

static void LNSerializer2_delete(Wrap_Serializer2* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSerializer2_mark(Wrap_Serializer2* obj)
{
	

}

static VALUE LNSerializer2_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Serializer2* internalObj;

    internalObj = new Wrap_Serializer2();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSerializer2_allocate");
    obj = Data_Wrap_Struct(klass, LNSerializer2_mark, LNSerializer2_delete, internalObj);

    return obj;
}

static VALUE LNSerializer2_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Serializer2* internalObj;

    internalObj = new Wrap_Serializer2();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSerializer2_allocate");
    obj = Data_Wrap_Struct(klass, LNSerializer2_mark, LNSerializer2_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNSerializer2_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::AssetObject

struct Wrap_AssetObject
    : public Wrap_Object
{

    Wrap_AssetObject()
    {}
};

static void LNAssetObject_delete(Wrap_AssetObject* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAssetObject_mark(Wrap_AssetObject* obj)
{
	

}

static VALUE LNAssetObject_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AssetObject* internalObj;

    internalObj = new Wrap_AssetObject();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAssetObject_allocate");
    obj = Data_Wrap_Struct(klass, LNAssetObject_mark, LNAssetObject_delete, internalObj);

    return obj;
}

static VALUE LNAssetObject_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AssetObject* internalObj;

    internalObj = new Wrap_AssetObject();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAssetObject_allocate");
    obj = Data_Wrap_Struct(klass, LNAssetObject_mark, LNAssetObject_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNAssetObject_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::AssetImportSettings

struct Wrap_AssetImportSettings
    : public Wrap_Object
{

    Wrap_AssetImportSettings()
    {}
};

static void LNAssetImportSettings_delete(Wrap_AssetImportSettings* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAssetImportSettings_mark(Wrap_AssetImportSettings* obj)
{
	

}

static VALUE LNAssetImportSettings_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AssetImportSettings* internalObj;

    internalObj = new Wrap_AssetImportSettings();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAssetImportSettings_allocate");
    obj = Data_Wrap_Struct(klass, LNAssetImportSettings_mark, LNAssetImportSettings_delete, internalObj);

    return obj;
}

static VALUE LNAssetImportSettings_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AssetImportSettings* internalObj;

    internalObj = new Wrap_AssetImportSettings();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAssetImportSettings_allocate");
    obj = Data_Wrap_Struct(klass, LNAssetImportSettings_mark, LNAssetImportSettings_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNAssetImportSettings_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::AssetModel

struct Wrap_AssetModel
    : public Wrap_Object
{

    Wrap_AssetModel()
    {}
};

static void LNAssetModel_delete(Wrap_AssetModel* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAssetModel_mark(Wrap_AssetModel* obj)
{
	

}

static VALUE LNAssetModel_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AssetModel* internalObj;

    internalObj = new Wrap_AssetModel();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAssetModel_allocate");
    obj = Data_Wrap_Struct(klass, LNAssetModel_mark, LNAssetModel_delete, internalObj);

    return obj;
}

static VALUE LNAssetModel_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AssetModel* internalObj;

    internalObj = new Wrap_AssetModel();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAssetModel_allocate");
    obj = Data_Wrap_Struct(klass, LNAssetModel_mark, LNAssetModel_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNAssetModel_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_AssetModel* selfObj;
    Data_Get_Struct(self, Wrap_AssetModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE target;
        rb_scan_args(argc, argv, "1", &target);
        if (LNRB_VALUE_IS_OBJECT(target))
        {
            LNHandle _target = LuminoRubyRuntimeManager::instance->getHandle(target);
            LNResult errorCode = LNAssetModel_Create(_target, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::AssetModel::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAssetModel_Target(int argc, VALUE* argv, VALUE self)
{
    Wrap_AssetModel* selfObj;
    Data_Get_Struct(self, Wrap_AssetModel, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNAssetModel_Target(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::AssetModel::target - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNAssetModel_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::Assets

struct Wrap_Assets
{

    Wrap_Assets()
    {}
};


static VALUE Wrap_LNAssets_SaveAssetToLocalFile(int argc, VALUE* argv, VALUE self)
{
    if (2 <= argc && argc <= 2) {
        VALUE asset;
        VALUE filePath;
        rb_scan_args(argc, argv, "2", &asset, &filePath);
        if (LNRB_VALUE_IS_OBJECT(asset) && LNRB_VALUE_IS_STRING(filePath))
        {
            LNHandle _asset = LuminoRubyRuntimeManager::instance->getHandle(asset);
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNResult errorCode = LNAssets_SaveAssetToLocalFileA(_asset, _filePath);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Assets::saveAssetToLocalFile - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAssets_LoadAssetFromLocalFile(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE filePath;
        rb_scan_args(argc, argv, "1", &filePath);
        if (LNRB_VALUE_IS_STRING(filePath))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNHandle _outReturn;
            LNResult errorCode = LNAssets_LoadAssetFromLocalFileA(_filePath, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Assets::loadAssetFromLocalFile - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAssets_LoadAsset(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE filePath;
        rb_scan_args(argc, argv, "1", &filePath);
        if (LNRB_VALUE_IS_STRING(filePath))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNHandle _outReturn;
            LNResult errorCode = LNAssets_LoadAssetA(_filePath, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Assets::loadAsset - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAssets_ReloadAsset(int argc, VALUE* argv, VALUE self)
{
    if (2 <= argc && argc <= 2) {
        VALUE filePath;
        VALUE obj;
        rb_scan_args(argc, argv, "2", &filePath, &obj);
        if (LNRB_VALUE_IS_STRING(filePath) && LNRB_VALUE_IS_OBJECT(obj))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNHandle _obj = LuminoRubyRuntimeManager::instance->getHandle(obj);
            LNResult errorCode = LNAssets_ReloadAssetA(_filePath, _obj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Assets::reloadAsset - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAssets_ReadAllText(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 2) {
        VALUE filePath;
        VALUE encoding;
        rb_scan_args(argc, argv, "11", &filePath, &encoding);
        if (LNRB_VALUE_IS_STRING(filePath) && LNRB_VALUE_IS_NUMBER(encoding))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNEncodingType _encoding = (encoding != Qnil) ? (LNEncodingType)FIX2INT(encoding) : (LNEncodingType)0;
            const char* _outReturn;
            LNResult errorCode = LNAssets_ReadAllTextA(_filePath, _encoding, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Assets::readAllText - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::Sound

struct Wrap_Sound
    : public Wrap_Object
{

    Wrap_Sound()
    {}
};

static void LNSound_delete(Wrap_Sound* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSound_mark(Wrap_Sound* obj)
{
	

}

static VALUE LNSound_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Sound* internalObj;

    internalObj = new Wrap_Sound();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSound_allocate");
    obj = Data_Wrap_Struct(klass, LNSound_mark, LNSound_delete, internalObj);

    return obj;
}

static VALUE LNSound_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Sound* internalObj;

    internalObj = new Wrap_Sound();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSound_allocate");
    obj = Data_Wrap_Struct(klass, LNSound_mark, LNSound_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNSound_SetVolume(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sound* selfObj;
    Data_Get_Struct(self, Wrap_Sound, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNSound_SetVolume(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sound::setVolume - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSound_GetVolume(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sound* selfObj;
    Data_Get_Struct(self, Wrap_Sound, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNSound_GetVolume(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Sound::getVolume - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSound_SetPitch(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sound* selfObj;
    Data_Get_Struct(self, Wrap_Sound, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNSound_SetPitch(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sound::setPitch - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSound_GetPitch(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sound* selfObj;
    Data_Get_Struct(self, Wrap_Sound, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNSound_GetPitch(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Sound::getPitch - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSound_SetLoopEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sound* selfObj;
    Data_Get_Struct(self, Wrap_Sound, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE enabled;
        rb_scan_args(argc, argv, "1", &enabled);
        if (LNRB_VALUE_IS_BOOL(enabled))
        {
            LNBool _enabled = LNRB_VALUE_TO_BOOL(enabled);
            LNResult errorCode = LNSound_SetLoopEnabled(selfObj->handle, _enabled);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sound::setLoopEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSound_IsLoopEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sound* selfObj;
    Data_Get_Struct(self, Wrap_Sound, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNSound_IsLoopEnabled(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Sound::isLoopEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSound_SetLoopRange(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sound* selfObj;
    Data_Get_Struct(self, Wrap_Sound, selfObj);
    if (2 <= argc && argc <= 2) {
        VALUE begin;
        VALUE length;
        rb_scan_args(argc, argv, "2", &begin, &length);
        if (LNRB_VALUE_IS_NUMBER(begin) && LNRB_VALUE_IS_NUMBER(length))
        {
            uint32_t _begin = LNRB_VALUE_TO_NUMBER(begin);
            uint32_t _length = LNRB_VALUE_TO_NUMBER(length);
            LNResult errorCode = LNSound_SetLoopRange(selfObj->handle, _begin, _length);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sound::SetLoopRange - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSound_Play(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sound* selfObj;
    Data_Get_Struct(self, Wrap_Sound, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNSound_Play(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sound::play - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSound_Stop(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sound* selfObj;
    Data_Get_Struct(self, Wrap_Sound, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNSound_Stop(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sound::stop - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSound_Pause(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sound* selfObj;
    Data_Get_Struct(self, Wrap_Sound, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNSound_Pause(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sound::pause - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSound_Resume(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sound* selfObj;
    Data_Get_Struct(self, Wrap_Sound, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNSound_Resume(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sound::resume - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSound_FadeVolume(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sound* selfObj;
    Data_Get_Struct(self, Wrap_Sound, selfObj);
    if (3 <= argc && argc <= 3) {
        VALUE targetVolume;
        VALUE time;
        VALUE behavior;
        rb_scan_args(argc, argv, "3", &targetVolume, &time, &behavior);
        if (LNRB_VALUE_IS_FLOAT(targetVolume) && LNRB_VALUE_IS_FLOAT(time) && LNRB_VALUE_IS_NUMBER(behavior))
        {
            float _targetVolume = LNRB_VALUE_TO_FLOAT(targetVolume);
            float _time = LNRB_VALUE_TO_FLOAT(time);
            LNSoundFadeBehavior _behavior = (LNSoundFadeBehavior)FIX2INT(behavior);
            LNResult errorCode = LNSound_FadeVolume(selfObj->handle, _targetVolume, _time, _behavior);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sound::fadeVolume - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNSound_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::Audio

struct Wrap_Audio
{

    Wrap_Audio()
    {}
};


static VALUE Wrap_LNAudio_PlayBGM(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 4) {
        VALUE filePath;
        VALUE volume;
        VALUE pitch;
        VALUE fadeTime;
        rb_scan_args(argc, argv, "13", &filePath, &volume, &pitch, &fadeTime);
        if (LNRB_VALUE_IS_STRING(filePath) && LNRB_VALUE_IS_FLOAT(volume) && LNRB_VALUE_IS_FLOAT(pitch) && LNRB_VALUE_IS_FLOAT(fadeTime))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            float _volume = (volume != Qnil) ? LNRB_VALUE_TO_FLOAT(volume) : 1.000000;
            float _pitch = (pitch != Qnil) ? LNRB_VALUE_TO_FLOAT(pitch) : 1.000000;
            double _fadeTime = (fadeTime != Qnil) ? LNRB_VALUE_TO_FLOAT(fadeTime) : 0.000000;
            LNResult errorCode = LNAudio_PlayBGMA(_filePath, _volume, _pitch, _fadeTime);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Audio::playBGM - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAudio_StopBGM(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE fadeTime;
        rb_scan_args(argc, argv, "01", &fadeTime);
        if (LNRB_VALUE_IS_FLOAT(fadeTime))
        {
            double _fadeTime = (fadeTime != Qnil) ? LNRB_VALUE_TO_FLOAT(fadeTime) : 0.000000;
            LNResult errorCode = LNAudio_StopBGM(_fadeTime);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Audio::stopBGM - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAudio_PlayBGS(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 4) {
        VALUE filePath;
        VALUE volume;
        VALUE pitch;
        VALUE fadeTime;
        rb_scan_args(argc, argv, "13", &filePath, &volume, &pitch, &fadeTime);
        if (LNRB_VALUE_IS_STRING(filePath) && LNRB_VALUE_IS_FLOAT(volume) && LNRB_VALUE_IS_FLOAT(pitch) && LNRB_VALUE_IS_FLOAT(fadeTime))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            float _volume = (volume != Qnil) ? LNRB_VALUE_TO_FLOAT(volume) : 1.000000;
            float _pitch = (pitch != Qnil) ? LNRB_VALUE_TO_FLOAT(pitch) : 1.000000;
            double _fadeTime = (fadeTime != Qnil) ? LNRB_VALUE_TO_FLOAT(fadeTime) : 0.000000;
            LNResult errorCode = LNAudio_PlayBGSA(_filePath, _volume, _pitch, _fadeTime);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Audio::playBGS - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAudio_StopBGS(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE fadeTime;
        rb_scan_args(argc, argv, "01", &fadeTime);
        if (LNRB_VALUE_IS_FLOAT(fadeTime))
        {
            double _fadeTime = (fadeTime != Qnil) ? LNRB_VALUE_TO_FLOAT(fadeTime) : 0.000000;
            LNResult errorCode = LNAudio_StopBGS(_fadeTime);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Audio::stopBGS - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAudio_PlayME(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 3) {
        VALUE filePath;
        VALUE volume;
        VALUE pitch;
        rb_scan_args(argc, argv, "12", &filePath, &volume, &pitch);
        if (LNRB_VALUE_IS_STRING(filePath) && LNRB_VALUE_IS_FLOAT(volume) && LNRB_VALUE_IS_FLOAT(pitch))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            float _volume = (volume != Qnil) ? LNRB_VALUE_TO_FLOAT(volume) : 1.000000;
            float _pitch = (pitch != Qnil) ? LNRB_VALUE_TO_FLOAT(pitch) : 1.000000;
            LNResult errorCode = LNAudio_PlayMEA(_filePath, _volume, _pitch);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Audio::playME - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAudio_StopME(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNAudio_StopME();
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Audio::stopME - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAudio_PlaySE(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 3) {
        VALUE filePath;
        VALUE volume;
        VALUE pitch;
        rb_scan_args(argc, argv, "12", &filePath, &volume, &pitch);
        if (LNRB_VALUE_IS_STRING(filePath) && LNRB_VALUE_IS_FLOAT(volume) && LNRB_VALUE_IS_FLOAT(pitch))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            float _volume = (volume != Qnil) ? LNRB_VALUE_TO_FLOAT(volume) : 1.000000;
            float _pitch = (pitch != Qnil) ? LNRB_VALUE_TO_FLOAT(pitch) : 1.000000;
            LNResult errorCode = LNAudio_PlaySEA(_filePath, _volume, _pitch);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Audio::playSE - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAudio_PlaySE3D(int argc, VALUE* argv, VALUE self)
{
    if (3 <= argc && argc <= 5) {
        VALUE filePath;
        VALUE position;
        VALUE distance;
        VALUE volume;
        VALUE pitch;
        rb_scan_args(argc, argv, "32", &filePath, &position, &distance, &volume, &pitch);
        if (LNRB_VALUE_IS_STRING(filePath) && LNRB_VALUE_IS_OBJECT(position) && LNRB_VALUE_IS_FLOAT(distance) && LNRB_VALUE_IS_FLOAT(volume) && LNRB_VALUE_IS_FLOAT(pitch))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNVector3* tmp__position; Data_Get_Struct(position, LNVector3, tmp__position);LNVector3& _position = *tmp__position;
            float _distance = LNRB_VALUE_TO_FLOAT(distance);
            float _volume = (volume != Qnil) ? LNRB_VALUE_TO_FLOAT(volume) : 1.000000;
            float _pitch = (pitch != Qnil) ? LNRB_VALUE_TO_FLOAT(pitch) : 1.000000;
            LNResult errorCode = LNAudio_PlaySE3DA(_filePath, &_position, _distance, _volume, _pitch);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Audio::playSE3D - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAudio_StopSE(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNAudio_StopSE();
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Audio::stopSE - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::Texture2DDelegate

struct Wrap_Texture2DDelegate
    : public Wrap_Object
{

    VALUE m_proc = Qnil;
    Wrap_Texture2DDelegate()
    {}
};

static void LNTexture2DDelegate_delete(Wrap_Texture2DDelegate* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNTexture2DDelegate_mark(Wrap_Texture2DDelegate* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNTexture2DDelegate_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Texture2DDelegate* internalObj;

    internalObj = new Wrap_Texture2DDelegate();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTexture2DDelegate_allocate");
    obj = Data_Wrap_Struct(klass, LNTexture2DDelegate_mark, LNTexture2DDelegate_delete, internalObj);

    return obj;
}

static VALUE LNTexture2DDelegate_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Texture2DDelegate* internalObj;

    internalObj = new Wrap_Texture2DDelegate();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTexture2DDelegate_allocate");
    obj = Data_Wrap_Struct(klass, LNTexture2DDelegate_mark, LNTexture2DDelegate_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNTexture2DDelegate_Texture2DDelegate_ProcCaller(LNHandle texture2ddelegate, LNHandle p1)
{
    Wrap_Texture2DDelegate* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(texture2ddelegate), Wrap_Texture2DDelegate, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(p1));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNTexture2DDelegate_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_Texture2DDelegate* selfObj;
    Data_Get_Struct(self, Wrap_Texture2DDelegate, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNTexture2DDelegate_Create(Wrap_LNTexture2DDelegate_Texture2DDelegate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ln::Texture2DDelegate::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::Texture2DPromise

struct Wrap_Texture2DPromise
    : public Wrap_Object
{

    Wrap_Texture2DPromise()
    {}
};

static void LNTexture2DPromise_delete(Wrap_Texture2DPromise* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNTexture2DPromise_mark(Wrap_Texture2DPromise* obj)
{
	

}

static VALUE LNTexture2DPromise_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Texture2DPromise* internalObj;

    internalObj = new Wrap_Texture2DPromise();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTexture2DPromise_allocate");
    obj = Data_Wrap_Struct(klass, LNTexture2DPromise_mark, LNTexture2DPromise_delete, internalObj);

    return obj;
}

static VALUE LNTexture2DPromise_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Texture2DPromise* internalObj;

    internalObj = new Wrap_Texture2DPromise();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTexture2DPromise_allocate");
    obj = Data_Wrap_Struct(klass, LNTexture2DPromise_mark, LNTexture2DPromise_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNTexture2DPromise_ThenWith(int argc, VALUE* argv, VALUE self)
{
    Wrap_Texture2DPromise* selfObj;
    Data_Get_Struct(self, Wrap_Texture2DPromise, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE callback;
        rb_scan_args(argc, argv, "1", &callback);
        if (LNRB_VALUE_IS_OBJECT(callback))
        {
            LNHandle _callback = LuminoRubyRuntimeManager::instance->getHandle(callback);
            LNResult errorCode = LNTexture2DPromise_ThenWith(selfObj->handle, _callback);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_Texture2DDelegate, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult result = LNTexture2DPromise_ThenWith(selfObj->handle, _value);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Texture2DPromise::thenWith - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNTexture2DPromise_CatchWith(int argc, VALUE* argv, VALUE self)
{
    Wrap_Texture2DPromise* selfObj;
    Data_Get_Struct(self, Wrap_Texture2DPromise, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE callback;
        rb_scan_args(argc, argv, "1", &callback);
        if (LNRB_VALUE_IS_OBJECT(callback))
        {
            LNHandle _callback = LuminoRubyRuntimeManager::instance->getHandle(callback);
            LNResult errorCode = LNTexture2DPromise_CatchWith(selfObj->handle, _callback);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_PromiseFailureDelegate, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult result = LNTexture2DPromise_CatchWith(selfObj->handle, _value);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Texture2DPromise::catchWith - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::Graphics

struct Wrap_Graphics
{

    Wrap_Graphics()
    {}
};


static VALUE Wrap_LNGraphics_GetActiveGraphicsAPI(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNGraphicsAPI _outReturn;
            LNResult errorCode = LNGraphics_GetActiveGraphicsAPI(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return INT2FIX(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Graphics::activeGraphicsAPI - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::Texture

struct Wrap_Texture
    : public Wrap_AssetObject
{

    Wrap_Texture()
    {}
};

static void LNTexture_delete(Wrap_Texture* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNTexture_mark(Wrap_Texture* obj)
{
	

}

static VALUE LNTexture_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Texture* internalObj;

    internalObj = new Wrap_Texture();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTexture_allocate");
    obj = Data_Wrap_Struct(klass, LNTexture_mark, LNTexture_delete, internalObj);

    return obj;
}

static VALUE LNTexture_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Texture* internalObj;

    internalObj = new Wrap_Texture();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTexture_allocate");
    obj = Data_Wrap_Struct(klass, LNTexture_mark, LNTexture_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNTexture_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::Texture2D

struct Wrap_Texture2D
    : public Wrap_Texture
{

    Wrap_Texture2D()
    {}
};

static void LNTexture2D_delete(Wrap_Texture2D* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNTexture2D_mark(Wrap_Texture2D* obj)
{
	

}

static VALUE LNTexture2D_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Texture2D* internalObj;

    internalObj = new Wrap_Texture2D();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTexture2D_allocate");
    obj = Data_Wrap_Struct(klass, LNTexture2D_mark, LNTexture2D_delete, internalObj);

    return obj;
}

static VALUE LNTexture2D_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Texture2D* internalObj;

    internalObj = new Wrap_Texture2D();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTexture2D_allocate");
    obj = Data_Wrap_Struct(klass, LNTexture2D_mark, LNTexture2D_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNTexture2D_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_Texture2D* selfObj;
    Data_Get_Struct(self, Wrap_Texture2D, selfObj);
    if (2 <= argc && argc <= 2) {
        VALUE width;
        VALUE height;
        rb_scan_args(argc, argv, "2", &width, &height);
        if (LNRB_VALUE_IS_NUMBER(width) && LNRB_VALUE_IS_NUMBER(height))
        {
            int _width = LNRB_VALUE_TO_NUMBER(width);
            int _height = LNRB_VALUE_TO_NUMBER(height);
            LNResult errorCode = LNTexture2D_Create(_width, _height, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (3 <= argc && argc <= 3) {
        VALUE width;
        VALUE height;
        VALUE format;
        rb_scan_args(argc, argv, "3", &width, &height, &format);
        if (LNRB_VALUE_IS_NUMBER(width) && LNRB_VALUE_IS_NUMBER(height) && LNRB_VALUE_IS_NUMBER(format))
        {
            int _width = LNRB_VALUE_TO_NUMBER(width);
            int _height = LNRB_VALUE_TO_NUMBER(height);
            LNTextureFormat _format = (LNTextureFormat)FIX2INT(format);
            LNResult errorCode = LNTexture2D_CreateWithFormat(_width, _height, _format, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Texture2D::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNTexture2D_Load(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE filePath;
        rb_scan_args(argc, argv, "1", &filePath);
        if (LNRB_VALUE_IS_STRING(filePath))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNHandle _outReturn;
            LNResult errorCode = LNTexture2D_LoadA(_filePath, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Texture2D::load - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNTexture2D_LoadEmoji(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE code;
        rb_scan_args(argc, argv, "1", &code);
        if (LNRB_VALUE_IS_STRING(code))
        {
            const char* _code = LNRB_VALUE_TO_STRING(code);
            LNHandle _outReturn;
            LNResult errorCode = LNTexture2D_LoadEmojiA(_code, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Texture2D::loadEmoji - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNTexture2D_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::Shader

struct Wrap_Shader
    : public Wrap_AssetObject
{

    Wrap_Shader()
    {}
};

static void LNShader_delete(Wrap_Shader* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNShader_mark(Wrap_Shader* obj)
{
	

}

static VALUE LNShader_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Shader* internalObj;

    internalObj = new Wrap_Shader();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNShader_allocate");
    obj = Data_Wrap_Struct(klass, LNShader_mark, LNShader_delete, internalObj);

    return obj;
}

static VALUE LNShader_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Shader* internalObj;

    internalObj = new Wrap_Shader();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNShader_allocate");
    obj = Data_Wrap_Struct(klass, LNShader_mark, LNShader_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNShader_Load(int argc, VALUE* argv, VALUE self)
{
    if (2 <= argc && argc <= 2) {
        VALUE filePath;
        VALUE settings;
        rb_scan_args(argc, argv, "2", &filePath, &settings);
        if (LNRB_VALUE_IS_STRING(filePath) && LNRB_VALUE_IS_OBJECT(settings))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNHandle _settings = LuminoRubyRuntimeManager::instance->getHandle(settings);
            LNHandle _outReturn;
            LNResult errorCode = LNShader_LoadA(_filePath, _settings, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Shader::load - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNShader_SetFloat(int argc, VALUE* argv, VALUE self)
{
    Wrap_Shader* selfObj;
    Data_Get_Struct(self, Wrap_Shader, selfObj);
    if (2 <= argc && argc <= 2) {
        VALUE parameterName;
        VALUE value;
        rb_scan_args(argc, argv, "2", &parameterName, &value);
        if (LNRB_VALUE_IS_STRING(parameterName) && LNRB_VALUE_IS_FLOAT(value))
        {
            const char* _parameterName = LNRB_VALUE_TO_STRING(parameterName);
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNShader_SetFloatA(selfObj->handle, _parameterName, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Shader::setFloat - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNShader_SetVector3(int argc, VALUE* argv, VALUE self)
{
    Wrap_Shader* selfObj;
    Data_Get_Struct(self, Wrap_Shader, selfObj);
    if (2 <= argc && argc <= 2) {
        VALUE parameterName;
        VALUE value;
        rb_scan_args(argc, argv, "2", &parameterName, &value);
        if (LNRB_VALUE_IS_STRING(parameterName) && LNRB_VALUE_IS_OBJECT(value))
        {
            const char* _parameterName = LNRB_VALUE_TO_STRING(parameterName);
            LNVector3* tmp__value; Data_Get_Struct(value, LNVector3, tmp__value);LNVector3& _value = *tmp__value;
            LNResult errorCode = LNShader_SetVector3A(selfObj->handle, _parameterName, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 2) {
        VALUE parameterName;
        VALUE value;
        rb_scan_args(argc, argv, "2", &parameterName, &value);
        if (LNRB_VALUE_IS_STRING(parameterName) && LNRB_VALUE_IS_OBJECT(value))
        {
            const char* _parameterName = LNRB_VALUE_TO_STRING(parameterName);
            LNVector4* tmp__value; Data_Get_Struct(value, LNVector4, tmp__value);LNVector4& _value = *tmp__value;
            LNResult errorCode = LNShader_SetVector4A(selfObj->handle, _parameterName, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Shader::setVector - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNShader_SetTexture(int argc, VALUE* argv, VALUE self)
{
    Wrap_Shader* selfObj;
    Data_Get_Struct(self, Wrap_Shader, selfObj);
    if (2 <= argc && argc <= 2) {
        VALUE parameterName;
        VALUE value;
        rb_scan_args(argc, argv, "2", &parameterName, &value);
        if (LNRB_VALUE_IS_STRING(parameterName) && LNRB_VALUE_IS_OBJECT(value))
        {
            const char* _parameterName = LNRB_VALUE_TO_STRING(parameterName);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult errorCode = LNShader_SetTextureA(selfObj->handle, _parameterName, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Shader::setTexture - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNShader_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::RenderView

struct Wrap_RenderView
    : public Wrap_Object
{

    Wrap_RenderView()
    {}
};

static void LNRenderView_delete(Wrap_RenderView* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNRenderView_mark(Wrap_RenderView* obj)
{
	

}

static VALUE LNRenderView_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_RenderView* internalObj;

    internalObj = new Wrap_RenderView();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNRenderView_allocate");
    obj = Data_Wrap_Struct(klass, LNRenderView_mark, LNRenderView_delete, internalObj);

    return obj;
}

static VALUE LNRenderView_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_RenderView* internalObj;

    internalObj = new Wrap_RenderView();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNRenderView_allocate");
    obj = Data_Wrap_Struct(klass, LNRenderView_mark, LNRenderView_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNRenderView_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::Material

struct Wrap_Material
    : public Wrap_Object
{
    VALUE LNMaterial_GetMainTexture_AccessorCache = Qnil;
    VALUE LNMaterial_GetShader_AccessorCache = Qnil;

    Wrap_Material()
    {}
};

static void LNMaterial_delete(Wrap_Material* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNMaterial_mark(Wrap_Material* obj)
{
	rb_gc_mark(obj->LNMaterial_GetMainTexture_AccessorCache);
rb_gc_mark(obj->LNMaterial_GetShader_AccessorCache);


}

static VALUE LNMaterial_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Material* internalObj;

    internalObj = new Wrap_Material();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMaterial_allocate");
    obj = Data_Wrap_Struct(klass, LNMaterial_mark, LNMaterial_delete, internalObj);

    return obj;
}

static VALUE LNMaterial_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Material* internalObj;

    internalObj = new Wrap_Material();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMaterial_allocate");
    obj = Data_Wrap_Struct(klass, LNMaterial_mark, LNMaterial_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNMaterial_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_Material* selfObj;
    Data_Get_Struct(self, Wrap_Material, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNMaterial_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Material::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMaterial_SetMainTexture(int argc, VALUE* argv, VALUE self)
{
    Wrap_Material* selfObj;
    Data_Get_Struct(self, Wrap_Material, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult errorCode = LNMaterial_SetMainTexture(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Material::setMainTexture - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMaterial_GetMainTexture(int argc, VALUE* argv, VALUE self)
{
    Wrap_Material* selfObj;
    Data_Get_Struct(self, Wrap_Material, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNMaterial_GetMainTexture(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn, selfObj->LNMaterial_GetMainTexture_AccessorCache);
        }
    }
    rb_raise(rb_eArgError, "ln::Material::mainTexture - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMaterial_SetColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_Material* selfObj;
    Data_Get_Struct(self, Wrap_Material, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNMaterial_SetColor(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Material::setColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMaterial_SetRoughness(int argc, VALUE* argv, VALUE self)
{
    Wrap_Material* selfObj;
    Data_Get_Struct(self, Wrap_Material, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNMaterial_SetRoughness(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Material::setRoughness - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMaterial_SetMetallic(int argc, VALUE* argv, VALUE self)
{
    Wrap_Material* selfObj;
    Data_Get_Struct(self, Wrap_Material, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNMaterial_SetMetallic(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Material::setMetallic - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMaterial_SetEmissive(int argc, VALUE* argv, VALUE self)
{
    Wrap_Material* selfObj;
    Data_Get_Struct(self, Wrap_Material, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNMaterial_SetEmissive(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Material::setEmissive - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMaterial_SetShadingModel(int argc, VALUE* argv, VALUE self)
{
    Wrap_Material* selfObj;
    Data_Get_Struct(self, Wrap_Material, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            LNShadingModel _value = (LNShadingModel)FIX2INT(value);
            LNResult errorCode = LNMaterial_SetShadingModel(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Material::setShadingModel - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMaterial_GetShadingModel(int argc, VALUE* argv, VALUE self)
{
    Wrap_Material* selfObj;
    Data_Get_Struct(self, Wrap_Material, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNShadingModel _outReturn;
            LNResult errorCode = LNMaterial_GetShadingModel(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return INT2FIX(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Material::shadingModel - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMaterial_SetShader(int argc, VALUE* argv, VALUE self)
{
    Wrap_Material* selfObj;
    Data_Get_Struct(self, Wrap_Material, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE shader;
        rb_scan_args(argc, argv, "1", &shader);
        if (LNRB_VALUE_IS_OBJECT(shader))
        {
            LNHandle _shader = LuminoRubyRuntimeManager::instance->getHandle(shader);
            LNResult errorCode = LNMaterial_SetShader(selfObj->handle, _shader);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Material::setShader - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMaterial_GetShader(int argc, VALUE* argv, VALUE self)
{
    Wrap_Material* selfObj;
    Data_Get_Struct(self, Wrap_Material, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNMaterial_GetShader(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn, selfObj->LNMaterial_GetShader_AccessorCache);
        }
    }
    rb_raise(rb_eArgError, "ln::Material::shader - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNMaterial_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::MeshNode

struct Wrap_MeshNode
    : public Wrap_Object
{

    Wrap_MeshNode()
    {}
};

static void LNMeshNode_delete(Wrap_MeshNode* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNMeshNode_mark(Wrap_MeshNode* obj)
{
	

}

static VALUE LNMeshNode_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_MeshNode* internalObj;

    internalObj = new Wrap_MeshNode();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMeshNode_allocate");
    obj = Data_Wrap_Struct(klass, LNMeshNode_mark, LNMeshNode_delete, internalObj);

    return obj;
}

static VALUE LNMeshNode_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_MeshNode* internalObj;

    internalObj = new Wrap_MeshNode();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMeshNode_allocate");
    obj = Data_Wrap_Struct(klass, LNMeshNode_mark, LNMeshNode_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNMeshNode_SetVisible(int argc, VALUE* argv, VALUE self)
{
    Wrap_MeshNode* selfObj;
    Data_Get_Struct(self, Wrap_MeshNode, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNMeshNode_SetVisible(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::MeshNode::setVisible - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMeshNode_IsVisible(int argc, VALUE* argv, VALUE self)
{
    Wrap_MeshNode* selfObj;
    Data_Get_Struct(self, Wrap_MeshNode, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNMeshNode_IsVisible(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::MeshNode::isVisible - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNMeshNode_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::AnimationController

struct Wrap_AnimationController
    : public Wrap_Object
{

    Wrap_AnimationController()
    {}
};

static void LNAnimationController_delete(Wrap_AnimationController* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAnimationController_mark(Wrap_AnimationController* obj)
{
	

}

static VALUE LNAnimationController_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AnimationController* internalObj;

    internalObj = new Wrap_AnimationController();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationController_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationController_mark, LNAnimationController_delete, internalObj);

    return obj;
}

static VALUE LNAnimationController_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AnimationController* internalObj;

    internalObj = new Wrap_AnimationController();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationController_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationController_mark, LNAnimationController_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNAnimationController_AddClip(int argc, VALUE* argv, VALUE self)
{
    Wrap_AnimationController* selfObj;
    Data_Get_Struct(self, Wrap_AnimationController, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE animationClip;
        rb_scan_args(argc, argv, "1", &animationClip);
        if (LNRB_VALUE_IS_OBJECT(animationClip))
        {
            LNHandle _animationClip = LuminoRubyRuntimeManager::instance->getHandle(animationClip);
            LNHandle _outReturn;
            LNResult errorCode = LNAnimationController_AddClip(selfObj->handle, _animationClip, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::AnimationController::addClip - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAnimationController_Play(int argc, VALUE* argv, VALUE self)
{
    Wrap_AnimationController* selfObj;
    Data_Get_Struct(self, Wrap_AnimationController, selfObj);
    if (1 <= argc && argc <= 2) {
        VALUE state;
        VALUE duration;
        rb_scan_args(argc, argv, "11", &state, &duration);
        if (LNRB_VALUE_IS_OBJECT(state) && LNRB_VALUE_IS_FLOAT(duration))
        {
            LNHandle _state = LuminoRubyRuntimeManager::instance->getHandle(state);
            float _duration = (duration != Qnil) ? LNRB_VALUE_TO_FLOAT(duration) : 0.300000;
            LNResult errorCode = LNAnimationController_Play(selfObj->handle, _state, _duration);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::AnimationController::play - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNAnimationController_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::MeshModel

struct Wrap_MeshModel
    : public Wrap_Object
{
    VALUE LNMeshModel_GetAnimationController_AccessorCache = Qnil;

    Wrap_MeshModel()
    {}
};

static void LNMeshModel_delete(Wrap_MeshModel* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNMeshModel_mark(Wrap_MeshModel* obj)
{
	rb_gc_mark(obj->LNMeshModel_GetAnimationController_AccessorCache);


}

static VALUE LNMeshModel_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_MeshModel* internalObj;

    internalObj = new Wrap_MeshModel();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMeshModel_allocate");
    obj = Data_Wrap_Struct(klass, LNMeshModel_mark, LNMeshModel_delete, internalObj);

    return obj;
}

static VALUE LNMeshModel_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_MeshModel* internalObj;

    internalObj = new Wrap_MeshModel();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMeshModel_allocate");
    obj = Data_Wrap_Struct(klass, LNMeshModel_mark, LNMeshModel_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNMeshModel_Load(int argc, VALUE* argv, VALUE self)
{
    if (2 <= argc && argc <= 2) {
        VALUE filePath;
        VALUE settings;
        rb_scan_args(argc, argv, "2", &filePath, &settings);
        if (LNRB_VALUE_IS_STRING(filePath) && LNRB_VALUE_IS_OBJECT(settings))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNHandle _settings = LuminoRubyRuntimeManager::instance->getHandle(settings);
            LNHandle _outReturn;
            LNResult errorCode = LNMeshModel_LoadA(_filePath, _settings, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::MeshModel::load - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMeshModel_FindNode(int argc, VALUE* argv, VALUE self)
{
    Wrap_MeshModel* selfObj;
    Data_Get_Struct(self, Wrap_MeshModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE name;
        rb_scan_args(argc, argv, "1", &name);
        if (LNRB_VALUE_IS_STRING(name))
        {
            const char* _name = LNRB_VALUE_TO_STRING(name);
            LNHandle _outReturn;
            LNResult errorCode = LNMeshModel_FindNodeA(selfObj->handle, _name, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::MeshModel::findNode - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMeshModel_FindMaterial(int argc, VALUE* argv, VALUE self)
{
    Wrap_MeshModel* selfObj;
    Data_Get_Struct(self, Wrap_MeshModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE name;
        rb_scan_args(argc, argv, "1", &name);
        if (LNRB_VALUE_IS_STRING(name))
        {
            const char* _name = LNRB_VALUE_TO_STRING(name);
            LNHandle _outReturn;
            LNResult errorCode = LNMeshModel_FindMaterialA(selfObj->handle, _name, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::MeshModel::findMaterial - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMeshModel_MaterialCount(int argc, VALUE* argv, VALUE self)
{
    Wrap_MeshModel* selfObj;
    Data_Get_Struct(self, Wrap_MeshModel, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            int _outReturn;
            LNResult errorCode = LNMeshModel_MaterialCount(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::MeshModel::materialCount - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMeshModel_Material(int argc, VALUE* argv, VALUE self)
{
    Wrap_MeshModel* selfObj;
    Data_Get_Struct(self, Wrap_MeshModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE index;
        rb_scan_args(argc, argv, "1", &index);
        if (LNRB_VALUE_IS_NUMBER(index))
        {
            int _index = LNRB_VALUE_TO_NUMBER(index);
            LNHandle _outReturn;
            LNResult errorCode = LNMeshModel_Material(selfObj->handle, _index, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::MeshModel::material - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMeshModel_GetAnimationController(int argc, VALUE* argv, VALUE self)
{
    Wrap_MeshModel* selfObj;
    Data_Get_Struct(self, Wrap_MeshModel, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNMeshModel_GetAnimationController(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn, selfObj->LNMeshModel_GetAnimationController_AccessorCache);
        }
    }
    rb_raise(rb_eArgError, "ln::MeshModel::animationController - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNMeshModel_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::MeshImportSettings

struct Wrap_MeshImportSettings
    : public Wrap_Object
{

    Wrap_MeshImportSettings()
    {}
};

static void LNMeshImportSettings_delete(Wrap_MeshImportSettings* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNMeshImportSettings_mark(Wrap_MeshImportSettings* obj)
{
	

}

static VALUE LNMeshImportSettings_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_MeshImportSettings* internalObj;

    internalObj = new Wrap_MeshImportSettings();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMeshImportSettings_allocate");
    obj = Data_Wrap_Struct(klass, LNMeshImportSettings_mark, LNMeshImportSettings_delete, internalObj);

    return obj;
}

static VALUE LNMeshImportSettings_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_MeshImportSettings* internalObj;

    internalObj = new Wrap_MeshImportSettings();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMeshImportSettings_allocate");
    obj = Data_Wrap_Struct(klass, LNMeshImportSettings_mark, LNMeshImportSettings_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNMeshImportSettings_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_MeshImportSettings* selfObj;
    Data_Get_Struct(self, Wrap_MeshImportSettings, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNMeshImportSettings_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::MeshImportSettings::init - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNMeshImportSettings_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::SkinnedMeshModel

struct Wrap_SkinnedMeshModel
    : public Wrap_MeshModel
{

    Wrap_SkinnedMeshModel()
    {}
};

static void LNSkinnedMeshModel_delete(Wrap_SkinnedMeshModel* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSkinnedMeshModel_mark(Wrap_SkinnedMeshModel* obj)
{
	

}

static VALUE LNSkinnedMeshModel_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SkinnedMeshModel* internalObj;

    internalObj = new Wrap_SkinnedMeshModel();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSkinnedMeshModel_allocate");
    obj = Data_Wrap_Struct(klass, LNSkinnedMeshModel_mark, LNSkinnedMeshModel_delete, internalObj);

    return obj;
}

static VALUE LNSkinnedMeshModel_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SkinnedMeshModel* internalObj;

    internalObj = new Wrap_SkinnedMeshModel();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSkinnedMeshModel_allocate");
    obj = Data_Wrap_Struct(klass, LNSkinnedMeshModel_mark, LNSkinnedMeshModel_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNSkinnedMeshModel_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::CollisionShape

struct Wrap_CollisionShape
    : public Wrap_Object
{

    Wrap_CollisionShape()
    {}
};

static void LNCollisionShape_delete(Wrap_CollisionShape* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNCollisionShape_mark(Wrap_CollisionShape* obj)
{
	

}

static VALUE LNCollisionShape_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_CollisionShape* internalObj;

    internalObj = new Wrap_CollisionShape();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCollisionShape_allocate");
    obj = Data_Wrap_Struct(klass, LNCollisionShape_mark, LNCollisionShape_delete, internalObj);

    return obj;
}

static VALUE LNCollisionShape_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_CollisionShape* internalObj;

    internalObj = new Wrap_CollisionShape();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCollisionShape_allocate");
    obj = Data_Wrap_Struct(klass, LNCollisionShape_mark, LNCollisionShape_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNCollisionShape_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::BoxCollisionShape

struct Wrap_BoxCollisionShape
    : public Wrap_CollisionShape
{

    Wrap_BoxCollisionShape()
    {}
};

static void LNBoxCollisionShape_delete(Wrap_BoxCollisionShape* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNBoxCollisionShape_mark(Wrap_BoxCollisionShape* obj)
{
	

}

static VALUE LNBoxCollisionShape_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_BoxCollisionShape* internalObj;

    internalObj = new Wrap_BoxCollisionShape();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNBoxCollisionShape_allocate");
    obj = Data_Wrap_Struct(klass, LNBoxCollisionShape_mark, LNBoxCollisionShape_delete, internalObj);

    return obj;
}

static VALUE LNBoxCollisionShape_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_BoxCollisionShape* internalObj;

    internalObj = new Wrap_BoxCollisionShape();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNBoxCollisionShape_allocate");
    obj = Data_Wrap_Struct(klass, LNBoxCollisionShape_mark, LNBoxCollisionShape_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNBoxCollisionShape_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_BoxCollisionShape* selfObj;
    Data_Get_Struct(self, Wrap_BoxCollisionShape, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE size;
        rb_scan_args(argc, argv, "1", &size);
        if (LNRB_VALUE_IS_OBJECT(size))
        {
            LNVector3* tmp__size; Data_Get_Struct(size, LNVector3, tmp__size);LNVector3& _size = *tmp__size;
            LNResult errorCode = LNBoxCollisionShape_Create(&_size, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (3 <= argc && argc <= 3) {
        VALUE width;
        VALUE height;
        VALUE depth;
        rb_scan_args(argc, argv, "3", &width, &height, &depth);
        if (LNRB_VALUE_IS_FLOAT(width) && LNRB_VALUE_IS_FLOAT(height) && LNRB_VALUE_IS_FLOAT(depth))
        {
            float _width = LNRB_VALUE_TO_FLOAT(width);
            float _height = LNRB_VALUE_TO_FLOAT(height);
            float _depth = LNRB_VALUE_TO_FLOAT(depth);
            LNResult errorCode = LNBoxCollisionShape_CreateWHD(_width, _height, _depth, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::BoxCollisionShape::init - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNBoxCollisionShape_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::AnimationCurve

struct Wrap_AnimationCurve
    : public Wrap_Object
{

    Wrap_AnimationCurve()
    {}
};

static void LNAnimationCurve_delete(Wrap_AnimationCurve* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAnimationCurve_mark(Wrap_AnimationCurve* obj)
{
	

}

static VALUE LNAnimationCurve_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AnimationCurve* internalObj;

    internalObj = new Wrap_AnimationCurve();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationCurve_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationCurve_mark, LNAnimationCurve_delete, internalObj);

    return obj;
}

static VALUE LNAnimationCurve_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AnimationCurve* internalObj;

    internalObj = new Wrap_AnimationCurve();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationCurve_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationCurve_mark, LNAnimationCurve_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNAnimationCurve_Evaluate(int argc, VALUE* argv, VALUE self)
{
    Wrap_AnimationCurve* selfObj;
    Data_Get_Struct(self, Wrap_AnimationCurve, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE time;
        rb_scan_args(argc, argv, "1", &time);
        if (LNRB_VALUE_IS_FLOAT(time))
        {
            float _time = LNRB_VALUE_TO_FLOAT(time);
            float _outReturn;
            LNResult errorCode = LNAnimationCurve_Evaluate(selfObj->handle, _time, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::AnimationCurve::evaluate - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNAnimationCurve_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::KeyFrameAnimationCurve

struct Wrap_KeyFrameAnimationCurve
    : public Wrap_AnimationCurve
{

    Wrap_KeyFrameAnimationCurve()
    {}
};

static void LNKeyFrameAnimationCurve_delete(Wrap_KeyFrameAnimationCurve* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNKeyFrameAnimationCurve_mark(Wrap_KeyFrameAnimationCurve* obj)
{
	

}

static VALUE LNKeyFrameAnimationCurve_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_KeyFrameAnimationCurve* internalObj;

    internalObj = new Wrap_KeyFrameAnimationCurve();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNKeyFrameAnimationCurve_allocate");
    obj = Data_Wrap_Struct(klass, LNKeyFrameAnimationCurve_mark, LNKeyFrameAnimationCurve_delete, internalObj);

    return obj;
}

static VALUE LNKeyFrameAnimationCurve_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_KeyFrameAnimationCurve* internalObj;

    internalObj = new Wrap_KeyFrameAnimationCurve();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNKeyFrameAnimationCurve_allocate");
    obj = Data_Wrap_Struct(klass, LNKeyFrameAnimationCurve_mark, LNKeyFrameAnimationCurve_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNKeyFrameAnimationCurve_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_KeyFrameAnimationCurve* selfObj;
    Data_Get_Struct(self, Wrap_KeyFrameAnimationCurve, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNKeyFrameAnimationCurve_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::KeyFrameAnimationCurve::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNKeyFrameAnimationCurve_AddKeyFrame(int argc, VALUE* argv, VALUE self)
{
    Wrap_KeyFrameAnimationCurve* selfObj;
    Data_Get_Struct(self, Wrap_KeyFrameAnimationCurve, selfObj);
    if (2 <= argc && argc <= 4) {
        VALUE time;
        VALUE value;
        VALUE rightTangentMode;
        VALUE tangent;
        rb_scan_args(argc, argv, "22", &time, &value, &rightTangentMode, &tangent);
        if (LNRB_VALUE_IS_FLOAT(time) && LNRB_VALUE_IS_FLOAT(value) && LNRB_VALUE_IS_NUMBER(rightTangentMode) && LNRB_VALUE_IS_FLOAT(tangent))
        {
            float _time = LNRB_VALUE_TO_FLOAT(time);
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNTangentMode _rightTangentMode = (rightTangentMode != Qnil) ? (LNTangentMode)FIX2INT(rightTangentMode) : (LNTangentMode)0;
            float _tangent = (tangent != Qnil) ? LNRB_VALUE_TO_FLOAT(tangent) : 0.000000;
            LNResult errorCode = LNKeyFrameAnimationCurve_AddKeyFrame(selfObj->handle, _time, _value, _rightTangentMode, _tangent);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::KeyFrameAnimationCurve::addKeyFrame - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNKeyFrameAnimationCurve_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::AnimationClip

struct Wrap_AnimationClip
    : public Wrap_AssetObject
{

    Wrap_AnimationClip()
    {}
};

static void LNAnimationClip_delete(Wrap_AnimationClip* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAnimationClip_mark(Wrap_AnimationClip* obj)
{
	

}

static VALUE LNAnimationClip_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AnimationClip* internalObj;

    internalObj = new Wrap_AnimationClip();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationClip_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationClip_mark, LNAnimationClip_delete, internalObj);

    return obj;
}

static VALUE LNAnimationClip_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AnimationClip* internalObj;

    internalObj = new Wrap_AnimationClip();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationClip_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationClip_mark, LNAnimationClip_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNAnimationClip_Load(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE filePath;
        rb_scan_args(argc, argv, "1", &filePath);
        if (LNRB_VALUE_IS_STRING(filePath))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNHandle _outReturn;
            LNResult errorCode = LNAnimationClip_LoadA(_filePath, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::AnimationClip::load - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAnimationClip_SetWrapMode(int argc, VALUE* argv, VALUE self)
{
    Wrap_AnimationClip* selfObj;
    Data_Get_Struct(self, Wrap_AnimationClip, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            LNAnimationWrapMode _value = (LNAnimationWrapMode)FIX2INT(value);
            LNResult errorCode = LNAnimationClip_SetWrapMode(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::AnimationClip::setWrapMode - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAnimationClip_GetWrapMode(int argc, VALUE* argv, VALUE self)
{
    Wrap_AnimationClip* selfObj;
    Data_Get_Struct(self, Wrap_AnimationClip, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNAnimationWrapMode _outReturn;
            LNResult errorCode = LNAnimationClip_GetWrapMode(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return INT2FIX(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::AnimationClip::wrapMode - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAnimationClip_SetHierarchicalAnimationMode(int argc, VALUE* argv, VALUE self)
{
    Wrap_AnimationClip* selfObj;
    Data_Get_Struct(self, Wrap_AnimationClip, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            LNHierarchicalAnimationMode _value = (LNHierarchicalAnimationMode)FIX2INT(value);
            LNResult errorCode = LNAnimationClip_SetHierarchicalAnimationMode(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::AnimationClip::setHierarchicalAnimationMode - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNAnimationClip_GetHierarchicalAnimationMode(int argc, VALUE* argv, VALUE self)
{
    Wrap_AnimationClip* selfObj;
    Data_Get_Struct(self, Wrap_AnimationClip, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNHierarchicalAnimationMode _outReturn;
            LNResult errorCode = LNAnimationClip_GetHierarchicalAnimationMode(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return INT2FIX(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::AnimationClip::hierarchicalAnimationMode - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNAnimationClip_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::AnimationState

struct Wrap_AnimationState
    : public Wrap_Object
{

    Wrap_AnimationState()
    {}
};

static void LNAnimationState_delete(Wrap_AnimationState* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAnimationState_mark(Wrap_AnimationState* obj)
{
	

}

static VALUE LNAnimationState_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AnimationState* internalObj;

    internalObj = new Wrap_AnimationState();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationState_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationState_mark, LNAnimationState_delete, internalObj);

    return obj;
}

static VALUE LNAnimationState_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AnimationState* internalObj;

    internalObj = new Wrap_AnimationState();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationState_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationState_mark, LNAnimationState_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNAnimationState_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::EffectResource

struct Wrap_EffectResource
    : public Wrap_AssetObject
{

    Wrap_EffectResource()
    {}
};

static void LNEffectResource_delete(Wrap_EffectResource* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNEffectResource_mark(Wrap_EffectResource* obj)
{
	

}

static VALUE LNEffectResource_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_EffectResource* internalObj;

    internalObj = new Wrap_EffectResource();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEffectResource_allocate");
    obj = Data_Wrap_Struct(klass, LNEffectResource_mark, LNEffectResource_delete, internalObj);

    return obj;
}

static VALUE LNEffectResource_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_EffectResource* internalObj;

    internalObj = new Wrap_EffectResource();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEffectResource_allocate");
    obj = Data_Wrap_Struct(klass, LNEffectResource_mark, LNEffectResource_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNEffectResource_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::ParticleEmitterModel

struct Wrap_ParticleEmitterModel
    : public Wrap_Object
{

    Wrap_ParticleEmitterModel()
    {}
};

static void LNParticleEmitterModel_delete(Wrap_ParticleEmitterModel* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNParticleEmitterModel_mark(Wrap_ParticleEmitterModel* obj)
{
	

}

static VALUE LNParticleEmitterModel_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ParticleEmitterModel* internalObj;

    internalObj = new Wrap_ParticleEmitterModel();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleEmitterModel_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleEmitterModel_mark, LNParticleEmitterModel_delete, internalObj);

    return obj;
}

static VALUE LNParticleEmitterModel_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ParticleEmitterModel* internalObj;

    internalObj = new Wrap_ParticleEmitterModel();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleEmitterModel_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleEmitterModel_mark, LNParticleEmitterModel_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNParticleEmitterModel_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModel, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNParticleEmitterModel_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitterModel::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleEmitterModel_SetMaxParticles(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE count;
        rb_scan_args(argc, argv, "1", &count);
        if (LNRB_VALUE_IS_NUMBER(count))
        {
            int _count = LNRB_VALUE_TO_NUMBER(count);
            LNResult errorCode = LNParticleEmitterModel_SetMaxParticles(selfObj->handle, _count);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitterModel::setMaxParticles - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleEmitterModel_SetSpawnRate(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE rate;
        rb_scan_args(argc, argv, "1", &rate);
        if (LNRB_VALUE_IS_FLOAT(rate))
        {
            float _rate = LNRB_VALUE_TO_FLOAT(rate);
            LNResult errorCode = LNParticleEmitterModel_SetSpawnRate(selfObj->handle, _rate);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitterModel::setSpawnRate - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleEmitterModel_SetLifeTime(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE time;
        rb_scan_args(argc, argv, "1", &time);
        if (LNRB_VALUE_IS_FLOAT(time))
        {
            float _time = LNRB_VALUE_TO_FLOAT(time);
            LNResult errorCode = LNParticleEmitterModel_SetLifeTime(selfObj->handle, _time);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitterModel::setLifeTime - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleEmitterModel_SetupBoxShape(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE size;
        rb_scan_args(argc, argv, "1", &size);
        if (LNRB_VALUE_IS_OBJECT(size))
        {
            LNVector3* tmp__size; Data_Get_Struct(size, LNVector3, tmp__size);LNVector3& _size = *tmp__size;
            LNResult errorCode = LNParticleEmitterModel_SetupBoxShape(selfObj->handle, &_size);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitterModel::setupBoxShape - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleEmitterModel_SetSize(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNParticleEmitterModel_SetSize(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitterModel::setSize - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleEmitterModel_SetSizeVelocity(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNParticleEmitterModel_SetSizeVelocity(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitterModel::setSizeVelocity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleEmitterModel_SetSizeAcceleration(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNParticleEmitterModel_SetSizeAcceleration(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitterModel::setSizeAcceleration - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleEmitterModel_SetForwardVelocityMin(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNParticleEmitterModel_SetForwardVelocityMin(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitterModel::setForwardVelocityMin - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleEmitterModel_SetForwardVelocityMax(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNParticleEmitterModel_SetForwardVelocityMax(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitterModel::setForwardVelocityMax - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleEmitterModel_SetForwardScale(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNParticleEmitterModel_SetForwardScale(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitterModel::setForwardScale - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleEmitterModel_SetGeometryDirection(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            LNParticleGeometryDirection _value = (LNParticleGeometryDirection)FIX2INT(value);
            LNResult errorCode = LNParticleEmitterModel_SetGeometryDirection(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitterModel::setGeometryDirection - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleEmitterModel_SetupSpriteModule(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE material;
        rb_scan_args(argc, argv, "1", &material);
        if (LNRB_VALUE_IS_OBJECT(material))
        {
            LNHandle _material = LuminoRubyRuntimeManager::instance->getHandle(material);
            LNResult errorCode = LNParticleEmitterModel_SetupSpriteModule(selfObj->handle, _material);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitterModel::setupSpriteModule - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNParticleEmitterModel_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::ParticleModel

struct Wrap_ParticleModel
    : public Wrap_EffectResource
{

    Wrap_ParticleModel()
    {}
};

static void LNParticleModel_delete(Wrap_ParticleModel* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNParticleModel_mark(Wrap_ParticleModel* obj)
{
	

}

static VALUE LNParticleModel_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ParticleModel* internalObj;

    internalObj = new Wrap_ParticleModel();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleModel_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleModel_mark, LNParticleModel_delete, internalObj);

    return obj;
}

static VALUE LNParticleModel_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ParticleModel* internalObj;

    internalObj = new Wrap_ParticleModel();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleModel_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleModel_mark, LNParticleModel_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNParticleModel_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleModel, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNParticleModel_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleModel::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleModel_SetLoop(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNParticleModel_SetLoop(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleModel::setLoop - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleModel_IsLoop(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleModel, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNParticleModel_IsLoop(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleModel::isLoop - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNParticleModel_AddEmitter(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleModel* selfObj;
    Data_Get_Struct(self, Wrap_ParticleModel, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE emitter;
        rb_scan_args(argc, argv, "1", &emitter);
        if (LNRB_VALUE_IS_OBJECT(emitter))
        {
            LNHandle _emitter = LuminoRubyRuntimeManager::instance->getHandle(emitter);
            LNResult errorCode = LNParticleModel_AddEmitter(selfObj->handle, _emitter);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleModel::addEmitter - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNParticleModel_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::Component

struct Wrap_Component
    : public Wrap_Object
{

    Wrap_Component()
    {}
};

static void LNComponent_delete(Wrap_Component* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNComponent_mark(Wrap_Component* obj)
{
	

}

static VALUE LNComponent_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Component* internalObj;

    internalObj = new Wrap_Component();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNComponent_mark, LNComponent_delete, internalObj);

    return obj;
}

static VALUE LNComponent_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Component* internalObj;

    internalObj = new Wrap_Component();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNComponent_mark, LNComponent_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNComponent_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::VisualComponent

struct Wrap_VisualComponent
    : public Wrap_Component
{

    Wrap_VisualComponent()
    {}
};

static void LNVisualComponent_delete(Wrap_VisualComponent* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNVisualComponent_mark(Wrap_VisualComponent* obj)
{
	

}

static VALUE LNVisualComponent_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_VisualComponent* internalObj;

    internalObj = new Wrap_VisualComponent();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVisualComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNVisualComponent_mark, LNVisualComponent_delete, internalObj);

    return obj;
}

static VALUE LNVisualComponent_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_VisualComponent* internalObj;

    internalObj = new Wrap_VisualComponent();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVisualComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNVisualComponent_mark, LNVisualComponent_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNVisualComponent_SetVisible(int argc, VALUE* argv, VALUE self)
{
    Wrap_VisualComponent* selfObj;
    Data_Get_Struct(self, Wrap_VisualComponent, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNVisualComponent_SetVisible(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::VisualComponent::setVisible - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVisualComponent_IsVisible(int argc, VALUE* argv, VALUE self)
{
    Wrap_VisualComponent* selfObj;
    Data_Get_Struct(self, Wrap_VisualComponent, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNVisualComponent_IsVisible(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::VisualComponent::isVisible - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNVisualComponent_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::SpriteComponent

struct Wrap_SpriteComponent
    : public Wrap_VisualComponent
{

    Wrap_SpriteComponent()
    {}
};

static void LNSpriteComponent_delete(Wrap_SpriteComponent* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSpriteComponent_mark(Wrap_SpriteComponent* obj)
{
	

}

static VALUE LNSpriteComponent_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SpriteComponent* internalObj;

    internalObj = new Wrap_SpriteComponent();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpriteComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNSpriteComponent_mark, LNSpriteComponent_delete, internalObj);

    return obj;
}

static VALUE LNSpriteComponent_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SpriteComponent* internalObj;

    internalObj = new Wrap_SpriteComponent();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpriteComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNSpriteComponent_mark, LNSpriteComponent_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNSpriteComponent_SetTexture(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpriteComponent* selfObj;
    Data_Get_Struct(self, Wrap_SpriteComponent, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE texture;
        rb_scan_args(argc, argv, "1", &texture);
        if (LNRB_VALUE_IS_OBJECT(texture))
        {
            LNHandle _texture = LuminoRubyRuntimeManager::instance->getHandle(texture);
            LNResult errorCode = LNSpriteComponent_SetTexture(selfObj->handle, _texture);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::SpriteComponent::setTexture - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNSpriteComponent_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::CollisionEventHandler

struct Wrap_CollisionEventHandler
    : public Wrap_Object
{

    VALUE m_proc = Qnil;
    Wrap_CollisionEventHandler()
    {}
};

static void LNCollisionEventHandler_delete(Wrap_CollisionEventHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNCollisionEventHandler_mark(Wrap_CollisionEventHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNCollisionEventHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_CollisionEventHandler* internalObj;

    internalObj = new Wrap_CollisionEventHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCollisionEventHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCollisionEventHandler_mark, LNCollisionEventHandler_delete, internalObj);

    return obj;
}

static VALUE LNCollisionEventHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_CollisionEventHandler* internalObj;

    internalObj = new Wrap_CollisionEventHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCollisionEventHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCollisionEventHandler_mark, LNCollisionEventHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNCollisionEventHandler_CollisionEventHandler_ProcCaller(LNHandle collisioneventhandler, LNHandle p1)
{
    Wrap_CollisionEventHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(collisioneventhandler), Wrap_CollisionEventHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(p1));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNCollisionEventHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_CollisionEventHandler* selfObj;
    Data_Get_Struct(self, Wrap_CollisionEventHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNCollisionEventHandler_Create(Wrap_LNCollisionEventHandler_CollisionEventHandler_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ln::CollisionEventHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::CharacterController

struct Wrap_CharacterController
    : public Wrap_Component
{

    Wrap_CharacterController()
    {}
};

static void LNCharacterController_delete(Wrap_CharacterController* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNCharacterController_mark(Wrap_CharacterController* obj)
{
	

}

static VALUE LNCharacterController_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_CharacterController* internalObj;

    internalObj = new Wrap_CharacterController();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCharacterController_allocate");
    obj = Data_Wrap_Struct(klass, LNCharacterController_mark, LNCharacterController_delete, internalObj);

    return obj;
}

static VALUE LNCharacterController_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_CharacterController* internalObj;

    internalObj = new Wrap_CharacterController();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCharacterController_allocate");
    obj = Data_Wrap_Struct(klass, LNCharacterController_mark, LNCharacterController_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNCharacterController_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNCharacterController_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCharacterController_SetWalkVelocity(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNCharacterController_SetWalkVelocity(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::setWalkVelocity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCharacterController_GetWalkVelocity(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNCharacterController_GetWalkVelocity(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::walkVelocity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCharacterController_SetVelocity(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNVector3* tmp__value; Data_Get_Struct(value, LNVector3, tmp__value);LNVector3& _value = *tmp__value;
            LNResult errorCode = LNCharacterController_SetVelocity(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::setVelocity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCharacterController_GetVelocity(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNVector3 _outReturn;
            LNResult errorCode = LNCharacterController_GetVelocity(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNVector3_allocate(g_class_Vector3);
            *((LNVector3*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::velocity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCharacterController_SetInputControlEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNCharacterController_SetInputControlEnabled(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::setInputControlEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCharacterController_SetCameraControlEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNCharacterController_SetCameraControlEnabled(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::setCameraControlEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCharacterController_SetHeight(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNCharacterController_SetHeight(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::setHeight - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCharacterController_GetHeight(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNCharacterController_GetHeight(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::height - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCharacterController_SetCameraRadius(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNCharacterController_SetCameraRadius(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::setCameraRadius - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCharacterController_GetCameraRadius(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNCharacterController_GetCameraRadius(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::cameraRadius - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCharacterController_SetCollisionEnter(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE handler;
        rb_scan_args(argc, argv, "1", &handler);
        if (LNRB_VALUE_IS_OBJECT(handler))
        {
            LNHandle _handler = LuminoRubyRuntimeManager::instance->getHandle(handler);
            LNResult errorCode = LNCharacterController_SetCollisionEnter(selfObj->handle, _handler);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_CollisionEventHandler, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult result = LNCharacterController_SetCollisionEnter(selfObj->handle, _value);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::setCollisionEnter - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCharacterController_SetCollisionLeave(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE handler;
        rb_scan_args(argc, argv, "1", &handler);
        if (LNRB_VALUE_IS_OBJECT(handler))
        {
            LNHandle _handler = LuminoRubyRuntimeManager::instance->getHandle(handler);
            LNResult errorCode = LNCharacterController_SetCollisionLeave(selfObj->handle, _handler);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_CollisionEventHandler, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult result = LNCharacterController_SetCollisionLeave(selfObj->handle, _value);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::setCollisionLeave - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNCharacterController_SetCollisionStay(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterController* selfObj;
    Data_Get_Struct(self, Wrap_CharacterController, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE handler;
        rb_scan_args(argc, argv, "1", &handler);
        if (LNRB_VALUE_IS_OBJECT(handler))
        {
            LNHandle _handler = LuminoRubyRuntimeManager::instance->getHandle(handler);
            LNResult errorCode = LNCharacterController_SetCollisionStay(selfObj->handle, _handler);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_CollisionEventHandler, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult result = LNCharacterController_SetCollisionStay(selfObj->handle, _value);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CharacterController::setCollisionStay - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNCharacterController_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::World

struct Wrap_World
    : public Wrap_Object
{

    Wrap_World()
    {}
};

static void LNWorld_delete(Wrap_World* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNWorld_mark(Wrap_World* obj)
{
	

}

static VALUE LNWorld_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_World* internalObj;

    internalObj = new Wrap_World();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorld_allocate");
    obj = Data_Wrap_Struct(klass, LNWorld_mark, LNWorld_delete, internalObj);

    return obj;
}

static VALUE LNWorld_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_World* internalObj;

    internalObj = new Wrap_World();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorld_allocate");
    obj = Data_Wrap_Struct(klass, LNWorld_mark, LNWorld_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNWorld_Add(int argc, VALUE* argv, VALUE self)
{
    Wrap_World* selfObj;
    Data_Get_Struct(self, Wrap_World, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE obj;
        rb_scan_args(argc, argv, "1", &obj);
        if (LNRB_VALUE_IS_OBJECT(obj))
        {
            LNHandle _obj = LuminoRubyRuntimeManager::instance->getHandle(obj);
            LNResult errorCode = LNWorld_Add(selfObj->handle, _obj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::World::add - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNWorld_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::ComponentList

struct Wrap_ComponentList
    : public Wrap_Object
{
    std::vector<VALUE> Items_AccessorCache;

    Wrap_ComponentList()
    {}
};

static void LNComponentList_delete(Wrap_ComponentList* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNComponentList_mark(Wrap_ComponentList* obj)
{
	for(VALUE& v : obj->Items_AccessorCache) rb_gc_mark(v);


}

static VALUE LNComponentList_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ComponentList* internalObj;

    internalObj = new Wrap_ComponentList();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNComponentList_allocate");
    obj = Data_Wrap_Struct(klass, LNComponentList_mark, LNComponentList_delete, internalObj);

    return obj;
}

static VALUE LNComponentList_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ComponentList* internalObj;

    internalObj = new Wrap_ComponentList();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNComponentList_allocate");
    obj = Data_Wrap_Struct(klass, LNComponentList_mark, LNComponentList_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNComponentList_GetLength(int argc, VALUE* argv, VALUE self)
{
    Wrap_ComponentList* selfObj;
    Data_Get_Struct(self, Wrap_ComponentList, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            int _outReturn;
            LNResult errorCode = LNComponentList_GetLength(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::ComponentList::getLength - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNComponentList_GetItem(int argc, VALUE* argv, VALUE self)
{
    Wrap_ComponentList* selfObj;
    Data_Get_Struct(self, Wrap_ComponentList, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE index;
        rb_scan_args(argc, argv, "1", &index);
        if (LNRB_VALUE_IS_NUMBER(index))
        {
            int _index = LNRB_VALUE_TO_NUMBER(index);
            LNHandle _outReturn;
            LNResult errorCode = LNComponentList_GetItem(selfObj->handle, _index, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn, selfObj->Items_AccessorCache, _index);
        }
    }
    rb_raise(rb_eArgError, "ln::ComponentList::getItem - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNComponentList_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::WorldObject

struct Wrap_WorldObject
    : public Wrap_Object
{
    VALUE LNWorldObject_GetComponents_AccessorCache = Qnil;

    Wrap_WorldObject()
    {}
};

static void LNWorldObject_delete(Wrap_WorldObject* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNWorldObject_mark(Wrap_WorldObject* obj)
{
	rb_gc_mark(obj->LNWorldObject_GetComponents_AccessorCache);


}

static VALUE LNWorldObject_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_WorldObject* internalObj;

    internalObj = new Wrap_WorldObject();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldObject_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldObject_mark, LNWorldObject_delete, internalObj);

    return obj;
}

static VALUE LNWorldObject_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_WorldObject* internalObj;

    internalObj = new Wrap_WorldObject();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldObject_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldObject_mark, LNWorldObject_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNWorldObject_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNWorldObject_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_SetPosition(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE pos;
        rb_scan_args(argc, argv, "1", &pos);
        if (LNRB_VALUE_IS_OBJECT(pos))
        {
            LNVector3* tmp__pos; Data_Get_Struct(pos, LNVector3, tmp__pos);LNVector3& _pos = *tmp__pos;
            LNResult errorCode = LNWorldObject_SetPosition(selfObj->handle, &_pos);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 3) {
        VALUE x;
        VALUE y;
        VALUE z;
        rb_scan_args(argc, argv, "21", &x, &y, &z);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(z))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _z = (z != Qnil) ? LNRB_VALUE_TO_FLOAT(z) : 0.000000;
            LNResult errorCode = LNWorldObject_SetPositionXYZ(selfObj->handle, _x, _y, _z);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::setPosition - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_GetPosition(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNVector3 _outReturn;
            LNResult errorCode = LNWorldObject_GetPosition(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNVector3_allocate(g_class_Vector3);
            *((LNVector3*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::position - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_SetRotation(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE rot;
        rb_scan_args(argc, argv, "1", &rot);
        if (LNRB_VALUE_IS_OBJECT(rot))
        {
            LNQuaternion* tmp__rot; Data_Get_Struct(rot, LNQuaternion, tmp__rot);LNQuaternion& _rot = *tmp__rot;
            LNResult errorCode = LNWorldObject_SetRotationQuaternion(selfObj->handle, &_rot);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (3 <= argc && argc <= 3) {
        VALUE x;
        VALUE y;
        VALUE z;
        rb_scan_args(argc, argv, "3", &x, &y, &z);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(z))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _z = LNRB_VALUE_TO_FLOAT(z);
            LNResult errorCode = LNWorldObject_SetRotation(selfObj->handle, _x, _y, _z);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::setRotation - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_GetRotation(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNQuaternion _outReturn;
            LNResult errorCode = LNWorldObject_GetRotation(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNQuaternion_allocate(g_class_Quaternion);
            *((LNQuaternion*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::rotation - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_SetScale(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE scale;
        rb_scan_args(argc, argv, "1", &scale);
        if (LNRB_VALUE_IS_OBJECT(scale))
        {
            LNVector3* tmp__scale; Data_Get_Struct(scale, LNVector3, tmp__scale);LNVector3& _scale = *tmp__scale;
            LNResult errorCode = LNWorldObject_SetScale(selfObj->handle, &_scale);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (1 <= argc && argc <= 1) {
        VALUE xyz;
        rb_scan_args(argc, argv, "1", &xyz);
        if (LNRB_VALUE_IS_FLOAT(xyz))
        {
            float _xyz = LNRB_VALUE_TO_FLOAT(xyz);
            LNResult errorCode = LNWorldObject_SetScaleS(selfObj->handle, _xyz);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 3) {
        VALUE x;
        VALUE y;
        VALUE z;
        rb_scan_args(argc, argv, "21", &x, &y, &z);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(z))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _z = (z != Qnil) ? LNRB_VALUE_TO_FLOAT(z) : 1.000000;
            LNResult errorCode = LNWorldObject_SetScaleXYZ(selfObj->handle, _x, _y, _z);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::setScale - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_GetScale(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNVector3 _outReturn;
            LNResult errorCode = LNWorldObject_GetScale(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNVector3_allocate(g_class_Vector3);
            *((LNVector3*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::scale - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_SetCenterPoint(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNVector3* tmp__value; Data_Get_Struct(value, LNVector3, tmp__value);LNVector3& _value = *tmp__value;
            LNResult errorCode = LNWorldObject_SetCenterPoint(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 3) {
        VALUE x;
        VALUE y;
        VALUE z;
        rb_scan_args(argc, argv, "21", &x, &y, &z);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(z))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _z = (z != Qnil) ? LNRB_VALUE_TO_FLOAT(z) : 0.000000;
            LNResult errorCode = LNWorldObject_SetCenterPointXYZ(selfObj->handle, _x, _y, _z);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::setCenterPoint - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_GetCenterPoint(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNVector3 _outReturn;
            LNResult errorCode = LNWorldObject_GetCenterPoint(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNVector3_allocate(g_class_Vector3);
            *((LNVector3*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::centerPoint - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_LookAt(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE target;
        rb_scan_args(argc, argv, "1", &target);
        if (LNRB_VALUE_IS_OBJECT(target))
        {
            LNVector3* tmp__target; Data_Get_Struct(target, LNVector3, tmp__target);LNVector3& _target = *tmp__target;
            LNResult errorCode = LNWorldObject_LookAt(selfObj->handle, &_target);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (3 <= argc && argc <= 3) {
        VALUE x;
        VALUE y;
        VALUE z;
        rb_scan_args(argc, argv, "3", &x, &y, &z);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(z))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _z = LNRB_VALUE_TO_FLOAT(z);
            LNResult errorCode = LNWorldObject_LookAtXYZ(selfObj->handle, _x, _y, _z);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::lookAt - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_AddComponent(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE component;
        rb_scan_args(argc, argv, "1", &component);
        if (LNRB_VALUE_IS_OBJECT(component))
        {
            LNHandle _component = LuminoRubyRuntimeManager::instance->getHandle(component);
            LNResult errorCode = LNWorldObject_AddComponent(selfObj->handle, _component);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::addComponent - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_RemoveComponent(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE component;
        rb_scan_args(argc, argv, "1", &component);
        if (LNRB_VALUE_IS_OBJECT(component))
        {
            LNHandle _component = LuminoRubyRuntimeManager::instance->getHandle(component);
            LNResult errorCode = LNWorldObject_RemoveComponent(selfObj->handle, _component);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::removeComponent - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_AddTag(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE tag;
        rb_scan_args(argc, argv, "1", &tag);
        if (LNRB_VALUE_IS_STRING(tag))
        {
            const char* _tag = LNRB_VALUE_TO_STRING(tag);
            LNResult errorCode = LNWorldObject_AddTagA(selfObj->handle, _tag);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::addTag - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_RemoveTag(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE tag;
        rb_scan_args(argc, argv, "1", &tag);
        if (LNRB_VALUE_IS_STRING(tag))
        {
            const char* _tag = LNRB_VALUE_TO_STRING(tag);
            LNResult errorCode = LNWorldObject_RemoveTagA(selfObj->handle, _tag);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::removeTag - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_HasTag(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE tag;
        rb_scan_args(argc, argv, "1", &tag);
        if (LNRB_VALUE_IS_STRING(tag))
        {
            const char* _tag = LNRB_VALUE_TO_STRING(tag);
            LNBool _outReturn;
            LNResult errorCode = LNWorldObject_HasTagA(selfObj->handle, _tag, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::hasTag - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_Destroy(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNWorldObject_Destroy(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::destroy - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_GetComponents(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNWorldObject_GetComponents(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn, selfObj->LNWorldObject_GetComponents_AccessorCache);
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::components - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_OnPreUpdate(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNWorldObject_OnPreUpdate_CallOverrideBase(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::onPreUpdate - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldObject_OnUpdate(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObject* selfObj;
    Data_Get_Struct(self, Wrap_WorldObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE elapsedSeconds;
        rb_scan_args(argc, argv, "1", &elapsedSeconds);
        if (LNRB_VALUE_IS_FLOAT(elapsedSeconds))
        {
            float _elapsedSeconds = LNRB_VALUE_TO_FLOAT(elapsedSeconds);
            LNResult errorCode = LNWorldObject_OnUpdate_CallOverrideBase(selfObj->handle, _elapsedSeconds);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldObject::onUpdate - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNWorldObject_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNWorldObject_OnPreUpdate_OverrideCallback(LNHandle worldobject)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_pre_update"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNWorldObject_OnUpdate_OverrideCallback(LNHandle worldobject, float elapsedSeconds)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 1, LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;
}

//==============================================================================
// ln::VisualObject

struct Wrap_VisualObject
    : public Wrap_WorldObject
{

    Wrap_VisualObject()
    {}
};

static void LNVisualObject_delete(Wrap_VisualObject* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNVisualObject_mark(Wrap_VisualObject* obj)
{
	

}

static VALUE LNVisualObject_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_VisualObject* internalObj;

    internalObj = new Wrap_VisualObject();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVisualObject_allocate");
    obj = Data_Wrap_Struct(klass, LNVisualObject_mark, LNVisualObject_delete, internalObj);

    return obj;
}

static VALUE LNVisualObject_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_VisualObject* internalObj;

    internalObj = new Wrap_VisualObject();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVisualObject_allocate");
    obj = Data_Wrap_Struct(klass, LNVisualObject_mark, LNVisualObject_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNVisualObject_SetVisible(int argc, VALUE* argv, VALUE self)
{
    Wrap_VisualObject* selfObj;
    Data_Get_Struct(self, Wrap_VisualObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNVisualObject_SetVisible(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::VisualObject::setVisible - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVisualObject_IsVisible(int argc, VALUE* argv, VALUE self)
{
    Wrap_VisualObject* selfObj;
    Data_Get_Struct(self, Wrap_VisualObject, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNVisualObject_IsVisible(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::VisualObject::isVisible - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVisualObject_SetBlendMode2(int argc, VALUE* argv, VALUE self)
{
    Wrap_VisualObject* selfObj;
    Data_Get_Struct(self, Wrap_VisualObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            LNBlendMode _value = (LNBlendMode)FIX2INT(value);
            LNResult errorCode = LNVisualObject_SetBlendMode2(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::VisualObject::setBlendMode2 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVisualObject_SetOpacity(int argc, VALUE* argv, VALUE self)
{
    Wrap_VisualObject* selfObj;
    Data_Get_Struct(self, Wrap_VisualObject, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNVisualObject_SetOpacity(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::VisualObject::setOpacity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNVisualObject_GetOpacity(int argc, VALUE* argv, VALUE self)
{
    Wrap_VisualObject* selfObj;
    Data_Get_Struct(self, Wrap_VisualObject, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNVisualObject_GetOpacity(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::VisualObject::opacity - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNVisualObject_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNVisualObject_OnPreUpdate_OverrideCallback(LNHandle worldobject)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_pre_update"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNVisualObject_OnUpdate_OverrideCallback(LNHandle worldobject, float elapsedSeconds)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 1, LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;
}

//==============================================================================
// ln::Camera

struct Wrap_Camera
    : public Wrap_WorldObject
{

    Wrap_Camera()
    {}
};

static void LNCamera_delete(Wrap_Camera* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNCamera_mark(Wrap_Camera* obj)
{
	

}

static VALUE LNCamera_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Camera* internalObj;

    internalObj = new Wrap_Camera();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCamera_allocate");
    obj = Data_Wrap_Struct(klass, LNCamera_mark, LNCamera_delete, internalObj);

    return obj;
}

static VALUE LNCamera_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Camera* internalObj;

    internalObj = new Wrap_Camera();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCamera_allocate");
    obj = Data_Wrap_Struct(klass, LNCamera_mark, LNCamera_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNCamera_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNCamera_OnPreUpdate_OverrideCallback(LNHandle worldobject)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_pre_update"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNCamera_OnUpdate_OverrideCallback(LNHandle worldobject, float elapsedSeconds)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 1, LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;
}

//==============================================================================
// ln::EnvironmentLight

struct Wrap_EnvironmentLight
    : public Wrap_WorldObject
{

    Wrap_EnvironmentLight()
    {}
};

static void LNEnvironmentLight_delete(Wrap_EnvironmentLight* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNEnvironmentLight_mark(Wrap_EnvironmentLight* obj)
{
	

}

static VALUE LNEnvironmentLight_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_EnvironmentLight* internalObj;

    internalObj = new Wrap_EnvironmentLight();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEnvironmentLight_allocate");
    obj = Data_Wrap_Struct(klass, LNEnvironmentLight_mark, LNEnvironmentLight_delete, internalObj);

    return obj;
}

static VALUE LNEnvironmentLight_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_EnvironmentLight* internalObj;

    internalObj = new Wrap_EnvironmentLight();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEnvironmentLight_allocate");
    obj = Data_Wrap_Struct(klass, LNEnvironmentLight_mark, LNEnvironmentLight_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNEnvironmentLight_SetEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE enabled;
        rb_scan_args(argc, argv, "1", &enabled);
        if (LNRB_VALUE_IS_BOOL(enabled))
        {
            LNBool _enabled = LNRB_VALUE_TO_BOOL(enabled);
            LNResult errorCode = LNEnvironmentLight_SetEnabled(selfObj->handle, _enabled);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::setEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_IsEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNEnvironmentLight_IsEnabled(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::isEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_SetColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNEnvironmentLight_SetColor(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::setColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_GetColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNColor _outReturn;
            LNResult errorCode = LNEnvironmentLight_GetColor(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::getColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_SetAmbientColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNEnvironmentLight_SetAmbientColor(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::setAmbientColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_GetAmbientColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNColor _outReturn;
            LNResult errorCode = LNEnvironmentLight_GetAmbientColor(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::getAmbientColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_GetSkyColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNColor _outReturn;
            LNResult errorCode = LNEnvironmentLight_GetSkyColor(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::getSkyColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_SetSkyColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNEnvironmentLight_SetSkyColor(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::setSkyColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_GetGroundColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNColor _outReturn;
            LNResult errorCode = LNEnvironmentLight_GetGroundColor(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::getGroundColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_SetGroundColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNEnvironmentLight_SetGroundColor(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::setGroundColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_SetIntensity(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE intensity;
        rb_scan_args(argc, argv, "1", &intensity);
        if (LNRB_VALUE_IS_FLOAT(intensity))
        {
            float _intensity = LNRB_VALUE_TO_FLOAT(intensity);
            LNResult errorCode = LNEnvironmentLight_SetIntensity(selfObj->handle, _intensity);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::setIntensity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_GetIntensity(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNEnvironmentLight_GetIntensity(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::getIntensity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_SetShadowEffectiveDistance(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNEnvironmentLight_SetShadowEffectiveDistance(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::setShadowEffectiveDistance - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_GetShadowEffectiveDistance(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNEnvironmentLight_GetShadowEffectiveDistance(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::shadowEffectiveDistance - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_SetShadowEffectiveDepth(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNEnvironmentLight_SetShadowEffectiveDepth(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::setShadowEffectiveDepth - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEnvironmentLight_GetShadowEffectiveDepth(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLight* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNEnvironmentLight_GetShadowEffectiveDepth(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::EnvironmentLight::shadowEffectiveDepth - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNEnvironmentLight_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNEnvironmentLight_OnPreUpdate_OverrideCallback(LNHandle worldobject)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_pre_update"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNEnvironmentLight_OnUpdate_OverrideCallback(LNHandle worldobject, float elapsedSeconds)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 1, LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;
}

//==============================================================================
// ln::DirectionalLight

struct Wrap_DirectionalLight
    : public Wrap_WorldObject
{

    Wrap_DirectionalLight()
    {}
};

static void LNDirectionalLight_delete(Wrap_DirectionalLight* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNDirectionalLight_mark(Wrap_DirectionalLight* obj)
{
	

}

static VALUE LNDirectionalLight_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_DirectionalLight* internalObj;

    internalObj = new Wrap_DirectionalLight();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNDirectionalLight_allocate");
    obj = Data_Wrap_Struct(klass, LNDirectionalLight_mark, LNDirectionalLight_delete, internalObj);

    return obj;
}

static VALUE LNDirectionalLight_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_DirectionalLight* internalObj;

    internalObj = new Wrap_DirectionalLight();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNDirectionalLight_allocate");
    obj = Data_Wrap_Struct(klass, LNDirectionalLight_mark, LNDirectionalLight_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNDirectionalLight_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLight* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNDirectionalLight_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (1 <= argc && argc <= 1) {
        VALUE color;
        rb_scan_args(argc, argv, "1", &color);
        if (LNRB_VALUE_IS_OBJECT(color))
        {
            LNColor* tmp__color; Data_Get_Struct(color, LNColor, tmp__color);LNColor& _color = *tmp__color;
            LNResult errorCode = LNDirectionalLight_CreateWithColor(&_color, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::DirectionalLight::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNDirectionalLight_SetEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLight* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE enabled;
        rb_scan_args(argc, argv, "1", &enabled);
        if (LNRB_VALUE_IS_BOOL(enabled))
        {
            LNBool _enabled = LNRB_VALUE_TO_BOOL(enabled);
            LNResult errorCode = LNDirectionalLight_SetEnabled(selfObj->handle, _enabled);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::DirectionalLight::setEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNDirectionalLight_IsEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLight* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNDirectionalLight_IsEnabled(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::DirectionalLight::isEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNDirectionalLight_SetColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLight* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE color;
        rb_scan_args(argc, argv, "1", &color);
        if (LNRB_VALUE_IS_OBJECT(color))
        {
            LNColor* tmp__color; Data_Get_Struct(color, LNColor, tmp__color);LNColor& _color = *tmp__color;
            LNResult errorCode = LNDirectionalLight_SetColor(selfObj->handle, &_color);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::DirectionalLight::setColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNDirectionalLight_GetColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLight* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNColor _outReturn;
            LNResult errorCode = LNDirectionalLight_GetColor(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::DirectionalLight::getColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNDirectionalLight_SetIntensity(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLight* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE intensity;
        rb_scan_args(argc, argv, "1", &intensity);
        if (LNRB_VALUE_IS_FLOAT(intensity))
        {
            float _intensity = LNRB_VALUE_TO_FLOAT(intensity);
            LNResult errorCode = LNDirectionalLight_SetIntensity(selfObj->handle, _intensity);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::DirectionalLight::setIntensity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNDirectionalLight_GetIntensity(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLight* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNDirectionalLight_GetIntensity(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::DirectionalLight::getIntensity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNDirectionalLight_SetShadowEffectiveDistance(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLight* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNDirectionalLight_SetShadowEffectiveDistance(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::DirectionalLight::setShadowEffectiveDistance - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNDirectionalLight_GetShadowEffectiveDistance(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLight* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNDirectionalLight_GetShadowEffectiveDistance(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::DirectionalLight::shadowEffectiveDistance - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNDirectionalLight_SetShadowEffectiveDepth(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLight* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNDirectionalLight_SetShadowEffectiveDepth(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::DirectionalLight::setShadowEffectiveDepth - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNDirectionalLight_GetShadowEffectiveDepth(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLight* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNDirectionalLight_GetShadowEffectiveDepth(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::DirectionalLight::shadowEffectiveDepth - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNDirectionalLight_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNDirectionalLight_OnPreUpdate_OverrideCallback(LNHandle worldobject)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_pre_update"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNDirectionalLight_OnUpdate_OverrideCallback(LNHandle worldobject, float elapsedSeconds)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 1, LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;
}

//==============================================================================
// ln::PointLight

struct Wrap_PointLight
    : public Wrap_WorldObject
{

    Wrap_PointLight()
    {}
};

static void LNPointLight_delete(Wrap_PointLight* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNPointLight_mark(Wrap_PointLight* obj)
{
	

}

static VALUE LNPointLight_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_PointLight* internalObj;

    internalObj = new Wrap_PointLight();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPointLight_allocate");
    obj = Data_Wrap_Struct(klass, LNPointLight_mark, LNPointLight_delete, internalObj);

    return obj;
}

static VALUE LNPointLight_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_PointLight* internalObj;

    internalObj = new Wrap_PointLight();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPointLight_allocate");
    obj = Data_Wrap_Struct(klass, LNPointLight_mark, LNPointLight_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNPointLight_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLight* selfObj;
    Data_Get_Struct(self, Wrap_PointLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNPointLight_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 2) {
        VALUE color;
        VALUE range;
        rb_scan_args(argc, argv, "2", &color, &range);
        if (LNRB_VALUE_IS_OBJECT(color) && LNRB_VALUE_IS_FLOAT(range))
        {
            LNColor* tmp__color; Data_Get_Struct(color, LNColor, tmp__color);LNColor& _color = *tmp__color;
            float _range = LNRB_VALUE_TO_FLOAT(range);
            LNResult errorCode = LNPointLight_CreateWithColorAndRange(&_color, _range, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::PointLight::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPointLight_SetEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLight* selfObj;
    Data_Get_Struct(self, Wrap_PointLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE enabled;
        rb_scan_args(argc, argv, "1", &enabled);
        if (LNRB_VALUE_IS_BOOL(enabled))
        {
            LNBool _enabled = LNRB_VALUE_TO_BOOL(enabled);
            LNResult errorCode = LNPointLight_SetEnabled(selfObj->handle, _enabled);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::PointLight::setEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPointLight_IsEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLight* selfObj;
    Data_Get_Struct(self, Wrap_PointLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNPointLight_IsEnabled(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::PointLight::isEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPointLight_SetColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLight* selfObj;
    Data_Get_Struct(self, Wrap_PointLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE color;
        rb_scan_args(argc, argv, "1", &color);
        if (LNRB_VALUE_IS_OBJECT(color))
        {
            LNColor* tmp__color; Data_Get_Struct(color, LNColor, tmp__color);LNColor& _color = *tmp__color;
            LNResult errorCode = LNPointLight_SetColor(selfObj->handle, &_color);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::PointLight::setColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPointLight_GetColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLight* selfObj;
    Data_Get_Struct(self, Wrap_PointLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNColor _outReturn;
            LNResult errorCode = LNPointLight_GetColor(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::PointLight::getColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPointLight_SetIntensity(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLight* selfObj;
    Data_Get_Struct(self, Wrap_PointLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE intensity;
        rb_scan_args(argc, argv, "1", &intensity);
        if (LNRB_VALUE_IS_FLOAT(intensity))
        {
            float _intensity = LNRB_VALUE_TO_FLOAT(intensity);
            LNResult errorCode = LNPointLight_SetIntensity(selfObj->handle, _intensity);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::PointLight::setIntensity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPointLight_GetIntensity(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLight* selfObj;
    Data_Get_Struct(self, Wrap_PointLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNPointLight_GetIntensity(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::PointLight::getIntensity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPointLight_SetRange(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLight* selfObj;
    Data_Get_Struct(self, Wrap_PointLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE range;
        rb_scan_args(argc, argv, "1", &range);
        if (LNRB_VALUE_IS_FLOAT(range))
        {
            float _range = LNRB_VALUE_TO_FLOAT(range);
            LNResult errorCode = LNPointLight_SetRange(selfObj->handle, _range);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::PointLight::setRange - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPointLight_GetRange(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLight* selfObj;
    Data_Get_Struct(self, Wrap_PointLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNPointLight_GetRange(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::PointLight::getRange - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPointLight_SetAttenuation(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLight* selfObj;
    Data_Get_Struct(self, Wrap_PointLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE attenuation;
        rb_scan_args(argc, argv, "1", &attenuation);
        if (LNRB_VALUE_IS_FLOAT(attenuation))
        {
            float _attenuation = LNRB_VALUE_TO_FLOAT(attenuation);
            LNResult errorCode = LNPointLight_SetAttenuation(selfObj->handle, _attenuation);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::PointLight::setAttenuation - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNPointLight_GetAttenuation(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLight* selfObj;
    Data_Get_Struct(self, Wrap_PointLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNPointLight_GetAttenuation(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::PointLight::getAttenuation - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNPointLight_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNPointLight_OnPreUpdate_OverrideCallback(LNHandle worldobject)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_pre_update"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNPointLight_OnUpdate_OverrideCallback(LNHandle worldobject, float elapsedSeconds)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 1, LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;
}

//==============================================================================
// ln::SpotLight

struct Wrap_SpotLight
    : public Wrap_WorldObject
{

    Wrap_SpotLight()
    {}
};

static void LNSpotLight_delete(Wrap_SpotLight* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSpotLight_mark(Wrap_SpotLight* obj)
{
	

}

static VALUE LNSpotLight_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SpotLight* internalObj;

    internalObj = new Wrap_SpotLight();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpotLight_allocate");
    obj = Data_Wrap_Struct(klass, LNSpotLight_mark, LNSpotLight_delete, internalObj);

    return obj;
}

static VALUE LNSpotLight_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SpotLight* internalObj;

    internalObj = new Wrap_SpotLight();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpotLight_allocate");
    obj = Data_Wrap_Struct(klass, LNSpotLight_mark, LNSpotLight_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNSpotLight_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNSpotLight_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (3 <= argc && argc <= 3) {
        VALUE color;
        VALUE range;
        VALUE angle;
        rb_scan_args(argc, argv, "3", &color, &range, &angle);
        if (LNRB_VALUE_IS_OBJECT(color) && LNRB_VALUE_IS_FLOAT(range) && LNRB_VALUE_IS_FLOAT(angle))
        {
            LNColor* tmp__color; Data_Get_Struct(color, LNColor, tmp__color);LNColor& _color = *tmp__color;
            float _range = LNRB_VALUE_TO_FLOAT(range);
            float _angle = LNRB_VALUE_TO_FLOAT(angle);
            LNResult errorCode = LNSpotLight_CreateWithColorAndRange(&_color, _range, _angle, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_SetEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE enabled;
        rb_scan_args(argc, argv, "1", &enabled);
        if (LNRB_VALUE_IS_BOOL(enabled))
        {
            LNBool _enabled = LNRB_VALUE_TO_BOOL(enabled);
            LNResult errorCode = LNSpotLight_SetEnabled(selfObj->handle, _enabled);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::setEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_IsEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNSpotLight_IsEnabled(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::isEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_SetColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE color;
        rb_scan_args(argc, argv, "1", &color);
        if (LNRB_VALUE_IS_OBJECT(color))
        {
            LNColor* tmp__color; Data_Get_Struct(color, LNColor, tmp__color);LNColor& _color = *tmp__color;
            LNResult errorCode = LNSpotLight_SetColor(selfObj->handle, &_color);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::setColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_GetColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNColor _outReturn;
            LNResult errorCode = LNSpotLight_GetColor(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::getColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_SetIntensity(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE intensity;
        rb_scan_args(argc, argv, "1", &intensity);
        if (LNRB_VALUE_IS_FLOAT(intensity))
        {
            float _intensity = LNRB_VALUE_TO_FLOAT(intensity);
            LNResult errorCode = LNSpotLight_SetIntensity(selfObj->handle, _intensity);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::setIntensity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_GetIntensity(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNSpotLight_GetIntensity(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::getIntensity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_SetRange(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE range;
        rb_scan_args(argc, argv, "1", &range);
        if (LNRB_VALUE_IS_FLOAT(range))
        {
            float _range = LNRB_VALUE_TO_FLOAT(range);
            LNResult errorCode = LNSpotLight_SetRange(selfObj->handle, _range);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::setRange - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_GetRange(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNSpotLight_GetRange(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::getRange - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_SetAttenuation(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE attenuation;
        rb_scan_args(argc, argv, "1", &attenuation);
        if (LNRB_VALUE_IS_FLOAT(attenuation))
        {
            float _attenuation = LNRB_VALUE_TO_FLOAT(attenuation);
            LNResult errorCode = LNSpotLight_SetAttenuation(selfObj->handle, _attenuation);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::setAttenuation - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_GetAttenuation(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNSpotLight_GetAttenuation(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::getAttenuation - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_SetAngle(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE angle;
        rb_scan_args(argc, argv, "1", &angle);
        if (LNRB_VALUE_IS_FLOAT(angle))
        {
            float _angle = LNRB_VALUE_TO_FLOAT(angle);
            LNResult errorCode = LNSpotLight_SetAngle(selfObj->handle, _angle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::setAngle - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_GetAngle(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNSpotLight_GetAngle(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::getAngle - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_SetPenumbra(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE penumbra;
        rb_scan_args(argc, argv, "1", &penumbra);
        if (LNRB_VALUE_IS_FLOAT(penumbra))
        {
            float _penumbra = LNRB_VALUE_TO_FLOAT(penumbra);
            LNResult errorCode = LNSpotLight_SetPenumbra(selfObj->handle, _penumbra);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::setPenumbra - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSpotLight_GetPenumbra(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLight* selfObj;
    Data_Get_Struct(self, Wrap_SpotLight, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNSpotLight_GetPenumbra(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::SpotLight::getPenumbra - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNSpotLight_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNSpotLight_OnPreUpdate_OverrideCallback(LNHandle worldobject)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_pre_update"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNSpotLight_OnUpdate_OverrideCallback(LNHandle worldobject, float elapsedSeconds)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 1, LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;
}

//==============================================================================
// ln::TestDelegate

struct Wrap_TestDelegate
    : public Wrap_Object
{

    VALUE m_proc = Qnil;
    Wrap_TestDelegate()
    {}
};

static void LNTestDelegate_delete(Wrap_TestDelegate* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNTestDelegate_mark(Wrap_TestDelegate* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNTestDelegate_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_TestDelegate* internalObj;

    internalObj = new Wrap_TestDelegate();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTestDelegate_allocate");
    obj = Data_Wrap_Struct(klass, LNTestDelegate_mark, LNTestDelegate_delete, internalObj);

    return obj;
}

static VALUE LNTestDelegate_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_TestDelegate* internalObj;

    internalObj = new Wrap_TestDelegate();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTestDelegate_allocate");
    obj = Data_Wrap_Struct(klass, LNTestDelegate_mark, LNTestDelegate_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNTestDelegate_TestDelegate_ProcCaller(LNHandle testdelegate, int p1, int* outReturn)
{
    Wrap_TestDelegate* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(testdelegate), Wrap_TestDelegate, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNI_TO_RUBY_VALUE(p1));
    *outReturn = LNRB_VALUE_TO_NUMBER(retval);
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNTestDelegate_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_TestDelegate* selfObj;
    Data_Get_Struct(self, Wrap_TestDelegate, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNTestDelegate_Create(Wrap_LNTestDelegate_TestDelegate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ln::TestDelegate::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::Sprite

struct Wrap_Sprite
    : public Wrap_VisualObject
{

    Wrap_Sprite()
    {}
};

static void LNSprite_delete(Wrap_Sprite* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSprite_mark(Wrap_Sprite* obj)
{
	

}

static VALUE LNSprite_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Sprite* internalObj;

    internalObj = new Wrap_Sprite();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSprite_allocate");
    obj = Data_Wrap_Struct(klass, LNSprite_mark, LNSprite_delete, internalObj);

    return obj;
}

static VALUE LNSprite_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Sprite* internalObj;

    internalObj = new Wrap_Sprite();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSprite_allocate");
    obj = Data_Wrap_Struct(klass, LNSprite_mark, LNSprite_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNSprite_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sprite* selfObj;
    Data_Get_Struct(self, Wrap_Sprite, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNSprite_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (1 <= argc && argc <= 1) {
        VALUE texture;
        rb_scan_args(argc, argv, "1", &texture);
        if (LNRB_VALUE_IS_OBJECT(texture))
        {
            LNHandle _texture = LuminoRubyRuntimeManager::instance->getHandle(texture);
            LNResult errorCode = LNSprite_CreateWithTexture(_texture, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (3 <= argc && argc <= 3) {
        VALUE texture;
        VALUE width;
        VALUE height;
        rb_scan_args(argc, argv, "3", &texture, &width, &height);
        if (LNRB_VALUE_IS_OBJECT(texture) && LNRB_VALUE_IS_FLOAT(width) && LNRB_VALUE_IS_FLOAT(height))
        {
            LNHandle _texture = LuminoRubyRuntimeManager::instance->getHandle(texture);
            float _width = LNRB_VALUE_TO_FLOAT(width);
            float _height = LNRB_VALUE_TO_FLOAT(height);
            LNResult errorCode = LNSprite_CreateWithTextureAndSize(_texture, _width, _height, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sprite::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSprite_SetTexture(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sprite* selfObj;
    Data_Get_Struct(self, Wrap_Sprite, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult errorCode = LNSprite_SetTexture(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sprite::setTexture - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSprite_SetSize(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sprite* selfObj;
    Data_Get_Struct(self, Wrap_Sprite, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNSize* tmp__value; Data_Get_Struct(value, LNSize, tmp__value);LNSize& _value = *tmp__value;
            LNResult errorCode = LNSprite_SetSize(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 2) {
        VALUE width;
        VALUE height;
        rb_scan_args(argc, argv, "2", &width, &height);
        if (LNRB_VALUE_IS_FLOAT(width) && LNRB_VALUE_IS_FLOAT(height))
        {
            float _width = LNRB_VALUE_TO_FLOAT(width);
            float _height = LNRB_VALUE_TO_FLOAT(height);
            LNResult errorCode = LNSprite_SetSizeWH(selfObj->handle, _width, _height);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sprite::setSize - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSprite_SetSourceRectXYWH(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sprite* selfObj;
    Data_Get_Struct(self, Wrap_Sprite, selfObj);
    if (4 <= argc && argc <= 4) {
        VALUE x;
        VALUE y;
        VALUE width;
        VALUE height;
        rb_scan_args(argc, argv, "4", &x, &y, &width, &height);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(width) && LNRB_VALUE_IS_FLOAT(height))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _width = LNRB_VALUE_TO_FLOAT(width);
            float _height = LNRB_VALUE_TO_FLOAT(height);
            LNResult errorCode = LNSprite_SetSourceRectXYWH(selfObj->handle, _x, _y, _width, _height);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sprite::setSourceRect - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNSprite_SetCallerTest(int argc, VALUE* argv, VALUE self)
{
    Wrap_Sprite* selfObj;
    Data_Get_Struct(self, Wrap_Sprite, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE callback;
        rb_scan_args(argc, argv, "1", &callback);
        if (LNRB_VALUE_IS_OBJECT(callback))
        {
            LNHandle _callback = LuminoRubyRuntimeManager::instance->getHandle(callback);
            LNResult errorCode = LNSprite_SetCallerTest(selfObj->handle, _callback);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_TestDelegate, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult result = LNSprite_SetCallerTest(selfObj->handle, _value);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Sprite::setCallerTest - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNSprite_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNSprite_OnPreUpdate_OverrideCallback(LNHandle worldobject)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_pre_update"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNSprite_OnUpdate_OverrideCallback(LNHandle worldobject, float elapsedSeconds)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 1, LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;
}

//==============================================================================
// ln::CameraOrbitControlComponent

struct Wrap_CameraOrbitControlComponent
    : public Wrap_Component
{

    Wrap_CameraOrbitControlComponent()
    {}
};

static void LNCameraOrbitControlComponent_delete(Wrap_CameraOrbitControlComponent* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNCameraOrbitControlComponent_mark(Wrap_CameraOrbitControlComponent* obj)
{
	

}

static VALUE LNCameraOrbitControlComponent_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_CameraOrbitControlComponent* internalObj;

    internalObj = new Wrap_CameraOrbitControlComponent();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCameraOrbitControlComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNCameraOrbitControlComponent_mark, LNCameraOrbitControlComponent_delete, internalObj);

    return obj;
}

static VALUE LNCameraOrbitControlComponent_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_CameraOrbitControlComponent* internalObj;

    internalObj = new Wrap_CameraOrbitControlComponent();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCameraOrbitControlComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNCameraOrbitControlComponent_mark, LNCameraOrbitControlComponent_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNCameraOrbitControlComponent_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_CameraOrbitControlComponent* selfObj;
    Data_Get_Struct(self, Wrap_CameraOrbitControlComponent, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNCameraOrbitControlComponent_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::CameraOrbitControlComponent::init - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNCameraOrbitControlComponent_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::Raycaster

struct Wrap_Raycaster
    : public Wrap_Object
{

    Wrap_Raycaster()
    {}
};

static void LNRaycaster_delete(Wrap_Raycaster* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNRaycaster_mark(Wrap_Raycaster* obj)
{
	

}

static VALUE LNRaycaster_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Raycaster* internalObj;

    internalObj = new Wrap_Raycaster();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNRaycaster_allocate");
    obj = Data_Wrap_Struct(klass, LNRaycaster_mark, LNRaycaster_delete, internalObj);

    return obj;
}

static VALUE LNRaycaster_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Raycaster* internalObj;

    internalObj = new Wrap_Raycaster();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNRaycaster_allocate");
    obj = Data_Wrap_Struct(klass, LNRaycaster_mark, LNRaycaster_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNRaycaster_FromScreen(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE point;
        rb_scan_args(argc, argv, "1", &point);
        if (LNRB_VALUE_IS_OBJECT(point))
        {
            LNPoint* tmp__point; Data_Get_Struct(point, LNPoint, tmp__point);LNPoint& _point = *tmp__point;
            LNHandle _outReturn;
            LNResult errorCode = LNRaycaster_FromScreen(&_point, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Raycaster::fromScreen - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNRaycaster_IntersectPlane(int argc, VALUE* argv, VALUE self)
{
    Wrap_Raycaster* selfObj;
    Data_Get_Struct(self, Wrap_Raycaster, selfObj);
    if (3 <= argc && argc <= 3) {
        VALUE normalX;
        VALUE normalY;
        VALUE normalZ;
        rb_scan_args(argc, argv, "3", &normalX, &normalY, &normalZ);
        if (LNRB_VALUE_IS_FLOAT(normalX) && LNRB_VALUE_IS_FLOAT(normalY) && LNRB_VALUE_IS_FLOAT(normalZ))
        {
            float _normalX = LNRB_VALUE_TO_FLOAT(normalX);
            float _normalY = LNRB_VALUE_TO_FLOAT(normalY);
            float _normalZ = LNRB_VALUE_TO_FLOAT(normalZ);
            LNHandle _outReturn;
            LNResult errorCode = LNRaycaster_IntersectPlane(selfObj->handle, _normalX, _normalY, _normalZ, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Raycaster::intersectPlane - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNRaycaster_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::RaycastResult

struct Wrap_RaycastResult
    : public Wrap_Object
{

    Wrap_RaycastResult()
    {}
};

static void LNRaycastResult_delete(Wrap_RaycastResult* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNRaycastResult_mark(Wrap_RaycastResult* obj)
{
	

}

static VALUE LNRaycastResult_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_RaycastResult* internalObj;

    internalObj = new Wrap_RaycastResult();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNRaycastResult_allocate");
    obj = Data_Wrap_Struct(klass, LNRaycastResult_mark, LNRaycastResult_delete, internalObj);

    return obj;
}

static VALUE LNRaycastResult_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_RaycastResult* internalObj;

    internalObj = new Wrap_RaycastResult();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNRaycastResult_allocate");
    obj = Data_Wrap_Struct(klass, LNRaycastResult_mark, LNRaycastResult_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNRaycastResult_GetPoint(int argc, VALUE* argv, VALUE self)
{
    Wrap_RaycastResult* selfObj;
    Data_Get_Struct(self, Wrap_RaycastResult, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNVector3 _outReturn;
            LNResult errorCode = LNRaycastResult_GetPoint(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNVector3_allocate(g_class_Vector3);
            *((LNVector3*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::RaycastResult::point - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNRaycastResult_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::WorldRenderView

struct Wrap_WorldRenderView
    : public Wrap_RenderView
{

    Wrap_WorldRenderView()
    {}
};

static void LNWorldRenderView_delete(Wrap_WorldRenderView* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNWorldRenderView_mark(Wrap_WorldRenderView* obj)
{
	

}

static VALUE LNWorldRenderView_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_WorldRenderView* internalObj;

    internalObj = new Wrap_WorldRenderView();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldRenderView_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldRenderView_mark, LNWorldRenderView_delete, internalObj);

    return obj;
}

static VALUE LNWorldRenderView_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_WorldRenderView* internalObj;

    internalObj = new Wrap_WorldRenderView();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldRenderView_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldRenderView_mark, LNWorldRenderView_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNWorldRenderView_SetGuideGridEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldRenderView* selfObj;
    Data_Get_Struct(self, Wrap_WorldRenderView, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNWorldRenderView_SetGuideGridEnabled(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::WorldRenderView::setGuideGridEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNWorldRenderView_GetGuideGridEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldRenderView* selfObj;
    Data_Get_Struct(self, Wrap_WorldRenderView, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNWorldRenderView_GetGuideGridEnabled(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::WorldRenderView::guideGridEnabled - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNWorldRenderView_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::BoxMesh

struct Wrap_BoxMesh
    : public Wrap_VisualObject
{

    Wrap_BoxMesh()
    {}
};

static void LNBoxMesh_delete(Wrap_BoxMesh* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNBoxMesh_mark(Wrap_BoxMesh* obj)
{
	

}

static VALUE LNBoxMesh_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_BoxMesh* internalObj;

    internalObj = new Wrap_BoxMesh();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNBoxMesh_allocate");
    obj = Data_Wrap_Struct(klass, LNBoxMesh_mark, LNBoxMesh_delete, internalObj);

    return obj;
}

static VALUE LNBoxMesh_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_BoxMesh* internalObj;

    internalObj = new Wrap_BoxMesh();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNBoxMesh_allocate");
    obj = Data_Wrap_Struct(klass, LNBoxMesh_mark, LNBoxMesh_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNBoxMesh_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_BoxMesh* selfObj;
    Data_Get_Struct(self, Wrap_BoxMesh, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNBoxMesh_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (3 <= argc && argc <= 3) {
        VALUE width;
        VALUE height;
        VALUE depth;
        rb_scan_args(argc, argv, "3", &width, &height, &depth);
        if (LNRB_VALUE_IS_FLOAT(width) && LNRB_VALUE_IS_FLOAT(height) && LNRB_VALUE_IS_FLOAT(depth))
        {
            float _width = LNRB_VALUE_TO_FLOAT(width);
            float _height = LNRB_VALUE_TO_FLOAT(height);
            float _depth = LNRB_VALUE_TO_FLOAT(depth);
            LNResult errorCode = LNBoxMesh_CreateXYZ(_width, _height, _depth, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::BoxMesh::init - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNBoxMesh_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNBoxMesh_OnPreUpdate_OverrideCallback(LNHandle worldobject)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_pre_update"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNBoxMesh_OnUpdate_OverrideCallback(LNHandle worldobject, float elapsedSeconds)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 1, LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;
}

//==============================================================================
// ln::PlaneMesh

struct Wrap_PlaneMesh
    : public Wrap_VisualObject
{

    Wrap_PlaneMesh()
    {}
};

static void LNPlaneMesh_delete(Wrap_PlaneMesh* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNPlaneMesh_mark(Wrap_PlaneMesh* obj)
{
	

}

static VALUE LNPlaneMesh_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_PlaneMesh* internalObj;

    internalObj = new Wrap_PlaneMesh();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPlaneMesh_allocate");
    obj = Data_Wrap_Struct(klass, LNPlaneMesh_mark, LNPlaneMesh_delete, internalObj);

    return obj;
}

static VALUE LNPlaneMesh_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_PlaneMesh* internalObj;

    internalObj = new Wrap_PlaneMesh();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPlaneMesh_allocate");
    obj = Data_Wrap_Struct(klass, LNPlaneMesh_mark, LNPlaneMesh_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNPlaneMesh_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_PlaneMesh* selfObj;
    Data_Get_Struct(self, Wrap_PlaneMesh, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNPlaneMesh_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::PlaneMesh::init - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNPlaneMesh_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNPlaneMesh_OnPreUpdate_OverrideCallback(LNHandle worldobject)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_pre_update"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNPlaneMesh_OnUpdate_OverrideCallback(LNHandle worldobject, float elapsedSeconds)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 1, LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;
}

//==============================================================================
// ln::StaticMesh

struct Wrap_StaticMesh
    : public Wrap_VisualObject
{
    VALUE LNStaticMesh_GetModel_AccessorCache = Qnil;

    Wrap_StaticMesh()
    {}
};

static void LNStaticMesh_delete(Wrap_StaticMesh* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNStaticMesh_mark(Wrap_StaticMesh* obj)
{
	rb_gc_mark(obj->LNStaticMesh_GetModel_AccessorCache);


}

static VALUE LNStaticMesh_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_StaticMesh* internalObj;

    internalObj = new Wrap_StaticMesh();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNStaticMesh_allocate");
    obj = Data_Wrap_Struct(klass, LNStaticMesh_mark, LNStaticMesh_delete, internalObj);

    return obj;
}

static VALUE LNStaticMesh_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_StaticMesh* internalObj;

    internalObj = new Wrap_StaticMesh();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNStaticMesh_allocate");
    obj = Data_Wrap_Struct(klass, LNStaticMesh_mark, LNStaticMesh_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNStaticMesh_Load(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE filePath;
        rb_scan_args(argc, argv, "1", &filePath);
        if (LNRB_VALUE_IS_STRING(filePath))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNHandle _outReturn;
            LNResult errorCode = LNStaticMesh_LoadA(_filePath, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::StaticMesh::load - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNStaticMesh_GetModel(int argc, VALUE* argv, VALUE self)
{
    Wrap_StaticMesh* selfObj;
    Data_Get_Struct(self, Wrap_StaticMesh, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNStaticMesh_GetModel(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn, selfObj->LNStaticMesh_GetModel_AccessorCache);
        }
    }
    rb_raise(rb_eArgError, "ln::StaticMesh::model - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNStaticMesh_MakeCollisionBody(int argc, VALUE* argv, VALUE self)
{
    Wrap_StaticMesh* selfObj;
    Data_Get_Struct(self, Wrap_StaticMesh, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE meshContainerName;
        rb_scan_args(argc, argv, "1", &meshContainerName);
        if (LNRB_VALUE_IS_STRING(meshContainerName))
        {
            const char* _meshContainerName = LNRB_VALUE_TO_STRING(meshContainerName);
            LNResult errorCode = LNStaticMesh_MakeCollisionBodyA(selfObj->handle, _meshContainerName);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::StaticMesh::makeCollisionBody - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNStaticMesh_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNStaticMesh_OnPreUpdate_OverrideCallback(LNHandle worldobject)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_pre_update"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNStaticMesh_OnUpdate_OverrideCallback(LNHandle worldobject, float elapsedSeconds)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 1, LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;
}

//==============================================================================
// ln::StaticMeshComponent

struct Wrap_StaticMeshComponent
    : public Wrap_VisualComponent
{

    Wrap_StaticMeshComponent()
    {}
};

static void LNStaticMeshComponent_delete(Wrap_StaticMeshComponent* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNStaticMeshComponent_mark(Wrap_StaticMeshComponent* obj)
{
	

}

static VALUE LNStaticMeshComponent_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_StaticMeshComponent* internalObj;

    internalObj = new Wrap_StaticMeshComponent();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNStaticMeshComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNStaticMeshComponent_mark, LNStaticMeshComponent_delete, internalObj);

    return obj;
}

static VALUE LNStaticMeshComponent_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_StaticMeshComponent* internalObj;

    internalObj = new Wrap_StaticMeshComponent();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNStaticMeshComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNStaticMeshComponent_mark, LNStaticMeshComponent_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNStaticMeshComponent_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_StaticMeshComponent* selfObj;
    Data_Get_Struct(self, Wrap_StaticMeshComponent, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNStaticMeshComponent_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::StaticMeshComponent::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNStaticMeshComponent_SetModel(int argc, VALUE* argv, VALUE self)
{
    Wrap_StaticMeshComponent* selfObj;
    Data_Get_Struct(self, Wrap_StaticMeshComponent, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE model;
        rb_scan_args(argc, argv, "1", &model);
        if (LNRB_VALUE_IS_OBJECT(model))
        {
            LNHandle _model = LuminoRubyRuntimeManager::instance->getHandle(model);
            LNResult errorCode = LNStaticMeshComponent_SetModel(selfObj->handle, _model);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::StaticMeshComponent::setModel - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNStaticMeshComponent_MakeCollisionBody(int argc, VALUE* argv, VALUE self)
{
    Wrap_StaticMeshComponent* selfObj;
    Data_Get_Struct(self, Wrap_StaticMeshComponent, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE meshContainerName;
        rb_scan_args(argc, argv, "1", &meshContainerName);
        if (LNRB_VALUE_IS_STRING(meshContainerName))
        {
            const char* _meshContainerName = LNRB_VALUE_TO_STRING(meshContainerName);
            LNResult errorCode = LNStaticMeshComponent_MakeCollisionBodyA(selfObj->handle, _meshContainerName);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::StaticMeshComponent::makeCollisionBody - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNStaticMeshComponent_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::SkinnedMeshComponent

struct Wrap_SkinnedMeshComponent
    : public Wrap_StaticMeshComponent
{

    Wrap_SkinnedMeshComponent()
    {}
};

static void LNSkinnedMeshComponent_delete(Wrap_SkinnedMeshComponent* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSkinnedMeshComponent_mark(Wrap_SkinnedMeshComponent* obj)
{
	

}

static VALUE LNSkinnedMeshComponent_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SkinnedMeshComponent* internalObj;

    internalObj = new Wrap_SkinnedMeshComponent();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSkinnedMeshComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNSkinnedMeshComponent_mark, LNSkinnedMeshComponent_delete, internalObj);

    return obj;
}

static VALUE LNSkinnedMeshComponent_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SkinnedMeshComponent* internalObj;

    internalObj = new Wrap_SkinnedMeshComponent();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSkinnedMeshComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNSkinnedMeshComponent_mark, LNSkinnedMeshComponent_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNSkinnedMeshComponent_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_SkinnedMeshComponent* selfObj;
    Data_Get_Struct(self, Wrap_SkinnedMeshComponent, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNSkinnedMeshComponent_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::SkinnedMeshComponent::init - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNSkinnedMeshComponent_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::Collision

struct Wrap_Collision
    : public Wrap_Object
{
    VALUE LNCollision_GetWorldObject_AccessorCache = Qnil;

    Wrap_Collision()
    {}
};

static void LNCollision_delete(Wrap_Collision* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNCollision_mark(Wrap_Collision* obj)
{
	rb_gc_mark(obj->LNCollision_GetWorldObject_AccessorCache);


}

static VALUE LNCollision_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Collision* internalObj;

    internalObj = new Wrap_Collision();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCollision_allocate");
    obj = Data_Wrap_Struct(klass, LNCollision_mark, LNCollision_delete, internalObj);

    return obj;
}

static VALUE LNCollision_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Collision* internalObj;

    internalObj = new Wrap_Collision();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCollision_allocate");
    obj = Data_Wrap_Struct(klass, LNCollision_mark, LNCollision_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNCollision_GetWorldObject(int argc, VALUE* argv, VALUE self)
{
    Wrap_Collision* selfObj;
    Data_Get_Struct(self, Wrap_Collision, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNCollision_GetWorldObject(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn, selfObj->LNCollision_GetWorldObject_AccessorCache);
        }
    }
    rb_raise(rb_eArgError, "ln::Collision::worldObject - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNCollision_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::TriggerBodyComponent

struct Wrap_TriggerBodyComponent
    : public Wrap_Component
{

    Wrap_TriggerBodyComponent()
    {}
};

static void LNTriggerBodyComponent_delete(Wrap_TriggerBodyComponent* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNTriggerBodyComponent_mark(Wrap_TriggerBodyComponent* obj)
{
	

}

static VALUE LNTriggerBodyComponent_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_TriggerBodyComponent* internalObj;

    internalObj = new Wrap_TriggerBodyComponent();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTriggerBodyComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNTriggerBodyComponent_mark, LNTriggerBodyComponent_delete, internalObj);

    return obj;
}

static VALUE LNTriggerBodyComponent_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_TriggerBodyComponent* internalObj;

    internalObj = new Wrap_TriggerBodyComponent();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTriggerBodyComponent_allocate");
    obj = Data_Wrap_Struct(klass, LNTriggerBodyComponent_mark, LNTriggerBodyComponent_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNTriggerBodyComponent_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_TriggerBodyComponent* selfObj;
    Data_Get_Struct(self, Wrap_TriggerBodyComponent, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNTriggerBodyComponent_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::TriggerBodyComponent::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNTriggerBodyComponent_AddCollisionShape(int argc, VALUE* argv, VALUE self)
{
    Wrap_TriggerBodyComponent* selfObj;
    Data_Get_Struct(self, Wrap_TriggerBodyComponent, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE shape;
        rb_scan_args(argc, argv, "1", &shape);
        if (LNRB_VALUE_IS_OBJECT(shape))
        {
            LNHandle _shape = LuminoRubyRuntimeManager::instance->getHandle(shape);
            LNResult errorCode = LNTriggerBodyComponent_AddCollisionShape(selfObj->handle, _shape);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::TriggerBodyComponent::addCollisionShape - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNTriggerBodyComponent_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::ParticleEmitter

struct Wrap_ParticleEmitter
    : public Wrap_VisualObject
{

    Wrap_ParticleEmitter()
    {}
};

static void LNParticleEmitter_delete(Wrap_ParticleEmitter* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNParticleEmitter_mark(Wrap_ParticleEmitter* obj)
{
	

}

static VALUE LNParticleEmitter_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ParticleEmitter* internalObj;

    internalObj = new Wrap_ParticleEmitter();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleEmitter_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleEmitter_mark, LNParticleEmitter_delete, internalObj);

    return obj;
}

static VALUE LNParticleEmitter_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ParticleEmitter* internalObj;

    internalObj = new Wrap_ParticleEmitter();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleEmitter_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleEmitter_mark, LNParticleEmitter_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNParticleEmitter_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitter* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitter, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE model;
        rb_scan_args(argc, argv, "1", &model);
        if (LNRB_VALUE_IS_OBJECT(model))
        {
            LNHandle _model = LuminoRubyRuntimeManager::instance->getHandle(model);
            LNResult errorCode = LNParticleEmitter_Create(_model, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::ParticleEmitter::init - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNParticleEmitter_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNParticleEmitter_OnPreUpdate_OverrideCallback(LNHandle worldobject)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_pre_update"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNParticleEmitter_OnUpdate_OverrideCallback(LNHandle worldobject, float elapsedSeconds)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(worldobject);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 1, LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;
}

//==============================================================================
// ln::Scene

struct Wrap_Scene
{

    Wrap_Scene()
    {}
};


static VALUE Wrap_LNScene_SetClearMode(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            LNSceneClearMode _value = (LNSceneClearMode)FIX2INT(value);
            LNResult errorCode = LNScene_SetClearMode(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setClearMode - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetSkyColor(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNScene_SetSkyColor(&_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setSkyColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetSkyHorizonColor(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNScene_SetSkyHorizonColor(&_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setSkyHorizonColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetSkyCloudColor(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNScene_SetSkyCloudColor(&_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setSkyCloudColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetSkyOverlayColor(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNScene_SetSkyOverlayColor(&_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setSkyOverlayColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_GotoLevel(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 2) {
        VALUE level;
        VALUE withEffect;
        rb_scan_args(argc, argv, "11", &level, &withEffect);
        if (LNRB_VALUE_IS_OBJECT(level) && LNRB_VALUE_IS_BOOL(withEffect))
        {
            LNHandle _level = LuminoRubyRuntimeManager::instance->getHandle(level);
            LNBool _withEffect = (withEffect != Qnil) ? LNRB_VALUE_TO_BOOL(withEffect) : LN_TRUE;
            LNResult errorCode = LNScene_GotoLevel(_level, _withEffect);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::gotoLevel - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_CallLevel(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 2) {
        VALUE level;
        VALUE withEffect;
        rb_scan_args(argc, argv, "11", &level, &withEffect);
        if (LNRB_VALUE_IS_OBJECT(level) && LNRB_VALUE_IS_BOOL(withEffect))
        {
            LNHandle _level = LuminoRubyRuntimeManager::instance->getHandle(level);
            LNBool _withEffect = (withEffect != Qnil) ? LNRB_VALUE_TO_BOOL(withEffect) : LN_TRUE;
            LNResult errorCode = LNScene_CallLevel(_level, _withEffect);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::callLevel - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_ReturnLevel(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE withEffect;
        rb_scan_args(argc, argv, "01", &withEffect);
        if (LNRB_VALUE_IS_BOOL(withEffect))
        {
            LNBool _withEffect = (withEffect != Qnil) ? LNRB_VALUE_TO_BOOL(withEffect) : LN_TRUE;
            LNResult errorCode = LNScene_ReturnLevel(_withEffect);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::returnLevel - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_ActiveLevel(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNScene_ActiveLevel(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::activeLevel - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_IsTransitionEffectRunning(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNScene_IsTransitionEffectRunning(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::isTransitionEffectRunning - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTransitionEffectMode(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            LNLevelTransitionEffectMode _value = (LNLevelTransitionEffectMode)FIX2INT(value);
            LNResult errorCode = LNScene_SetTransitionEffectMode(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTransitionEffectMode - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_TransitionEffectMode(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNLevelTransitionEffectMode _outReturn;
            LNResult errorCode = LNScene_TransitionEffectMode(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return INT2FIX(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::transitionEffectMode - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTransitionDuration(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetTransitionDuration(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTransitionDuration - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_TransitionDuration(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNScene_TransitionDuration(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::transitionDuration - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTransitionEffectColor(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNScene_SetTransitionEffectColor(&_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTransitionEffectColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_TransitionEffectColor(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNColor _outReturn;
            LNResult errorCode = LNScene_TransitionEffectColor(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::transitionEffectColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTransitionEffectMaskTexture(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult errorCode = LNScene_SetTransitionEffectMaskTexture(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTransitionEffectMaskTexture - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_TransitionEffectMaskTexture(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNScene_TransitionEffectMaskTexture(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::transitionEffectMaskTexture - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTransitionEffectVague(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetTransitionEffectVague(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTransitionEffectVague - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_TransitionEffectVague(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNScene_TransitionEffectVague(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::transitionEffectVague - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_StartFadeOut(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNScene_StartFadeOut();
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::startFadeOut - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_StartFadeIn(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNScene_StartFadeIn();
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::startFadeIn - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetFogStartDistance(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetFogStartDistance(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setFogStartDistance - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetFogColor(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNScene_SetFogColor(&_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setFogColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetFogDensity(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetFogDensity(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setFogDensity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetFogHeightDensity(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetFogHeightDensity(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setFogHeightDensity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetFogLowerHeight(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetFogLowerHeight(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setFogLowerHeight - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetFogUpperHeight(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetFogUpperHeight(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setFogUpperHeight - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetHDREnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNScene_SetHDREnabled(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setHDREnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_IsHDREnabled(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNScene_IsHDREnabled(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::isHDREnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetScreenBlendColor(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNScene_SetScreenBlendColor(&_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setScreenBlendColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_ScreenBlendColor(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNColor _outReturn;
            LNResult errorCode = LNScene_ScreenBlendColor(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::screenBlendColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetColorTone(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColorTone* tmp__value; Data_Get_Struct(value, LNColorTone, tmp__value);LNColorTone& _value = *tmp__value;
            LNResult errorCode = LNScene_SetColorTone(&_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setColorTone - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_ColorTone(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNColorTone _outReturn;
            LNResult errorCode = LNScene_ColorTone(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColorTone_allocate(g_class_ColorTone);
            *((LNColorTone*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::colorTone - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetAntialiasEnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNScene_SetAntialiasEnabled(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setAntialiasEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_IsAntialiasEnabled(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNScene_IsAntialiasEnabled(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::isAntialiasEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetSSREnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNScene_SetSSREnabled(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setSSREnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_IsSSREnabled(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNScene_IsSSREnabled(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::isSSREnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetSSAOEnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNScene_SetSSAOEnabled(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setSSAOEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_IsSSAOEnabled(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNScene_IsSSAOEnabled(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::isSSAOEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetBloomEnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNScene_SetBloomEnabled(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setBloomEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_IsBloomEnabled(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNScene_IsBloomEnabled(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::isBloomEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetDOFEnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNScene_SetDOFEnabled(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setDOFEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_IsDOFEnabled(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNScene_IsDOFEnabled(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::isDOFEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTonemapEnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNScene_SetTonemapEnabled(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTonemapEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_IsTonemapEnabled(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNScene_IsTonemapEnabled(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::isTonemapEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetVignetteEnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNScene_SetVignetteEnabled(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setVignetteEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_IsVignetteEnabled(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNScene_IsVignetteEnabled(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::isVignetteEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetGammaEnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNScene_SetGammaEnabled(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setGammaEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_IsGammaEnabled(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNScene_IsGammaEnabled(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::isGammaEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTonemapExposure(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetTonemapExposure(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTonemapExposure - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTonemapLinearWhite(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetTonemapLinearWhite(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTonemapLinearWhite - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTonemapShoulderStrength(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetTonemapShoulderStrength(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTonemapShoulderStrength - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTonemapLinearStrength(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetTonemapLinearStrength(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTonemapLinearStrength - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTonemapLinearAngle(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetTonemapLinearAngle(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTonemapLinearAngle - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTonemapToeStrength(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetTonemapToeStrength(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTonemapToeStrength - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTonemapToeNumerator(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetTonemapToeNumerator(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTonemapToeNumerator - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNScene_SetTonemapToeDenominator(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNScene_SetTonemapToeDenominator(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Scene::setTonemapToeDenominator - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::Level

struct Wrap_Level
    : public Wrap_AssetObject
{

    Wrap_Level()
    {}
};

static void LNLevel_delete(Wrap_Level* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNLevel_mark(Wrap_Level* obj)
{
	

}

static VALUE LNLevel_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Level* internalObj;

    internalObj = new Wrap_Level();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevel_allocate");
    obj = Data_Wrap_Struct(klass, LNLevel_mark, LNLevel_delete, internalObj);

    return obj;
}

static VALUE LNLevel_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Level* internalObj;

    internalObj = new Wrap_Level();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevel_allocate");
    obj = Data_Wrap_Struct(klass, LNLevel_mark, LNLevel_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNLevel_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_Level* selfObj;
    Data_Get_Struct(self, Wrap_Level, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNLevel_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Level::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNLevel_AddObject(int argc, VALUE* argv, VALUE self)
{
    Wrap_Level* selfObj;
    Data_Get_Struct(self, Wrap_Level, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE obj;
        rb_scan_args(argc, argv, "1", &obj);
        if (LNRB_VALUE_IS_OBJECT(obj))
        {
            LNHandle _obj = LuminoRubyRuntimeManager::instance->getHandle(obj);
            LNResult errorCode = LNLevel_AddObject(selfObj->handle, _obj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Level::addObject - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNLevel_RemoveObject(int argc, VALUE* argv, VALUE self)
{
    Wrap_Level* selfObj;
    Data_Get_Struct(self, Wrap_Level, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE obj;
        rb_scan_args(argc, argv, "1", &obj);
        if (LNRB_VALUE_IS_OBJECT(obj))
        {
            LNHandle _obj = LuminoRubyRuntimeManager::instance->getHandle(obj);
            LNResult errorCode = LNLevel_RemoveObject(selfObj->handle, _obj);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Level::removeObject - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNLevel_AddSubLevel(int argc, VALUE* argv, VALUE self)
{
    Wrap_Level* selfObj;
    Data_Get_Struct(self, Wrap_Level, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE sublevel;
        rb_scan_args(argc, argv, "1", &sublevel);
        if (LNRB_VALUE_IS_OBJECT(sublevel))
        {
            LNHandle _sublevel = LuminoRubyRuntimeManager::instance->getHandle(sublevel);
            LNResult errorCode = LNLevel_AddSubLevel(selfObj->handle, _sublevel);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Level::addSubLevel - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNLevel_RemoveSubLevel(int argc, VALUE* argv, VALUE self)
{
    Wrap_Level* selfObj;
    Data_Get_Struct(self, Wrap_Level, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE sublevel;
        rb_scan_args(argc, argv, "1", &sublevel);
        if (LNRB_VALUE_IS_OBJECT(sublevel))
        {
            LNHandle _sublevel = LuminoRubyRuntimeManager::instance->getHandle(sublevel);
            LNResult errorCode = LNLevel_RemoveSubLevel(selfObj->handle, _sublevel);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Level::removeSubLevel - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNLevel_RemoveAllSubLevels(int argc, VALUE* argv, VALUE self)
{
    Wrap_Level* selfObj;
    Data_Get_Struct(self, Wrap_Level, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNLevel_RemoveAllSubLevels(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Level::removeAllSubLevels - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNLevel_OnStart(int argc, VALUE* argv, VALUE self)
{
    Wrap_Level* selfObj;
    Data_Get_Struct(self, Wrap_Level, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNLevel_OnStart_CallOverrideBase(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Level::onStart - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNLevel_OnStop(int argc, VALUE* argv, VALUE self)
{
    Wrap_Level* selfObj;
    Data_Get_Struct(self, Wrap_Level, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNLevel_OnStop_CallOverrideBase(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Level::onStop - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNLevel_OnPause(int argc, VALUE* argv, VALUE self)
{
    Wrap_Level* selfObj;
    Data_Get_Struct(self, Wrap_Level, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNLevel_OnPause_CallOverrideBase(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Level::onPause - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNLevel_OnResume(int argc, VALUE* argv, VALUE self)
{
    Wrap_Level* selfObj;
    Data_Get_Struct(self, Wrap_Level, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNLevel_OnResume_CallOverrideBase(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Level::onResume - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNLevel_OnUpdate(int argc, VALUE* argv, VALUE self)
{
    Wrap_Level* selfObj;
    Data_Get_Struct(self, Wrap_Level, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNLevel_OnUpdate_CallOverrideBase(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Level::onUpdate - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNLevel_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNLevel_OnStart_OverrideCallback(LNHandle level)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(level);
    VALUE retval = rb_funcall(obj, rb_intern("on_start"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNLevel_OnStop_OverrideCallback(LNHandle level)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(level);
    VALUE retval = rb_funcall(obj, rb_intern("on_stop"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNLevel_OnPause_OverrideCallback(LNHandle level)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(level);
    VALUE retval = rb_funcall(obj, rb_intern("on_pause"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNLevel_OnResume_OverrideCallback(LNHandle level)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(level);
    VALUE retval = rb_funcall(obj, rb_intern("on_resume"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNLevel_OnUpdate_OverrideCallback(LNHandle level)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(level);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 0, 0);
    return LN_OK;
}

//==============================================================================
// ln::UIColors

struct Wrap_UIColors
{

    Wrap_UIColors()
    {}
};


static VALUE Wrap_LNUIColors_Red(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Red(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::red - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Pink(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Pink(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::pink - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Purple(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Purple(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::purple - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_DeepPurple(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_DeepPurple(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::deepPurple - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Indigo(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Indigo(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::indigo - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Blue(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Blue(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::blue - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_LightBlue(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_LightBlue(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::lightBlue - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Cyan(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Cyan(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::cyan - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Teal(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Teal(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::teal - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Green(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Green(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::green - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_LightGreen(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_LightGreen(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::lightGreen - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Lime(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Lime(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::lime - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Yellow(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Yellow(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::yellow - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Amber(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Amber(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::amber - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Orange(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Orange(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::orange - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_DeepOrange(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_DeepOrange(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::deepOrange - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Brown(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Brown(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::brown - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Grey(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 1) {
        VALUE shades;
        rb_scan_args(argc, argv, "01", &shades);
        if (LNRB_VALUE_IS_NUMBER(shades))
        {
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Grey(_shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::grey - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIColors_Get(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 2) {
        VALUE hue;
        VALUE shades;
        rb_scan_args(argc, argv, "11", &hue, &shades);
        if (LNRB_VALUE_IS_NUMBER(hue) && LNRB_VALUE_IS_NUMBER(shades))
        {
            LNUIColorHues _hue = (LNUIColorHues)FIX2INT(hue);
            int _shades = (shades != Qnil) ? LNRB_VALUE_TO_NUMBER(shades) : 5;
            LNColor _outReturn;
            LNResult errorCode = LNUIColors_Get(_hue, _shades, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIColors::get - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::UIEventArgs

struct Wrap_UIEventArgs
    : public Wrap_Object
{

    Wrap_UIEventArgs()
    {}
};

static void LNUIEventArgs_delete(Wrap_UIEventArgs* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIEventArgs_mark(Wrap_UIEventArgs* obj)
{
	

}

static VALUE LNUIEventArgs_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIEventArgs* internalObj;

    internalObj = new Wrap_UIEventArgs();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIEventArgs_allocate");
    obj = Data_Wrap_Struct(klass, LNUIEventArgs_mark, LNUIEventArgs_delete, internalObj);

    return obj;
}

static VALUE LNUIEventArgs_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIEventArgs* internalObj;

    internalObj = new Wrap_UIEventArgs();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIEventArgs_allocate");
    obj = Data_Wrap_Struct(klass, LNUIEventArgs_mark, LNUIEventArgs_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIEventArgs_Sender(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIEventArgs* selfObj;
    Data_Get_Struct(self, Wrap_UIEventArgs, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNUIEventArgs_Sender(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIEventArgs::sender - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIEventArgs_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIGeneralEventHandler

struct Wrap_UIGeneralEventHandler
    : public Wrap_Object
{

    VALUE m_proc = Qnil;
    Wrap_UIGeneralEventHandler()
    {}
};

static void LNUIGeneralEventHandler_delete(Wrap_UIGeneralEventHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIGeneralEventHandler_mark(Wrap_UIGeneralEventHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIGeneralEventHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIGeneralEventHandler* internalObj;

    internalObj = new Wrap_UIGeneralEventHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIGeneralEventHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIGeneralEventHandler_mark, LNUIGeneralEventHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIGeneralEventHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIGeneralEventHandler* internalObj;

    internalObj = new Wrap_UIGeneralEventHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIGeneralEventHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIGeneralEventHandler_mark, LNUIGeneralEventHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIGeneralEventHandler_UIGeneralEventHandler_ProcCaller(LNHandle uigeneraleventhandler, LNHandle p1)
{
    Wrap_UIGeneralEventHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uigeneraleventhandler), Wrap_UIGeneralEventHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(p1));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIGeneralEventHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIGeneralEventHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIGeneralEventHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIGeneralEventHandler_Create(Wrap_LNUIGeneralEventHandler_UIGeneralEventHandler_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ln::UIGeneralEventHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::UIEventHandler

struct Wrap_UIEventHandler
    : public Wrap_Object
{

    VALUE m_proc = Qnil;
    Wrap_UIEventHandler()
    {}
};

static void LNUIEventHandler_delete(Wrap_UIEventHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIEventHandler_mark(Wrap_UIEventHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIEventHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIEventHandler* internalObj;

    internalObj = new Wrap_UIEventHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIEventHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIEventHandler_mark, LNUIEventHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIEventHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIEventHandler* internalObj;

    internalObj = new Wrap_UIEventHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIEventHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIEventHandler_mark, LNUIEventHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIEventHandler_UIEventHandler_ProcCaller(LNHandle uieventhandler)
{
    Wrap_UIEventHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uieventhandler), Wrap_UIEventHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 0, );
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIEventHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIEventHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIEventHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIEventHandler_Create(Wrap_LNUIEventHandler_UIEventHandler_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ln::UIEventHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::UILayoutElement

struct Wrap_UILayoutElement
    : public Wrap_Object
{

    Wrap_UILayoutElement()
    {}
};

static void LNUILayoutElement_delete(Wrap_UILayoutElement* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUILayoutElement_mark(Wrap_UILayoutElement* obj)
{
	

}

static VALUE LNUILayoutElement_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UILayoutElement* internalObj;

    internalObj = new Wrap_UILayoutElement();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUILayoutElement_allocate");
    obj = Data_Wrap_Struct(klass, LNUILayoutElement_mark, LNUILayoutElement_delete, internalObj);

    return obj;
}

static VALUE LNUILayoutElement_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UILayoutElement* internalObj;

    internalObj = new Wrap_UILayoutElement();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUILayoutElement_allocate");
    obj = Data_Wrap_Struct(klass, LNUILayoutElement_mark, LNUILayoutElement_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNUILayoutElement_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIElement

struct Wrap_UIElement
    : public Wrap_UILayoutElement
{
    VALUE LNUIElement_GetData_AccessorCache = Qnil;

    Wrap_UIElement()
    {}
};

static void LNUIElement_delete(Wrap_UIElement* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIElement_mark(Wrap_UIElement* obj)
{
	rb_gc_mark(obj->LNUIElement_GetData_AccessorCache);


}

static VALUE LNUIElement_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIElement* internalObj;

    internalObj = new Wrap_UIElement();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIElement_allocate");
    obj = Data_Wrap_Struct(klass, LNUIElement_mark, LNUIElement_delete, internalObj);

    return obj;
}

static VALUE LNUIElement_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIElement* internalObj;

    internalObj = new Wrap_UIElement();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIElement_allocate");
    obj = Data_Wrap_Struct(klass, LNUIElement_mark, LNUIElement_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIElement_SetSize(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE size;
        rb_scan_args(argc, argv, "1", &size);
        if (LNRB_VALUE_IS_OBJECT(size))
        {
            LNSize* tmp__size; Data_Get_Struct(size, LNSize, tmp__size);LNSize& _size = *tmp__size;
            LNResult errorCode = LNUIElement_SetSize(selfObj->handle, &_size);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 2) {
        VALUE width;
        VALUE height;
        rb_scan_args(argc, argv, "2", &width, &height);
        if (LNRB_VALUE_IS_FLOAT(width) && LNRB_VALUE_IS_FLOAT(height))
        {
            float _width = LNRB_VALUE_TO_FLOAT(width);
            float _height = LNRB_VALUE_TO_FLOAT(height);
            LNResult errorCode = LNUIElement_SetSizeWH(selfObj->handle, _width, _height);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setSize - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetWidth(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNUIElement_SetWidth(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setWidth - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetWidth(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNUIElement_GetWidth(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::width - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetHeight(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNUIElement_SetHeight(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setHeight - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetHeight(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNUIElement_GetHeight(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::height - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetMargin(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE margin;
        rb_scan_args(argc, argv, "1", &margin);
        if (LNRB_VALUE_IS_OBJECT(margin))
        {
            LNThickness* tmp__margin; Data_Get_Struct(margin, LNThickness, tmp__margin);LNThickness& _margin = *tmp__margin;
            LNResult errorCode = LNUIElement_SetMargin(selfObj->handle, &_margin);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setMargin - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetMargin(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNThickness _outReturn;
            LNResult errorCode = LNUIElement_GetMargin(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNThickness_allocate(g_class_Thickness);
            *((LNThickness*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::margin - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetPadding(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE padding;
        rb_scan_args(argc, argv, "1", &padding);
        if (LNRB_VALUE_IS_OBJECT(padding))
        {
            LNThickness* tmp__padding; Data_Get_Struct(padding, LNThickness, tmp__padding);LNThickness& _padding = *tmp__padding;
            LNResult errorCode = LNUIElement_SetPadding(selfObj->handle, &_padding);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setPadding - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetPadding(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNThickness _outReturn;
            LNResult errorCode = LNUIElement_GetPadding(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNThickness_allocate(g_class_Thickness);
            *((LNThickness*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::padding - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetHAlignment(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            LNUIHAlignment _value = (LNUIHAlignment)FIX2INT(value);
            LNResult errorCode = LNUIElement_SetHAlignment(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setHAlignment - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetHAlignment(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNUIHAlignment _outReturn;
            LNResult errorCode = LNUIElement_GetHAlignment(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return INT2FIX(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::hAlignment - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetVAlignment(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            LNUIVAlignment _value = (LNUIVAlignment)FIX2INT(value);
            LNResult errorCode = LNUIElement_SetVAlignment(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setVAlignment - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetVAlignment(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNUIVAlignment _outReturn;
            LNResult errorCode = LNUIElement_GetVAlignment(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return INT2FIX(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::vAlignment - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetAlignments(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (2 <= argc && argc <= 2) {
        VALUE halign;
        VALUE valign;
        rb_scan_args(argc, argv, "2", &halign, &valign);
        if (LNRB_VALUE_IS_NUMBER(halign) && LNRB_VALUE_IS_NUMBER(valign))
        {
            LNUIHAlignment _halign = (LNUIHAlignment)FIX2INT(halign);
            LNUIVAlignment _valign = (LNUIVAlignment)FIX2INT(valign);
            LNResult errorCode = LNUIElement_SetAlignments(selfObj->handle, _halign, _valign);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setAlignments - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetPosition(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE pos;
        rb_scan_args(argc, argv, "1", &pos);
        if (LNRB_VALUE_IS_OBJECT(pos))
        {
            LNVector3* tmp__pos; Data_Get_Struct(pos, LNVector3, tmp__pos);LNVector3& _pos = *tmp__pos;
            LNResult errorCode = LNUIElement_SetPosition(selfObj->handle, &_pos);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 3) {
        VALUE x;
        VALUE y;
        VALUE z;
        rb_scan_args(argc, argv, "21", &x, &y, &z);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(z))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _z = (z != Qnil) ? LNRB_VALUE_TO_FLOAT(z) : 0.000000;
            LNResult errorCode = LNUIElement_SetPositionXYZ(selfObj->handle, _x, _y, _z);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setPosition - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetPosition(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNVector3 _outReturn;
            LNResult errorCode = LNUIElement_GetPosition(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNVector3_allocate(g_class_Vector3);
            *((LNVector3*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::position - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetRotation(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE rot;
        rb_scan_args(argc, argv, "1", &rot);
        if (LNRB_VALUE_IS_OBJECT(rot))
        {
            LNQuaternion* tmp__rot; Data_Get_Struct(rot, LNQuaternion, tmp__rot);LNQuaternion& _rot = *tmp__rot;
            LNResult errorCode = LNUIElement_SetRotation(selfObj->handle, &_rot);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setRotation - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetEulerAngles(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (3 <= argc && argc <= 3) {
        VALUE x;
        VALUE y;
        VALUE z;
        rb_scan_args(argc, argv, "3", &x, &y, &z);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(z))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _z = LNRB_VALUE_TO_FLOAT(z);
            LNResult errorCode = LNUIElement_SetEulerAngles(selfObj->handle, _x, _y, _z);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setEulerAngles - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetRotation(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNQuaternion _outReturn;
            LNResult errorCode = LNUIElement_GetRotation(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNQuaternion_allocate(g_class_Quaternion);
            *((LNQuaternion*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::rotation - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetScale(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE scale;
        rb_scan_args(argc, argv, "1", &scale);
        if (LNRB_VALUE_IS_OBJECT(scale))
        {
            LNVector3* tmp__scale; Data_Get_Struct(scale, LNVector3, tmp__scale);LNVector3& _scale = *tmp__scale;
            LNResult errorCode = LNUIElement_SetScale(selfObj->handle, &_scale);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (1 <= argc && argc <= 1) {
        VALUE xyz;
        rb_scan_args(argc, argv, "1", &xyz);
        if (LNRB_VALUE_IS_FLOAT(xyz))
        {
            float _xyz = LNRB_VALUE_TO_FLOAT(xyz);
            LNResult errorCode = LNUIElement_SetScaleS(selfObj->handle, _xyz);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 2) {
        VALUE x;
        VALUE y;
        rb_scan_args(argc, argv, "2", &x, &y);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            LNResult errorCode = LNUIElement_SetScaleXY(selfObj->handle, _x, _y);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setScale - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetScale(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNVector3 _outReturn;
            LNResult errorCode = LNUIElement_GetScale(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNVector3_allocate(g_class_Vector3);
            *((LNVector3*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::scale - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetCenterPoint(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNVector3* tmp__value; Data_Get_Struct(value, LNVector3, tmp__value);LNVector3& _value = *tmp__value;
            LNResult errorCode = LNUIElement_SetCenterPoint(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 3) {
        VALUE x;
        VALUE y;
        VALUE z;
        rb_scan_args(argc, argv, "21", &x, &y, &z);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(z))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _z = (z != Qnil) ? LNRB_VALUE_TO_FLOAT(z) : 0.000000;
            LNResult errorCode = LNUIElement_SetCenterPointXYZ(selfObj->handle, _x, _y, _z);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setCenterPoint - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetCenterPoint(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNVector3 _outReturn;
            LNResult errorCode = LNUIElement_GetCenterPoint(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNVector3_allocate(g_class_Vector3);
            *((LNVector3*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::centerPoint - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNUIElement_SetEnabled(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_IsEnabled(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNUIElement_IsEnabled(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::isEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetData(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNResult errorCode = LNUIElement_SetData(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setData - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetData(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNUIElement_GetData(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn, selfObj->LNUIElement_GetData_AccessorCache);
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::data - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetBackgroundColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNUIElement_SetBackgroundColor(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setBackgroundColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetBackgroundColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNColor _outReturn;
            LNResult errorCode = LNUIElement_GetBackgroundColor(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::backgroundColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetBorderThickness(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNThickness* tmp__value; Data_Get_Struct(value, LNThickness, tmp__value);LNThickness& _value = *tmp__value;
            LNResult errorCode = LNUIElement_SetBorderThickness(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setBorderThickness - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetBorderThickness(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNThickness _outReturn;
            LNResult errorCode = LNUIElement_GetBorderThickness(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNThickness_allocate(g_class_Thickness);
            *((LNThickness*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::borderThickness - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetBorderColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNColor* tmp__value; Data_Get_Struct(value, LNColor, tmp__value);LNColor& _value = *tmp__value;
            LNResult errorCode = LNUIElement_SetBorderColor(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setBorderColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetBorderColor(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNColor _outReturn;
            LNResult errorCode = LNUIElement_GetBorderColor(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNColor_allocate(g_class_Color);
            *((LNColor*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::borderColor - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetCornerRadius(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_OBJECT(value))
        {
            LNCornerRadius* tmp__value; Data_Get_Struct(value, LNCornerRadius, tmp__value);LNCornerRadius& _value = *tmp__value;
            LNResult errorCode = LNUIElement_SetCornerRadius(selfObj->handle, &_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setCornerRadius - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetCornerRadius(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNCornerRadius _outReturn;
            LNResult errorCode = LNUIElement_GetCornerRadius(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNCornerRadius_allocate(g_class_CornerRadius);
            *((LNCornerRadius*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::cornerRadius - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetVisibility(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            LNUIVisibility _value = (LNUIVisibility)FIX2INT(value);
            LNResult errorCode = LNUIElement_SetVisibility(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setVisibility - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetVisibility(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNUIVisibility _outReturn;
            LNResult errorCode = LNUIElement_GetVisibility(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return INT2FIX(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::visibility - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetOpacity(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNUIElement_SetOpacity(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setOpacity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetOpacity(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            float _outReturn;
            LNResult errorCode = LNUIElement_GetOpacity(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::opacity - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_AddChild(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE child;
        rb_scan_args(argc, argv, "1", &child);
        if (LNRB_VALUE_IS_OBJECT(child))
        {
            LNHandle _child = LuminoRubyRuntimeManager::instance->getHandle(child);
            LNResult errorCode = LNUIElement_AddChild(selfObj->handle, _child);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::addChild - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_SetFocusable(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNUIElement_SetFocusable(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::setFocusable - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIElement_GetFocusable(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElement* selfObj;
    Data_Get_Struct(self, Wrap_UIElement, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNUIElement_GetFocusable(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIElement::focusable - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIElement_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UITextBlock

struct Wrap_UITextBlock
    : public Wrap_UIElement
{

    Wrap_UITextBlock()
    {}
};

static void LNUITextBlock_delete(Wrap_UITextBlock* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUITextBlock_mark(Wrap_UITextBlock* obj)
{
	

}

static VALUE LNUITextBlock_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UITextBlock* internalObj;

    internalObj = new Wrap_UITextBlock();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUITextBlock_allocate");
    obj = Data_Wrap_Struct(klass, LNUITextBlock_mark, LNUITextBlock_delete, internalObj);

    return obj;
}

static VALUE LNUITextBlock_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UITextBlock* internalObj;

    internalObj = new Wrap_UITextBlock();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUITextBlock_allocate");
    obj = Data_Wrap_Struct(klass, LNUITextBlock_mark, LNUITextBlock_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUITextBlock_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UITextBlock* selfObj;
    Data_Get_Struct(self, Wrap_UITextBlock, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNUITextBlock_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (1 <= argc && argc <= 1) {
        VALUE text;
        rb_scan_args(argc, argv, "1", &text);
        if (LNRB_VALUE_IS_STRING(text))
        {
            const char* _text = LNRB_VALUE_TO_STRING(text);
            LNResult errorCode = LNUITextBlock_CreateWithTextA(_text, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UITextBlock::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUITextBlock_SetText(int argc, VALUE* argv, VALUE self)
{
    Wrap_UITextBlock* selfObj;
    Data_Get_Struct(self, Wrap_UITextBlock, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_STRING(value))
        {
            const char* _value = LNRB_VALUE_TO_STRING(value);
            LNResult errorCode = LNUITextBlock_SetTextA(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UITextBlock::setText - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUITextBlock_GetText(int argc, VALUE* argv, VALUE self)
{
    Wrap_UITextBlock* selfObj;
    Data_Get_Struct(self, Wrap_UITextBlock, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            const char* _outReturn;
            LNResult errorCode = LNUITextBlock_GetTextA(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UITextBlock::text - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUITextBlock_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UISprite

struct Wrap_UISprite
    : public Wrap_UIElement
{

    Wrap_UISprite()
    {}
};

static void LNUISprite_delete(Wrap_UISprite* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUISprite_mark(Wrap_UISprite* obj)
{
	

}

static VALUE LNUISprite_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UISprite* internalObj;

    internalObj = new Wrap_UISprite();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUISprite_allocate");
    obj = Data_Wrap_Struct(klass, LNUISprite_mark, LNUISprite_delete, internalObj);

    return obj;
}

static VALUE LNUISprite_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UISprite* internalObj;

    internalObj = new Wrap_UISprite();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUISprite_allocate");
    obj = Data_Wrap_Struct(klass, LNUISprite_mark, LNUISprite_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUISprite_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UISprite* selfObj;
    Data_Get_Struct(self, Wrap_UISprite, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNUISprite_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (1 <= argc && argc <= 1) {
        VALUE texture;
        rb_scan_args(argc, argv, "1", &texture);
        if (LNRB_VALUE_IS_OBJECT(texture))
        {
            LNHandle _texture = LuminoRubyRuntimeManager::instance->getHandle(texture);
            LNResult errorCode = LNUISprite_CreateWithTexture(_texture, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UISprite::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUISprite_SetTexture(int argc, VALUE* argv, VALUE self)
{
    Wrap_UISprite* selfObj;
    Data_Get_Struct(self, Wrap_UISprite, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE texture;
        rb_scan_args(argc, argv, "1", &texture);
        if (LNRB_VALUE_IS_OBJECT(texture))
        {
            LNHandle _texture = LuminoRubyRuntimeManager::instance->getHandle(texture);
            LNResult errorCode = LNUISprite_SetTexture(selfObj->handle, _texture);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UISprite::setTexture - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUISprite_SetSourceRect(int argc, VALUE* argv, VALUE self)
{
    Wrap_UISprite* selfObj;
    Data_Get_Struct(self, Wrap_UISprite, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE rect;
        rb_scan_args(argc, argv, "1", &rect);
        if (LNRB_VALUE_IS_OBJECT(rect))
        {
            LNRect* tmp__rect; Data_Get_Struct(rect, LNRect, tmp__rect);LNRect& _rect = *tmp__rect;
            LNResult errorCode = LNUISprite_SetSourceRect(selfObj->handle, &_rect);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (4 <= argc && argc <= 4) {
        VALUE x;
        VALUE y;
        VALUE width;
        VALUE height;
        rb_scan_args(argc, argv, "4", &x, &y, &width, &height);
        if (LNRB_VALUE_IS_FLOAT(x) && LNRB_VALUE_IS_FLOAT(y) && LNRB_VALUE_IS_FLOAT(width) && LNRB_VALUE_IS_FLOAT(height))
        {
            float _x = LNRB_VALUE_TO_FLOAT(x);
            float _y = LNRB_VALUE_TO_FLOAT(y);
            float _width = LNRB_VALUE_TO_FLOAT(width);
            float _height = LNRB_VALUE_TO_FLOAT(height);
            LNResult errorCode = LNUISprite_SetSourceRectXYWH(selfObj->handle, _x, _y, _width, _height);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UISprite::setSourceRect - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUISprite_GetSourceRect(int argc, VALUE* argv, VALUE self)
{
    Wrap_UISprite* selfObj;
    Data_Get_Struct(self, Wrap_UISprite, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNRect _outReturn;
            LNResult errorCode = LNUISprite_GetSourceRect(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNRect_allocate(g_class_Rect);
            *((LNRect*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::UISprite::sourceRect - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUISprite_SetShader(int argc, VALUE* argv, VALUE self)
{
    Wrap_UISprite* selfObj;
    Data_Get_Struct(self, Wrap_UISprite, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE shader;
        rb_scan_args(argc, argv, "1", &shader);
        if (LNRB_VALUE_IS_OBJECT(shader))
        {
            LNHandle _shader = LuminoRubyRuntimeManager::instance->getHandle(shader);
            LNResult errorCode = LNUISprite_SetShader(selfObj->handle, _shader);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UISprite::setShader - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUISprite_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIIcon

struct Wrap_UIIcon
    : public Wrap_UIElement
{

    Wrap_UIIcon()
    {}
};

static void LNUIIcon_delete(Wrap_UIIcon* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIIcon_mark(Wrap_UIIcon* obj)
{
	

}

static VALUE LNUIIcon_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIIcon* internalObj;

    internalObj = new Wrap_UIIcon();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIIcon_allocate");
    obj = Data_Wrap_Struct(klass, LNUIIcon_mark, LNUIIcon_delete, internalObj);

    return obj;
}

static VALUE LNUIIcon_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIIcon* internalObj;

    internalObj = new Wrap_UIIcon();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIIcon_allocate");
    obj = Data_Wrap_Struct(klass, LNUIIcon_mark, LNUIIcon_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIIcon_LoadFontIcon(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE iconName;
        rb_scan_args(argc, argv, "1", &iconName);
        if (LNRB_VALUE_IS_STRING(iconName))
        {
            const char* _iconName = LNRB_VALUE_TO_STRING(iconName);
            LNHandle _outReturn;
            LNResult errorCode = LNUIIcon_LoadFontIconA(_iconName, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    if (2 <= argc && argc <= 2) {
        VALUE iconName;
        VALUE size;
        rb_scan_args(argc, argv, "2", &iconName, &size);
        if (LNRB_VALUE_IS_STRING(iconName) && LNRB_VALUE_IS_NUMBER(size))
        {
            const char* _iconName = LNRB_VALUE_TO_STRING(iconName);
            int _size = LNRB_VALUE_TO_NUMBER(size);
            LNHandle _outReturn;
            LNResult errorCode = LNUIIcon_LoadFontIconWithNameSizeA(_iconName, _size, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    if (3 <= argc && argc <= 3) {
        VALUE iconName;
        VALUE size;
        VALUE color;
        rb_scan_args(argc, argv, "3", &iconName, &size, &color);
        if (LNRB_VALUE_IS_STRING(iconName) && LNRB_VALUE_IS_NUMBER(size) && LNRB_VALUE_IS_OBJECT(color))
        {
            const char* _iconName = LNRB_VALUE_TO_STRING(iconName);
            int _size = LNRB_VALUE_TO_NUMBER(size);
            LNColor* tmp__color; Data_Get_Struct(color, LNColor, tmp__color);LNColor& _color = *tmp__color;
            LNHandle _outReturn;
            LNResult errorCode = LNUIIcon_LoadFontIconWithNameSizeColorA(_iconName, _size, &_color, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIIcon::loadFontIcon - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIIcon_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIMessageTextArea

struct Wrap_UIMessageTextArea
    : public Wrap_UIElement
{

    Wrap_UIMessageTextArea()
    {}
};

static void LNUIMessageTextArea_delete(Wrap_UIMessageTextArea* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIMessageTextArea_mark(Wrap_UIMessageTextArea* obj)
{
	

}

static VALUE LNUIMessageTextArea_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIMessageTextArea* internalObj;

    internalObj = new Wrap_UIMessageTextArea();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIMessageTextArea_allocate");
    obj = Data_Wrap_Struct(klass, LNUIMessageTextArea_mark, LNUIMessageTextArea_delete, internalObj);

    return obj;
}

static VALUE LNUIMessageTextArea_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIMessageTextArea* internalObj;

    internalObj = new Wrap_UIMessageTextArea();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIMessageTextArea_allocate");
    obj = Data_Wrap_Struct(klass, LNUIMessageTextArea_mark, LNUIMessageTextArea_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIMessageTextArea_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIMessageTextArea* selfObj;
    Data_Get_Struct(self, Wrap_UIMessageTextArea, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNUIMessageTextArea_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIMessageTextArea::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIMessageTextArea_SetText(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIMessageTextArea* selfObj;
    Data_Get_Struct(self, Wrap_UIMessageTextArea, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_STRING(value))
        {
            const char* _value = LNRB_VALUE_TO_STRING(value);
            LNResult errorCode = LNUIMessageTextArea_SetTextA(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIMessageTextArea::setText - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIMessageTextArea_SetTypingSpeed(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIMessageTextArea* selfObj;
    Data_Get_Struct(self, Wrap_UIMessageTextArea, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_FLOAT(value))
        {
            float _value = LNRB_VALUE_TO_FLOAT(value);
            LNResult errorCode = LNUIMessageTextArea_SetTypingSpeed(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIMessageTextArea::setTypingSpeed - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIMessageTextArea_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UI

struct Wrap_UI
{

    Wrap_UI()
    {}
};


static VALUE Wrap_LNUI_Add(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE element;
        rb_scan_args(argc, argv, "1", &element);
        if (LNRB_VALUE_IS_OBJECT(element))
        {
            LNHandle _element = LuminoRubyRuntimeManager::instance->getHandle(element);
            LNResult errorCode = LNUI_Add(_element);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UI::add - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUI_Remove(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE element;
        rb_scan_args(argc, argv, "1", &element);
        if (LNRB_VALUE_IS_OBJECT(element))
        {
            LNHandle _element = LuminoRubyRuntimeManager::instance->getHandle(element);
            LNResult errorCode = LNUI_Remove(_element);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UI::remove - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::UILayoutPanel

struct Wrap_UILayoutPanel
    : public Wrap_UIElement
{

    Wrap_UILayoutPanel()
    {}
};

static void LNUILayoutPanel_delete(Wrap_UILayoutPanel* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUILayoutPanel_mark(Wrap_UILayoutPanel* obj)
{
	

}

static VALUE LNUILayoutPanel_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UILayoutPanel* internalObj;

    internalObj = new Wrap_UILayoutPanel();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUILayoutPanel_allocate");
    obj = Data_Wrap_Struct(klass, LNUILayoutPanel_mark, LNUILayoutPanel_delete, internalObj);

    return obj;
}

static VALUE LNUILayoutPanel_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UILayoutPanel* internalObj;

    internalObj = new Wrap_UILayoutPanel();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUILayoutPanel_allocate");
    obj = Data_Wrap_Struct(klass, LNUILayoutPanel_mark, LNUILayoutPanel_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNUILayoutPanel_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIBoxLayout

struct Wrap_UIBoxLayout
    : public Wrap_UILayoutPanel
{

    Wrap_UIBoxLayout()
    {}
};

static void LNUIBoxLayout_delete(Wrap_UIBoxLayout* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIBoxLayout_mark(Wrap_UIBoxLayout* obj)
{
	

}

static VALUE LNUIBoxLayout_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIBoxLayout* internalObj;

    internalObj = new Wrap_UIBoxLayout();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIBoxLayout_allocate");
    obj = Data_Wrap_Struct(klass, LNUIBoxLayout_mark, LNUIBoxLayout_delete, internalObj);

    return obj;
}

static VALUE LNUIBoxLayout_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIBoxLayout* internalObj;

    internalObj = new Wrap_UIBoxLayout();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIBoxLayout_allocate");
    obj = Data_Wrap_Struct(klass, LNUIBoxLayout_mark, LNUIBoxLayout_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIBoxLayout_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIBoxLayout* selfObj;
    Data_Get_Struct(self, Wrap_UIBoxLayout, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNUIBoxLayout_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIBoxLayout::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIBoxLayout_SetOrientation(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIBoxLayout* selfObj;
    Data_Get_Struct(self, Wrap_UIBoxLayout, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE orientation;
        rb_scan_args(argc, argv, "1", &orientation);
        if (LNRB_VALUE_IS_NUMBER(orientation))
        {
            LNUILayoutOrientation _orientation = (LNUILayoutOrientation)FIX2INT(orientation);
            LNResult errorCode = LNUIBoxLayout_SetOrientation(selfObj->handle, _orientation);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIBoxLayout::setOrientation - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIBoxLayout_GetOrientation(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIBoxLayout* selfObj;
    Data_Get_Struct(self, Wrap_UIBoxLayout, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNUILayoutOrientation _outReturn;
            LNResult errorCode = LNUIBoxLayout_GetOrientation(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return INT2FIX(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIBoxLayout::orientation - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIBoxLayout_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIStackLayout

struct Wrap_UIStackLayout
    : public Wrap_UILayoutPanel
{

    Wrap_UIStackLayout()
    {}
};

static void LNUIStackLayout_delete(Wrap_UIStackLayout* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIStackLayout_mark(Wrap_UIStackLayout* obj)
{
	

}

static VALUE LNUIStackLayout_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIStackLayout* internalObj;

    internalObj = new Wrap_UIStackLayout();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIStackLayout_allocate");
    obj = Data_Wrap_Struct(klass, LNUIStackLayout_mark, LNUIStackLayout_delete, internalObj);

    return obj;
}

static VALUE LNUIStackLayout_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIStackLayout* internalObj;

    internalObj = new Wrap_UIStackLayout();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIStackLayout_allocate");
    obj = Data_Wrap_Struct(klass, LNUIStackLayout_mark, LNUIStackLayout_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIStackLayout_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIStackLayout* selfObj;
    Data_Get_Struct(self, Wrap_UIStackLayout, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNUIStackLayout_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIStackLayout::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIStackLayout_SetOrientation(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIStackLayout* selfObj;
    Data_Get_Struct(self, Wrap_UIStackLayout, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE orientation;
        rb_scan_args(argc, argv, "1", &orientation);
        if (LNRB_VALUE_IS_NUMBER(orientation))
        {
            LNUILayoutOrientation _orientation = (LNUILayoutOrientation)FIX2INT(orientation);
            LNResult errorCode = LNUIStackLayout_SetOrientation(selfObj->handle, _orientation);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIStackLayout::setOrientation - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIStackLayout_GetOrientation(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIStackLayout* selfObj;
    Data_Get_Struct(self, Wrap_UIStackLayout, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNUILayoutOrientation _outReturn;
            LNResult errorCode = LNUIStackLayout_GetOrientation(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return INT2FIX(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIStackLayout::getOrientation - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIStackLayout_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIGridLayout

struct Wrap_UIGridLayout
    : public Wrap_UILayoutPanel
{

    Wrap_UIGridLayout()
    {}
};

static void LNUIGridLayout_delete(Wrap_UIGridLayout* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIGridLayout_mark(Wrap_UIGridLayout* obj)
{
	

}

static VALUE LNUIGridLayout_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIGridLayout* internalObj;

    internalObj = new Wrap_UIGridLayout();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIGridLayout_allocate");
    obj = Data_Wrap_Struct(klass, LNUIGridLayout_mark, LNUIGridLayout_delete, internalObj);

    return obj;
}

static VALUE LNUIGridLayout_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIGridLayout* internalObj;

    internalObj = new Wrap_UIGridLayout();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIGridLayout_allocate");
    obj = Data_Wrap_Struct(klass, LNUIGridLayout_mark, LNUIGridLayout_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIGridLayout_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIGridLayout* selfObj;
    Data_Get_Struct(self, Wrap_UIGridLayout, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNUIGridLayout_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIGridLayout::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIGridLayout_SetColumnCount(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIGridLayout* selfObj;
    Data_Get_Struct(self, Wrap_UIGridLayout, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            int _value = LNRB_VALUE_TO_NUMBER(value);
            LNResult errorCode = LNUIGridLayout_SetColumnCount(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIGridLayout::setColumnCount - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIGridLayout_SetRow(int argc, VALUE* argv, VALUE self)
{
    if (2 <= argc && argc <= 2) {
        VALUE element;
        VALUE row;
        rb_scan_args(argc, argv, "2", &element, &row);
        if (LNRB_VALUE_IS_OBJECT(element) && LNRB_VALUE_IS_NUMBER(row))
        {
            LNHandle _element = LuminoRubyRuntimeManager::instance->getHandle(element);
            int _row = LNRB_VALUE_TO_NUMBER(row);
            LNResult errorCode = LNUIGridLayout_SetRow(_element, _row);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIGridLayout::setRow - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIGridLayout_SetColumn(int argc, VALUE* argv, VALUE self)
{
    if (2 <= argc && argc <= 2) {
        VALUE element;
        VALUE column;
        rb_scan_args(argc, argv, "2", &element, &column);
        if (LNRB_VALUE_IS_OBJECT(element) && LNRB_VALUE_IS_NUMBER(column))
        {
            LNHandle _element = LuminoRubyRuntimeManager::instance->getHandle(element);
            int _column = LNRB_VALUE_TO_NUMBER(column);
            LNResult errorCode = LNUIGridLayout_SetColumn(_element, _column);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIGridLayout::setColumn - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIGridLayout_SetPlacement(int argc, VALUE* argv, VALUE self)
{
    if (3 <= argc && argc <= 5) {
        VALUE element;
        VALUE row;
        VALUE column;
        VALUE rowSpan;
        VALUE columnSpan;
        rb_scan_args(argc, argv, "32", &element, &row, &column, &rowSpan, &columnSpan);
        if (LNRB_VALUE_IS_OBJECT(element) && LNRB_VALUE_IS_NUMBER(row) && LNRB_VALUE_IS_NUMBER(column) && LNRB_VALUE_IS_NUMBER(rowSpan) && LNRB_VALUE_IS_NUMBER(columnSpan))
        {
            LNHandle _element = LuminoRubyRuntimeManager::instance->getHandle(element);
            int _row = LNRB_VALUE_TO_NUMBER(row);
            int _column = LNRB_VALUE_TO_NUMBER(column);
            int _rowSpan = (rowSpan != Qnil) ? LNRB_VALUE_TO_NUMBER(rowSpan) : 1;
            int _columnSpan = (columnSpan != Qnil) ? LNRB_VALUE_TO_NUMBER(columnSpan) : 1;
            LNResult errorCode = LNUIGridLayout_SetPlacement(_element, _row, _column, _rowSpan, _columnSpan);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIGridLayout::setPlacement - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIGridLayout_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIControl

struct Wrap_UIControl
    : public Wrap_UIElement
{

    Wrap_UIControl()
    {}
};

static void LNUIControl_delete(Wrap_UIControl* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIControl_mark(Wrap_UIControl* obj)
{
	

}

static VALUE LNUIControl_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIControl* internalObj;

    internalObj = new Wrap_UIControl();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIControl_allocate");
    obj = Data_Wrap_Struct(klass, LNUIControl_mark, LNUIControl_delete, internalObj);

    return obj;
}

static VALUE LNUIControl_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIControl* internalObj;

    internalObj = new Wrap_UIControl();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIControl_allocate");
    obj = Data_Wrap_Struct(klass, LNUIControl_mark, LNUIControl_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIControl_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIControl* selfObj;
    Data_Get_Struct(self, Wrap_UIControl, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNUIControl_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIControl::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIControl_AddInlineVisual(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIControl* selfObj;
    Data_Get_Struct(self, Wrap_UIControl, selfObj);
    if (2 <= argc && argc <= 2) {
        VALUE element;
        VALUE layout;
        rb_scan_args(argc, argv, "2", &element, &layout);
        if (LNRB_VALUE_IS_OBJECT(element) && LNRB_VALUE_IS_NUMBER(layout))
        {
            LNHandle _element = LuminoRubyRuntimeManager::instance->getHandle(element);
            LNUIInlinePlacement _layout = (LNUIInlinePlacement)FIX2INT(layout);
            LNResult errorCode = LNUIControl_AddInlineVisual(selfObj->handle, _element, _layout);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIControl::addInlineVisual - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIControl_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIButtonBase

struct Wrap_UIButtonBase
    : public Wrap_UIControl
{

    Wrap_UIButtonBase()
    {}
};

static void LNUIButtonBase_delete(Wrap_UIButtonBase* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIButtonBase_mark(Wrap_UIButtonBase* obj)
{
	

}

static VALUE LNUIButtonBase_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIButtonBase* internalObj;

    internalObj = new Wrap_UIButtonBase();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIButtonBase_allocate");
    obj = Data_Wrap_Struct(klass, LNUIButtonBase_mark, LNUIButtonBase_delete, internalObj);

    return obj;
}

static VALUE LNUIButtonBase_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIButtonBase* internalObj;

    internalObj = new Wrap_UIButtonBase();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIButtonBase_allocate");
    obj = Data_Wrap_Struct(klass, LNUIButtonBase_mark, LNUIButtonBase_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIButtonBase_SetText(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIButtonBase* selfObj;
    Data_Get_Struct(self, Wrap_UIButtonBase, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE text;
        rb_scan_args(argc, argv, "1", &text);
        if (LNRB_VALUE_IS_STRING(text))
        {
            const char* _text = LNRB_VALUE_TO_STRING(text);
            LNResult errorCode = LNUIButtonBase_SetTextA(selfObj->handle, _text);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIButtonBase::setText - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIButtonBase_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIButton

struct Wrap_UIButton
    : public Wrap_UIButtonBase
{

    Wrap_UIButton()
    {}
};

static void LNUIButton_delete(Wrap_UIButton* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIButton_mark(Wrap_UIButton* obj)
{
	

}

static VALUE LNUIButton_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIButton* internalObj;

    internalObj = new Wrap_UIButton();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIButton_allocate");
    obj = Data_Wrap_Struct(klass, LNUIButton_mark, LNUIButton_delete, internalObj);

    return obj;
}

static VALUE LNUIButton_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIButton* internalObj;

    internalObj = new Wrap_UIButton();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIButton_allocate");
    obj = Data_Wrap_Struct(klass, LNUIButton_mark, LNUIButton_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIButton_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIButton* selfObj;
    Data_Get_Struct(self, Wrap_UIButton, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNUIButton_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    if (1 <= argc && argc <= 1) {
        VALUE text;
        rb_scan_args(argc, argv, "1", &text);
        if (LNRB_VALUE_IS_STRING(text))
        {
            const char* _text = LNRB_VALUE_TO_STRING(text);
            LNResult errorCode = LNUIButton_CreateWithTextA(_text, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIButton::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIButton_ConnectOnClicked(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIButton* selfObj;
    Data_Get_Struct(self, Wrap_UIButton, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE handler;
        rb_scan_args(argc, argv, "1", &handler);
        if (LNRB_VALUE_IS_OBJECT(handler))
        {
            LNHandle _handler = LuminoRubyRuntimeManager::instance->getHandle(handler);
            LNHandle _outReturn;
            LNResult errorCode = LNUIButton_ConnectOnClicked(selfObj->handle, _handler, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_UIEventHandler, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNHandle _outReturn;
            LNResult result = LNUIButton_ConnectOnClicked(selfObj->handle, _value, &_outReturn);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIButton::connectOnClicked - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIButton_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIWindow

struct Wrap_UIWindow
    : public Wrap_UIControl
{

    Wrap_UIWindow()
    {}
};

static void LNUIWindow_delete(Wrap_UIWindow* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIWindow_mark(Wrap_UIWindow* obj)
{
	

}

static VALUE LNUIWindow_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIWindow* internalObj;

    internalObj = new Wrap_UIWindow();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIWindow_allocate");
    obj = Data_Wrap_Struct(klass, LNUIWindow_mark, LNUIWindow_delete, internalObj);

    return obj;
}

static VALUE LNUIWindow_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIWindow* internalObj;

    internalObj = new Wrap_UIWindow();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIWindow_allocate");
    obj = Data_Wrap_Struct(klass, LNUIWindow_mark, LNUIWindow_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIWindow_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIWindow* selfObj;
    Data_Get_Struct(self, Wrap_UIWindow, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNUIWindow_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIWindow::init - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIWindow_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIListItem

struct Wrap_UIListItem
    : public Wrap_UIControl
{

    Wrap_UIListItem()
    {}
};

static void LNUIListItem_delete(Wrap_UIListItem* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIListItem_mark(Wrap_UIListItem* obj)
{
	

}

static VALUE LNUIListItem_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIListItem* internalObj;

    internalObj = new Wrap_UIListItem();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListItem_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListItem_mark, LNUIListItem_delete, internalObj);

    return obj;
}

static VALUE LNUIListItem_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIListItem* internalObj;

    internalObj = new Wrap_UIListItem();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListItem_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListItem_mark, LNUIListItem_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIListItem_ConnectOnSubmit(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIListItem* selfObj;
    Data_Get_Struct(self, Wrap_UIListItem, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE handler;
        rb_scan_args(argc, argv, "1", &handler);
        if (LNRB_VALUE_IS_OBJECT(handler))
        {
            LNHandle _handler = LuminoRubyRuntimeManager::instance->getHandle(handler);
            LNHandle _outReturn;
            LNResult errorCode = LNUIListItem_ConnectOnSubmit(selfObj->handle, _handler, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    if (argc == 0) {
        VALUE block;
        rb_scan_args(argc, argv, "0&", &block);
        if (block != Qnil) {
            VALUE value = rb_funcall(g_class_UIGeneralEventHandler, rb_intern("new"), 1, block);
            LNHandle _value = LuminoRubyRuntimeManager::instance->getHandle(value);
            LNHandle _outReturn;
            LNResult result = LNUIListItem_ConnectOnSubmit(selfObj->handle, _value, &_outReturn);
            if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE_NO_RETAIN(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIListItem::connectOnSubmit - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIListItem_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIListItemsControl

struct Wrap_UIListItemsControl
    : public Wrap_UIControl
{

    Wrap_UIListItemsControl()
    {}
};

static void LNUIListItemsControl_delete(Wrap_UIListItemsControl* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIListItemsControl_mark(Wrap_UIListItemsControl* obj)
{
	

}

static VALUE LNUIListItemsControl_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIListItemsControl* internalObj;

    internalObj = new Wrap_UIListItemsControl();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListItemsControl_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListItemsControl_mark, LNUIListItemsControl_delete, internalObj);

    return obj;
}

static VALUE LNUIListItemsControl_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIListItemsControl* internalObj;

    internalObj = new Wrap_UIListItemsControl();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListItemsControl_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListItemsControl_mark, LNUIListItemsControl_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIListItemsControl_SetItemsLayoutPanel(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIListItemsControl* selfObj;
    Data_Get_Struct(self, Wrap_UIListItemsControl, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE layout;
        rb_scan_args(argc, argv, "1", &layout);
        if (LNRB_VALUE_IS_OBJECT(layout))
        {
            LNHandle _layout = LuminoRubyRuntimeManager::instance->getHandle(layout);
            LNResult errorCode = LNUIListItemsControl_SetItemsLayoutPanel(selfObj->handle, _layout);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIListItemsControl::setItemsLayoutPanel - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIListItemsControl_SetSubmitMode(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIListItemsControl* selfObj;
    Data_Get_Struct(self, Wrap_UIListItemsControl, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            LNUIListSubmitMode _value = (LNUIListSubmitMode)FIX2INT(value);
            LNResult errorCode = LNUIListItemsControl_SetSubmitMode(selfObj->handle, _value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIListItemsControl::setSubmitMode - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIListItemsControl_GetSubmitMode(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIListItemsControl* selfObj;
    Data_Get_Struct(self, Wrap_UIListItemsControl, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNUIListSubmitMode _outReturn;
            LNResult errorCode = LNUIListItemsControl_GetSubmitMode(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return INT2FIX(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIListItemsControl::submitMode - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIListItemsControl_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIListBoxItem

struct Wrap_UIListBoxItem
    : public Wrap_UIListItem
{

    Wrap_UIListBoxItem()
    {}
};

static void LNUIListBoxItem_delete(Wrap_UIListBoxItem* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIListBoxItem_mark(Wrap_UIListBoxItem* obj)
{
	

}

static VALUE LNUIListBoxItem_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIListBoxItem* internalObj;

    internalObj = new Wrap_UIListBoxItem();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListBoxItem_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListBoxItem_mark, LNUIListBoxItem_delete, internalObj);

    return obj;
}

static VALUE LNUIListBoxItem_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIListBoxItem* internalObj;

    internalObj = new Wrap_UIListBoxItem();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListBoxItem_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListBoxItem_mark, LNUIListBoxItem_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIListBoxItem_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIListBoxItem* selfObj;
    Data_Get_Struct(self, Wrap_UIListBoxItem, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE content;
        rb_scan_args(argc, argv, "1", &content);
        if (LNRB_VALUE_IS_OBJECT(content))
        {
            LNHandle _content = LuminoRubyRuntimeManager::instance->getHandle(content);
            LNResult errorCode = LNUIListBoxItem_Create(_content, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIListBoxItem::init - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIListBoxItem_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::UIListBox

struct Wrap_UIListBox
    : public Wrap_UIListItemsControl
{

    Wrap_UIListBox()
    {}
};

static void LNUIListBox_delete(Wrap_UIListBox* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIListBox_mark(Wrap_UIListBox* obj)
{
	

}

static VALUE LNUIListBox_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIListBox* internalObj;

    internalObj = new Wrap_UIListBox();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListBox_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListBox_mark, LNUIListBox_delete, internalObj);

    return obj;
}

static VALUE LNUIListBox_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIListBox* internalObj;

    internalObj = new Wrap_UIListBox();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListBox_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListBox_mark, LNUIListBox_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNUIListBox_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIListBox* selfObj;
    Data_Get_Struct(self, Wrap_UIListBox, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNUIListBox_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::UIListBox::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNUIListBox_AddItem(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIListBox* selfObj;
    Data_Get_Struct(self, Wrap_UIListBox, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE content;
        rb_scan_args(argc, argv, "1", &content);
        if (LNRB_VALUE_IS_OBJECT(content))
        {
            LNHandle _content = LuminoRubyRuntimeManager::instance->getHandle(content);
            LNHandle _outReturn;
            LNResult errorCode = LNUIListBox_AddItem(selfObj->handle, _content, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::UIListBox::addItem - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNUIListBox_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::InputGesture

struct Wrap_InputGesture
    : public Wrap_Object
{

    Wrap_InputGesture()
    {}
};

static void LNInputGesture_delete(Wrap_InputGesture* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNInputGesture_mark(Wrap_InputGesture* obj)
{
	

}

static VALUE LNInputGesture_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_InputGesture* internalObj;

    internalObj = new Wrap_InputGesture();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInputGesture_allocate");
    obj = Data_Wrap_Struct(klass, LNInputGesture_mark, LNInputGesture_delete, internalObj);

    return obj;
}

static VALUE LNInputGesture_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_InputGesture* internalObj;

    internalObj = new Wrap_InputGesture();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInputGesture_allocate");
    obj = Data_Wrap_Struct(klass, LNInputGesture_mark, LNInputGesture_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


LNResult Wrap_LNInputGesture_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::KeyGesture

struct Wrap_KeyGesture
    : public Wrap_InputGesture
{

    Wrap_KeyGesture()
    {}
};

static void LNKeyGesture_delete(Wrap_KeyGesture* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNKeyGesture_mark(Wrap_KeyGesture* obj)
{
	

}

static VALUE LNKeyGesture_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_KeyGesture* internalObj;

    internalObj = new Wrap_KeyGesture();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNKeyGesture_allocate");
    obj = Data_Wrap_Struct(klass, LNKeyGesture_mark, LNKeyGesture_delete, internalObj);

    return obj;
}

static VALUE LNKeyGesture_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_KeyGesture* internalObj;

    internalObj = new Wrap_KeyGesture();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNKeyGesture_allocate");
    obj = Data_Wrap_Struct(klass, LNKeyGesture_mark, LNKeyGesture_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNKeyGesture_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_KeyGesture* selfObj;
    Data_Get_Struct(self, Wrap_KeyGesture, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE key;
        rb_scan_args(argc, argv, "1", &key);
        if (LNRB_VALUE_IS_NUMBER(key))
        {
            LNKeys _key = (LNKeys)FIX2INT(key);
            LNResult errorCode = LNKeyGesture_Create(_key, &selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::KeyGesture::init - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNKeyGesture_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::Input

struct Wrap_Input
{

    Wrap_Input()
    {}
};


static VALUE Wrap_LNInput_IsPressed(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE buttonName;
        rb_scan_args(argc, argv, "1", &buttonName);
        if (LNRB_VALUE_IS_STRING(buttonName))
        {
            const char* _buttonName = LNRB_VALUE_TO_STRING(buttonName);
            LNBool _outReturn;
            LNResult errorCode = LNInput_IsPressedA(_buttonName, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Input::isPressed - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInput_IsTriggered(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE buttonName;
        rb_scan_args(argc, argv, "1", &buttonName);
        if (LNRB_VALUE_IS_STRING(buttonName))
        {
            const char* _buttonName = LNRB_VALUE_TO_STRING(buttonName);
            LNBool _outReturn;
            LNResult errorCode = LNInput_IsTriggeredA(_buttonName, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Input::isTriggered - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInput_IsTriggeredOff(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE buttonName;
        rb_scan_args(argc, argv, "1", &buttonName);
        if (LNRB_VALUE_IS_STRING(buttonName))
        {
            const char* _buttonName = LNRB_VALUE_TO_STRING(buttonName);
            LNBool _outReturn;
            LNResult errorCode = LNInput_IsTriggeredOffA(_buttonName, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Input::isTriggeredOff - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInput_IsRepeated(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE buttonName;
        rb_scan_args(argc, argv, "1", &buttonName);
        if (LNRB_VALUE_IS_STRING(buttonName))
        {
            const char* _buttonName = LNRB_VALUE_TO_STRING(buttonName);
            LNBool _outReturn;
            LNResult errorCode = LNInput_IsRepeatedA(_buttonName, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Input::isRepeated - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInput_GetAxisValue(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE buttonName;
        rb_scan_args(argc, argv, "1", &buttonName);
        if (LNRB_VALUE_IS_STRING(buttonName))
        {
            const char* _buttonName = LNRB_VALUE_TO_STRING(buttonName);
            float _outReturn;
            LNResult errorCode = LNInput_GetAxisValueA(_buttonName, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Input::getAxisValue - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInput_AddBinding(int argc, VALUE* argv, VALUE self)
{
    if (2 <= argc && argc <= 2) {
        VALUE buttonName;
        VALUE gesture;
        rb_scan_args(argc, argv, "2", &buttonName, &gesture);
        if (LNRB_VALUE_IS_STRING(buttonName) && LNRB_VALUE_IS_OBJECT(gesture))
        {
            const char* _buttonName = LNRB_VALUE_TO_STRING(buttonName);
            LNHandle _gesture = LuminoRubyRuntimeManager::instance->getHandle(gesture);
            LNResult errorCode = LNInput_AddBindingA(_buttonName, _gesture);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Input::addBinding - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInput_RemoveBinding(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE gesture;
        rb_scan_args(argc, argv, "1", &gesture);
        if (LNRB_VALUE_IS_OBJECT(gesture))
        {
            LNHandle _gesture = LuminoRubyRuntimeManager::instance->getHandle(gesture);
            LNResult errorCode = LNInput_RemoveBinding(_gesture);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Input::removeBinding - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInput_ClearBindings(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE buttonName;
        rb_scan_args(argc, argv, "1", &buttonName);
        if (LNRB_VALUE_IS_STRING(buttonName))
        {
            const char* _buttonName = LNRB_VALUE_TO_STRING(buttonName);
            LNResult errorCode = LNInput_ClearBindingsA(_buttonName);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Input::clearBindings - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInput_ClearAllBindings(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNInput_ClearAllBindings();
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Input::clearAllBindings - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::Mouse

struct Wrap_Mouse
{

    Wrap_Mouse()
    {}
};


static VALUE Wrap_LNMouse_Pressed(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE button;
        rb_scan_args(argc, argv, "1", &button);
        if (LNRB_VALUE_IS_NUMBER(button))
        {
            LNMouseButtons _button = (LNMouseButtons)FIX2INT(button);
            LNBool _outReturn;
            LNResult errorCode = LNMouse_Pressed(_button, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Mouse::pressed - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMouse_Triggered(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE button;
        rb_scan_args(argc, argv, "1", &button);
        if (LNRB_VALUE_IS_NUMBER(button))
        {
            LNMouseButtons _button = (LNMouseButtons)FIX2INT(button);
            LNBool _outReturn;
            LNResult errorCode = LNMouse_Triggered(_button, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Mouse::triggered - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMouse_TriggeredOff(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE button;
        rb_scan_args(argc, argv, "1", &button);
        if (LNRB_VALUE_IS_NUMBER(button))
        {
            LNMouseButtons _button = (LNMouseButtons)FIX2INT(button);
            LNBool _outReturn;
            LNResult errorCode = LNMouse_TriggeredOff(_button, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Mouse::triggeredOff - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMouse_Repeated(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE button;
        rb_scan_args(argc, argv, "1", &button);
        if (LNRB_VALUE_IS_NUMBER(button))
        {
            LNMouseButtons _button = (LNMouseButtons)FIX2INT(button);
            LNBool _outReturn;
            LNResult errorCode = LNMouse_Repeated(_button, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Mouse::repeated - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNMouse_Position(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNPoint _outReturn;
            LNResult errorCode = LNMouse_Position(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            VALUE retObj = LNPoint_allocate(g_class_Point);
            *((LNPoint*)DATA_PTR(retObj)) = _outReturn;
            return retObj;
        }
    }
    rb_raise(rb_eArgError, "ln::Mouse::position - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::InterpreterCommand

struct Wrap_InterpreterCommand
    : public Wrap_Object
{

    Wrap_InterpreterCommand()
    {}
};

static void LNInterpreterCommand_delete(Wrap_InterpreterCommand* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNInterpreterCommand_mark(Wrap_InterpreterCommand* obj)
{
	

}

static VALUE LNInterpreterCommand_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_InterpreterCommand* internalObj;

    internalObj = new Wrap_InterpreterCommand();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterCommand_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterCommand_mark, LNInterpreterCommand_delete, internalObj);

    return obj;
}

static VALUE LNInterpreterCommand_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_InterpreterCommand* internalObj;

    internalObj = new Wrap_InterpreterCommand();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterCommand_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterCommand_mark, LNInterpreterCommand_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNInterpreterCommand_Code(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterCommand* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterCommand, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            const char* _outReturn;
            LNResult errorCode = LNInterpreterCommand_CodeA(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::InterpreterCommand::code - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreterCommand_ParamsCount(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterCommand* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterCommand, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            int _outReturn;
            LNResult errorCode = LNInterpreterCommand_ParamsCount(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::InterpreterCommand::paramsCount - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreterCommand_Param(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterCommand* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterCommand, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE index;
        rb_scan_args(argc, argv, "1", &index);
        if (LNRB_VALUE_IS_NUMBER(index))
        {
            int _index = LNRB_VALUE_TO_NUMBER(index);
            const char* _outReturn;
            LNResult errorCode = LNInterpreterCommand_ParamA(selfObj->handle, _index, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::InterpreterCommand::param - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNInterpreterCommand_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::InterpreterCommandList

struct Wrap_InterpreterCommandList
    : public Wrap_Object
{

    Wrap_InterpreterCommandList()
    {}
};

static void LNInterpreterCommandList_delete(Wrap_InterpreterCommandList* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNInterpreterCommandList_mark(Wrap_InterpreterCommandList* obj)
{
	

}

static VALUE LNInterpreterCommandList_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_InterpreterCommandList* internalObj;

    internalObj = new Wrap_InterpreterCommandList();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterCommandList_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterCommandList_mark, LNInterpreterCommandList_delete, internalObj);

    return obj;
}

static VALUE LNInterpreterCommandList_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_InterpreterCommandList* internalObj;

    internalObj = new Wrap_InterpreterCommandList();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterCommandList_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterCommandList_mark, LNInterpreterCommandList_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNInterpreterCommandList_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterCommandList* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterCommandList, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNInterpreterCommandList_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::InterpreterCommandList::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreterCommandList_AddCommand(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterCommandList* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterCommandList, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE code;
        rb_scan_args(argc, argv, "1", &code);
        if (LNRB_VALUE_IS_STRING(code))
        {
            const char* _code = LNRB_VALUE_TO_STRING(code);
            LNResult errorCode = LNInterpreterCommandList_AddCommandA(selfObj->handle, _code);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::InterpreterCommandList::addCommand - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreterCommandList_AddCommand1(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterCommandList* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterCommandList, selfObj);
    if (2 <= argc && argc <= 2) {
        VALUE code;
        VALUE param0;
        rb_scan_args(argc, argv, "2", &code, &param0);
        if (LNRB_VALUE_IS_STRING(code) && LNRB_VALUE_IS_STRING(param0))
        {
            const char* _code = LNRB_VALUE_TO_STRING(code);
            const char* _param0 = LNRB_VALUE_TO_STRING(param0);
            LNResult errorCode = LNInterpreterCommandList_AddCommand1A(selfObj->handle, _code, _param0);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::InterpreterCommandList::addCommand1 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreterCommandList_AddCommand2(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterCommandList* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterCommandList, selfObj);
    if (3 <= argc && argc <= 3) {
        VALUE code;
        VALUE param0;
        VALUE param1;
        rb_scan_args(argc, argv, "3", &code, &param0, &param1);
        if (LNRB_VALUE_IS_STRING(code) && LNRB_VALUE_IS_STRING(param0) && LNRB_VALUE_IS_STRING(param1))
        {
            const char* _code = LNRB_VALUE_TO_STRING(code);
            const char* _param0 = LNRB_VALUE_TO_STRING(param0);
            const char* _param1 = LNRB_VALUE_TO_STRING(param1);
            LNResult errorCode = LNInterpreterCommandList_AddCommand2A(selfObj->handle, _code, _param0, _param1);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::InterpreterCommandList::addCommand2 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreterCommandList_AddCommand3(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterCommandList* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterCommandList, selfObj);
    if (4 <= argc && argc <= 4) {
        VALUE code;
        VALUE param0;
        VALUE param1;
        VALUE param2;
        rb_scan_args(argc, argv, "4", &code, &param0, &param1, &param2);
        if (LNRB_VALUE_IS_STRING(code) && LNRB_VALUE_IS_STRING(param0) && LNRB_VALUE_IS_STRING(param1) && LNRB_VALUE_IS_STRING(param2))
        {
            const char* _code = LNRB_VALUE_TO_STRING(code);
            const char* _param0 = LNRB_VALUE_TO_STRING(param0);
            const char* _param1 = LNRB_VALUE_TO_STRING(param1);
            const char* _param2 = LNRB_VALUE_TO_STRING(param2);
            LNResult errorCode = LNInterpreterCommandList_AddCommand3A(selfObj->handle, _code, _param0, _param1, _param2);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::InterpreterCommandList::addCommand3 - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreterCommandList_AddCommand4(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterCommandList* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterCommandList, selfObj);
    if (5 <= argc && argc <= 5) {
        VALUE code;
        VALUE param0;
        VALUE param1;
        VALUE param2;
        VALUE param3;
        rb_scan_args(argc, argv, "5", &code, &param0, &param1, &param2, &param3);
        if (LNRB_VALUE_IS_STRING(code) && LNRB_VALUE_IS_STRING(param0) && LNRB_VALUE_IS_STRING(param1) && LNRB_VALUE_IS_STRING(param2) && LNRB_VALUE_IS_STRING(param3))
        {
            const char* _code = LNRB_VALUE_TO_STRING(code);
            const char* _param0 = LNRB_VALUE_TO_STRING(param0);
            const char* _param1 = LNRB_VALUE_TO_STRING(param1);
            const char* _param2 = LNRB_VALUE_TO_STRING(param2);
            const char* _param3 = LNRB_VALUE_TO_STRING(param3);
            LNResult errorCode = LNInterpreterCommandList_AddCommand4A(selfObj->handle, _code, _param0, _param1, _param2, _param3);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::InterpreterCommandList::addCommand4 - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNInterpreterCommandList_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}

//==============================================================================
// ln::InterpreterCommandDelegate

struct Wrap_InterpreterCommandDelegate
    : public Wrap_Object
{

    VALUE m_proc = Qnil;
    Wrap_InterpreterCommandDelegate()
    {}
};

static void LNInterpreterCommandDelegate_delete(Wrap_InterpreterCommandDelegate* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNInterpreterCommandDelegate_mark(Wrap_InterpreterCommandDelegate* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNInterpreterCommandDelegate_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_InterpreterCommandDelegate* internalObj;

    internalObj = new Wrap_InterpreterCommandDelegate();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterCommandDelegate_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterCommandDelegate_mark, LNInterpreterCommandDelegate_delete, internalObj);

    return obj;
}

static VALUE LNInterpreterCommandDelegate_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_InterpreterCommandDelegate* internalObj;

    internalObj = new Wrap_InterpreterCommandDelegate();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterCommandDelegate_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterCommandDelegate_mark, LNInterpreterCommandDelegate_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNInterpreterCommandDelegate_InterpreterCommandDelegate_ProcCaller(LNHandle interpretercommanddelegate, LNHandle p1, LNBool* outReturn)
{
    Wrap_InterpreterCommandDelegate* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(interpretercommanddelegate), Wrap_InterpreterCommandDelegate, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(p1));
    *outReturn = LNRB_VALUE_TO_BOOL(retval);
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNInterpreterCommandDelegate_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterCommandDelegate* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterCommandDelegate, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNInterpreterCommandDelegate_Create(Wrap_LNInterpreterCommandDelegate_InterpreterCommandDelegate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ln::InterpreterCommandDelegate::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::Interpreter

struct Wrap_Interpreter
    : public Wrap_Object
{

    Wrap_Interpreter()
    {}
};

static void LNInterpreter_delete(Wrap_Interpreter* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNInterpreter_mark(Wrap_Interpreter* obj)
{
	

}

static VALUE LNInterpreter_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Interpreter* internalObj;

    internalObj = new Wrap_Interpreter();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreter_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreter_mark, LNInterpreter_delete, internalObj);

    return obj;
}

static VALUE LNInterpreter_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Interpreter* internalObj;

    internalObj = new Wrap_Interpreter();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreter_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreter_mark, LNInterpreter_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNInterpreter_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_Interpreter* selfObj;
    Data_Get_Struct(self, Wrap_Interpreter, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNInterpreter_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Interpreter::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreter_Clear(int argc, VALUE* argv, VALUE self)
{
    Wrap_Interpreter* selfObj;
    Data_Get_Struct(self, Wrap_Interpreter, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNInterpreter_Clear(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Interpreter::clear - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreter_Run(int argc, VALUE* argv, VALUE self)
{
    Wrap_Interpreter* selfObj;
    Data_Get_Struct(self, Wrap_Interpreter, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE commandList;
        rb_scan_args(argc, argv, "1", &commandList);
        if (LNRB_VALUE_IS_OBJECT(commandList))
        {
            LNHandle _commandList = LuminoRubyRuntimeManager::instance->getHandle(commandList);
            LNResult errorCode = LNInterpreter_Run(selfObj->handle, _commandList);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Interpreter::run - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreter_IsRunning(int argc, VALUE* argv, VALUE self)
{
    Wrap_Interpreter* selfObj;
    Data_Get_Struct(self, Wrap_Interpreter, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNInterpreter_IsRunning(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Interpreter::isRunning - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreter_Update(int argc, VALUE* argv, VALUE self)
{
    Wrap_Interpreter* selfObj;
    Data_Get_Struct(self, Wrap_Interpreter, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNInterpreter_Update(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Interpreter::update - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreter_Terminate(int argc, VALUE* argv, VALUE self)
{
    Wrap_Interpreter* selfObj;
    Data_Get_Struct(self, Wrap_Interpreter, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNInterpreter_Terminate(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Interpreter::terminate - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreter_RegisterCommandHandler(int argc, VALUE* argv, VALUE self)
{
    Wrap_Interpreter* selfObj;
    Data_Get_Struct(self, Wrap_Interpreter, selfObj);
    if (2 <= argc && argc <= 2) {
        VALUE name;
        VALUE handler;
        rb_scan_args(argc, argv, "2", &name, &handler);
        if (LNRB_VALUE_IS_STRING(name) && LNRB_VALUE_IS_OBJECT(handler))
        {
            const char* _name = LNRB_VALUE_TO_STRING(name);
            LNHandle _handler = LuminoRubyRuntimeManager::instance->getHandle(handler);
            LNResult errorCode = LNInterpreter_RegisterCommandHandlerA(selfObj->handle, _name, _handler);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Interpreter::registerCommandHandler - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreter_SetWaitMode(int argc, VALUE* argv, VALUE self)
{
    Wrap_Interpreter* selfObj;
    Data_Get_Struct(self, Wrap_Interpreter, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE mode;
        rb_scan_args(argc, argv, "1", &mode);
        if (LNRB_VALUE_IS_STRING(mode))
        {
            const char* _mode = LNRB_VALUE_TO_STRING(mode);
            LNResult errorCode = LNInterpreter_SetWaitModeA(selfObj->handle, _mode);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Interpreter::setWaitMode - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreter_GetWaitMode(int argc, VALUE* argv, VALUE self)
{
    Wrap_Interpreter* selfObj;
    Data_Get_Struct(self, Wrap_Interpreter, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            const char* _outReturn;
            LNResult errorCode = LNInterpreter_GetWaitModeA(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Interpreter::waitMode - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreter_SetWaitCount(int argc, VALUE* argv, VALUE self)
{
    Wrap_Interpreter* selfObj;
    Data_Get_Struct(self, Wrap_Interpreter, selfObj);
    if (1 <= argc && argc <= 1) {
        VALUE count;
        rb_scan_args(argc, argv, "1", &count);
        if (LNRB_VALUE_IS_NUMBER(count))
        {
            int _count = LNRB_VALUE_TO_NUMBER(count);
            LNResult errorCode = LNInterpreter_SetWaitCount(selfObj->handle, _count);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Interpreter::setWaitCount - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreter_GetWaitCount(int argc, VALUE* argv, VALUE self)
{
    Wrap_Interpreter* selfObj;
    Data_Get_Struct(self, Wrap_Interpreter, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            int _outReturn;
            LNResult errorCode = LNInterpreter_GetWaitCount(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Interpreter::waitCount - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNInterpreter_OnUpdateWait(int argc, VALUE* argv, VALUE self)
{
    Wrap_Interpreter* selfObj;
    Data_Get_Struct(self, Wrap_Interpreter, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNInterpreter_OnUpdateWait_CallOverrideBase(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Interpreter::onUpdateWait - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNInterpreter_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNInterpreter_OnUpdateWait_OverrideCallback(LNHandle interpreter, LNBool* outReturn)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(interpreter);
    VALUE retval = rb_funcall(obj, rb_intern("on_update_wait"), 0, 0);
    *outReturn = LNRB_VALUE_TO_BOOL(retval);
    return LN_OK;
}

//==============================================================================
// ln::EngineSettings

struct Wrap_EngineSettings
{

    Wrap_EngineSettings()
    {}
};


static VALUE Wrap_LNEngineSettings_SetMainWindowSize(int argc, VALUE* argv, VALUE self)
{
    if (2 <= argc && argc <= 2) {
        VALUE width;
        VALUE height;
        rb_scan_args(argc, argv, "2", &width, &height);
        if (LNRB_VALUE_IS_NUMBER(width) && LNRB_VALUE_IS_NUMBER(height))
        {
            int _width = LNRB_VALUE_TO_NUMBER(width);
            int _height = LNRB_VALUE_TO_NUMBER(height);
            LNResult errorCode = LNEngineSettings_SetMainWindowSize(_width, _height);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::setMainWindowSize - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngineSettings_SetMainWorldViewSize(int argc, VALUE* argv, VALUE self)
{
    if (2 <= argc && argc <= 2) {
        VALUE width;
        VALUE height;
        rb_scan_args(argc, argv, "2", &width, &height);
        if (LNRB_VALUE_IS_NUMBER(width) && LNRB_VALUE_IS_NUMBER(height))
        {
            int _width = LNRB_VALUE_TO_NUMBER(width);
            int _height = LNRB_VALUE_TO_NUMBER(height);
            LNResult errorCode = LNEngineSettings_SetMainWorldViewSize(_width, _height);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::setMainWorldViewSize - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngineSettings_SetMainWindowTitle(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE title;
        rb_scan_args(argc, argv, "1", &title);
        if (LNRB_VALUE_IS_STRING(title))
        {
            const char* _title = LNRB_VALUE_TO_STRING(title);
            LNResult errorCode = LNEngineSettings_SetMainWindowTitleA(_title);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::setMainWindowTitle - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngineSettings_SetMainWindowResizable(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNEngineSettings_SetMainWindowResizable(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::setMainWindowResizable - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngineSettings_AddAssetDirectory(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE path;
        rb_scan_args(argc, argv, "1", &path);
        if (LNRB_VALUE_IS_STRING(path))
        {
            const char* _path = LNRB_VALUE_TO_STRING(path);
            LNResult errorCode = LNEngineSettings_AddAssetDirectoryA(_path);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::addAssetDirectory - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngineSettings_AddAssetArchive(int argc, VALUE* argv, VALUE self)
{
    if (2 <= argc && argc <= 2) {
        VALUE fileFullPath;
        VALUE password;
        rb_scan_args(argc, argv, "2", &fileFullPath, &password);
        if (LNRB_VALUE_IS_STRING(fileFullPath) && LNRB_VALUE_IS_STRING(password))
        {
            const char* _fileFullPath = LNRB_VALUE_TO_STRING(fileFullPath);
            const char* _password = LNRB_VALUE_TO_STRING(password);
            LNResult errorCode = LNEngineSettings_AddAssetArchiveA(_fileFullPath, _password);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::addAssetArchive - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngineSettings_SetFrameRate(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            int _value = LNRB_VALUE_TO_NUMBER(value);
            LNResult errorCode = LNEngineSettings_SetFrameRate(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::setFrameRate - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngineSettings_SetUITheme(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_STRING(value))
        {
            const char* _value = LNRB_VALUE_TO_STRING(value);
            LNResult errorCode = LNEngineSettings_SetUIThemeA(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::setUITheme - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngineSettings_SetFontFile(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE filePath;
        rb_scan_args(argc, argv, "1", &filePath);
        if (LNRB_VALUE_IS_STRING(filePath))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNResult errorCode = LNEngineSettings_SetFontFileA(_filePath);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::setFontFile - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngineSettings_SetDebugToolEnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE enabled;
        rb_scan_args(argc, argv, "1", &enabled);
        if (LNRB_VALUE_IS_BOOL(enabled))
        {
            LNBool _enabled = LNRB_VALUE_TO_BOOL(enabled);
            LNResult errorCode = LNEngineSettings_SetDebugToolEnabled(_enabled);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::setDebugToolEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngineSettings_SetEngineLogEnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE enabled;
        rb_scan_args(argc, argv, "1", &enabled);
        if (LNRB_VALUE_IS_BOOL(enabled))
        {
            LNBool _enabled = LNRB_VALUE_TO_BOOL(enabled);
            LNResult errorCode = LNEngineSettings_SetEngineLogEnabled(_enabled);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::setEngineLogEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngineSettings_SetEngineLogFilePath(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE filePath;
        rb_scan_args(argc, argv, "1", &filePath);
        if (LNRB_VALUE_IS_STRING(filePath))
        {
            const char* _filePath = LNRB_VALUE_TO_STRING(filePath);
            LNResult errorCode = LNEngineSettings_SetEngineLogFilePathA(_filePath);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::setEngineLogFilePath - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngineSettings_SetDeveloperToolEnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE enabled;
        rb_scan_args(argc, argv, "1", &enabled);
        if (LNRB_VALUE_IS_BOOL(enabled))
        {
            LNBool _enabled = LNRB_VALUE_TO_BOOL(enabled);
            LNResult errorCode = LNEngineSettings_SetDeveloperToolEnabled(_enabled);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::setDeveloperToolEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngineSettings_SetUserMainWindow(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_NUMBER(value))
        {
            intptr_t _value = LNRB_VALUE_TO_NUMBER(value);
            LNResult errorCode = LNEngineSettings_SetUserMainWindow(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::EngineSettings::setUserMainWindow - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::Engine

struct Wrap_Engine
{
    VALUE LNEngine_GetWorld_AccessorCache = Qnil;
    VALUE LNEngine_GetCamera_AccessorCache = Qnil;
    VALUE LNEngine_GetMainLight_AccessorCache = Qnil;
    VALUE LNEngine_GetRenderView_AccessorCache = Qnil;

    Wrap_Engine()
    {}
};


static VALUE Wrap_LNEngine_Initialize(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNEngine_Initialize();
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Engine::initialize - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngine_Terminate(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNEngine_Terminate();
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Engine::terminate - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngine_Update(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNBool _outReturn;
            LNResult errorCode = LNEngine_Update(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Engine::update - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngine_Run(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE app;
        rb_scan_args(argc, argv, "1", &app);
        if (LNRB_VALUE_IS_OBJECT(app))
        {
            LNHandle _app = LuminoRubyRuntimeManager::instance->getHandle(app);
            LNResult errorCode = LNEngine_Run(_app);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Engine::run - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngine_GetTime(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            double _outReturn;
            LNResult errorCode = LNEngine_GetTime(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNI_TO_RUBY_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Engine::time - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngine_GetWorld(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNEngine_GetWorld(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Engine::world - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngine_GetCamera(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNEngine_GetCamera(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Engine::camera - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngine_GetMainLight(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNEngine_GetMainLight(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Engine::mainLight - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNEngine_GetRenderView(int argc, VALUE* argv, VALUE self)
{
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNEngine_GetRenderView(&_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Engine::renderView - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ln::Application

struct Wrap_Application
    : public Wrap_Object
{

    Wrap_Application()
    {}
};

static void LNApplication_delete(Wrap_Application* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNApplication_mark(Wrap_Application* obj)
{
	

}

static VALUE LNApplication_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Application* internalObj;

    internalObj = new Wrap_Application();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNApplication_allocate");
    obj = Data_Wrap_Struct(klass, LNApplication_mark, LNApplication_delete, internalObj);

    return obj;
}

static VALUE LNApplication_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Application* internalObj;

    internalObj = new Wrap_Application();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNApplication_allocate");
    obj = Data_Wrap_Struct(klass, LNApplication_mark, LNApplication_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static VALUE Wrap_LNApplication_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_Application* selfObj;
    Data_Get_Struct(self, Wrap_Application, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNApplication_Create(&selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);

            if (rb_block_given_p()) rb_yield(self);
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Application::init - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNApplication_OnInit(int argc, VALUE* argv, VALUE self)
{
    Wrap_Application* selfObj;
    Data_Get_Struct(self, Wrap_Application, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNApplication_OnInit_CallOverrideBase(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Application::onInit - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNApplication_OnUpdate(int argc, VALUE* argv, VALUE self)
{
    Wrap_Application* selfObj;
    Data_Get_Struct(self, Wrap_Application, selfObj);
    if (0 <= argc && argc <= 0) {

        {

            LNResult errorCode = LNApplication_OnUpdate_CallOverrideBase(selfObj->handle);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Application::onUpdate - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNApplication_World(int argc, VALUE* argv, VALUE self)
{
    Wrap_Application* selfObj;
    Data_Get_Struct(self, Wrap_Application, selfObj);
    if (0 <= argc && argc <= 0) {

        {
            LNHandle _outReturn;
            LNResult errorCode = LNApplication_World(selfObj->handle, &_outReturn);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return LNRB_HANDLE_WRAP_TO_VALUE(_outReturn);
        }
    }
    rb_raise(rb_eArgError, "ln::Application::world - wrong argument type.");
    return Qnil;
}

LNResult Wrap_LNApplication_OnSerialize_OverrideCallback(LNHandle object, LNHandle ar)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(object);
    VALUE retval = rb_funcall(obj, rb_intern("on_serialize"), 1, LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;
}
LNResult Wrap_LNApplication_OnInit_OverrideCallback(LNHandle application)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(application);
    VALUE retval = rb_funcall(obj, rb_intern("on_init"), 0, 0);
    return LN_OK;
}
LNResult Wrap_LNApplication_OnUpdate_OverrideCallback(LNHandle application)
{
    VALUE obj = LNRB_HANDLE_WRAP_TO_VALUE(application);
    VALUE retval = rb_funcall(obj, rb_intern("on_update"), 0, 0);
    return LN_OK;
}

//==============================================================================
// ln::Debug

struct Wrap_Debug
{

    Wrap_Debug()
    {}
};


static VALUE Wrap_LNDebug_SetGuideGridEnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNDebug_SetGuideGridEnabled(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Debug::setGuideGridEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNDebug_SetPhysicsDebugDrawEnabled(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE value;
        rb_scan_args(argc, argv, "1", &value);
        if (LNRB_VALUE_IS_BOOL(value))
        {
            LNBool _value = LNRB_VALUE_TO_BOOL(value);
            LNResult errorCode = LNDebug_SetPhysicsDebugDrawEnabled(_value);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Debug::setPhysicsDebugDrawEnabled - wrong argument type.");
    return Qnil;
}

static VALUE Wrap_LNDebug_Print(int argc, VALUE* argv, VALUE self)
{
    if (1 <= argc && argc <= 1) {
        VALUE str;
        rb_scan_args(argc, argv, "1", &str);
        if (LNRB_VALUE_IS_STRING(str))
        {
            const char* _str = LNRB_VALUE_TO_STRING(str);
            LNResult errorCode = LNDebug_PrintA(_str);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (2 <= argc && argc <= 2) {
        VALUE time;
        VALUE str;
        rb_scan_args(argc, argv, "2", &time, &str);
        if (LNRB_VALUE_IS_FLOAT(time) && LNRB_VALUE_IS_STRING(str))
        {
            float _time = LNRB_VALUE_TO_FLOAT(time);
            const char* _str = LNRB_VALUE_TO_STRING(str);
            LNResult errorCode = LNDebug_PrintWithTimeA(_time, _str);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    if (3 <= argc && argc <= 3) {
        VALUE time;
        VALUE color;
        VALUE str;
        rb_scan_args(argc, argv, "3", &time, &color, &str);
        if (LNRB_VALUE_IS_FLOAT(time) && LNRB_VALUE_IS_OBJECT(color) && LNRB_VALUE_IS_STRING(str))
        {
            float _time = LNRB_VALUE_TO_FLOAT(time);
            LNColor* tmp__color; Data_Get_Struct(color, LNColor, tmp__color);LNColor& _color = *tmp__color;
            const char* _str = LNRB_VALUE_TO_STRING(str);
            LNResult errorCode = LNDebug_PrintWithTimeAndColorA(_time, &_color, _str);
            if (errorCode < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", errorCode, LNRuntime_GetLastErrorMessage());
            return Qnil;
        }
    }
    rb_raise(rb_eArgError, "ln::Debug::print - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ObjectSerializeHandler

struct Wrap_ObjectSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ObjectSerializeHandler()
    {}
};

static void LNObjectSerializeHandler_delete(Wrap_ObjectSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNObjectSerializeHandler_mark(Wrap_ObjectSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNObjectSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ObjectSerializeHandler* internalObj;

    internalObj = new Wrap_ObjectSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNObjectSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNObjectSerializeHandler_mark, LNObjectSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNObjectSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ObjectSerializeHandler* internalObj;

    internalObj = new Wrap_ObjectSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNObjectSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNObjectSerializeHandler_mark, LNObjectSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNObjectSerializeHandler_OnSerialize_ProcCaller(LNHandle objectserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_ObjectSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(objectserializehandler), Wrap_ObjectSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNObjectSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ObjectSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_ObjectSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNObjectSerializeHandler_Create(Wrap_LNObjectSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ObjectSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// EventConnectionSerializeHandler

struct Wrap_EventConnectionSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_EventConnectionSerializeHandler()
    {}
};

static void LNEventConnectionSerializeHandler_delete(Wrap_EventConnectionSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNEventConnectionSerializeHandler_mark(Wrap_EventConnectionSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNEventConnectionSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_EventConnectionSerializeHandler* internalObj;

    internalObj = new Wrap_EventConnectionSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEventConnectionSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNEventConnectionSerializeHandler_mark, LNEventConnectionSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNEventConnectionSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_EventConnectionSerializeHandler* internalObj;

    internalObj = new Wrap_EventConnectionSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEventConnectionSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNEventConnectionSerializeHandler_mark, LNEventConnectionSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNEventConnectionSerializeHandler_OnSerialize_ProcCaller(LNHandle eventconnectionserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_EventConnectionSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(eventconnectionserializehandler), Wrap_EventConnectionSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNEventConnectionSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_EventConnectionSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_EventConnectionSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNEventConnectionSerializeHandler_Create(Wrap_LNEventConnectionSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "EventConnectionSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// VariantSerializeHandler

struct Wrap_VariantSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_VariantSerializeHandler()
    {}
};

static void LNVariantSerializeHandler_delete(Wrap_VariantSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNVariantSerializeHandler_mark(Wrap_VariantSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNVariantSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_VariantSerializeHandler* internalObj;

    internalObj = new Wrap_VariantSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVariantSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNVariantSerializeHandler_mark, LNVariantSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNVariantSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_VariantSerializeHandler* internalObj;

    internalObj = new Wrap_VariantSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVariantSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNVariantSerializeHandler_mark, LNVariantSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNVariantSerializeHandler_OnSerialize_ProcCaller(LNHandle variantserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_VariantSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(variantserializehandler), Wrap_VariantSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNVariantSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_VariantSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_VariantSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNVariantSerializeHandler_Create(Wrap_LNVariantSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "VariantSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ZVTestClass1SerializeHandler

struct Wrap_ZVTestClass1SerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ZVTestClass1SerializeHandler()
    {}
};

static void LNZVTestClass1SerializeHandler_delete(Wrap_ZVTestClass1SerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNZVTestClass1SerializeHandler_mark(Wrap_ZVTestClass1SerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNZVTestClass1SerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ZVTestClass1SerializeHandler* internalObj;

    internalObj = new Wrap_ZVTestClass1SerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestClass1SerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestClass1SerializeHandler_mark, LNZVTestClass1SerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNZVTestClass1SerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ZVTestClass1SerializeHandler* internalObj;

    internalObj = new Wrap_ZVTestClass1SerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestClass1SerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestClass1SerializeHandler_mark, LNZVTestClass1SerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNZVTestClass1SerializeHandler_OnSerialize_ProcCaller(LNHandle zvtestclass1serializehandler, LNHandle self, LNHandle ar)
{
    Wrap_ZVTestClass1SerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(zvtestclass1serializehandler), Wrap_ZVTestClass1SerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNZVTestClass1SerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestClass1SerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestClass1SerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNZVTestClass1SerializeHandler_Create(Wrap_LNZVTestClass1SerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ZVTestClass1SerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ZVTestEventArgs1SerializeHandler

struct Wrap_ZVTestEventArgs1SerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ZVTestEventArgs1SerializeHandler()
    {}
};

static void LNZVTestEventArgs1SerializeHandler_delete(Wrap_ZVTestEventArgs1SerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNZVTestEventArgs1SerializeHandler_mark(Wrap_ZVTestEventArgs1SerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNZVTestEventArgs1SerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ZVTestEventArgs1SerializeHandler* internalObj;

    internalObj = new Wrap_ZVTestEventArgs1SerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestEventArgs1SerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestEventArgs1SerializeHandler_mark, LNZVTestEventArgs1SerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNZVTestEventArgs1SerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ZVTestEventArgs1SerializeHandler* internalObj;

    internalObj = new Wrap_ZVTestEventArgs1SerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNZVTestEventArgs1SerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNZVTestEventArgs1SerializeHandler_mark, LNZVTestEventArgs1SerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNZVTestEventArgs1SerializeHandler_OnSerialize_ProcCaller(LNHandle zvtesteventargs1serializehandler, LNHandle self, LNHandle ar)
{
    Wrap_ZVTestEventArgs1SerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(zvtesteventargs1serializehandler), Wrap_ZVTestEventArgs1SerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNZVTestEventArgs1SerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ZVTestEventArgs1SerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_ZVTestEventArgs1SerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNZVTestEventArgs1SerializeHandler_Create(Wrap_LNZVTestEventArgs1SerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ZVTestEventArgs1SerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// Serializer2SerializeHandler

struct Wrap_Serializer2SerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_Serializer2SerializeHandler()
    {}
};

static void LNSerializer2SerializeHandler_delete(Wrap_Serializer2SerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSerializer2SerializeHandler_mark(Wrap_Serializer2SerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNSerializer2SerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Serializer2SerializeHandler* internalObj;

    internalObj = new Wrap_Serializer2SerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSerializer2SerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSerializer2SerializeHandler_mark, LNSerializer2SerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNSerializer2SerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Serializer2SerializeHandler* internalObj;

    internalObj = new Wrap_Serializer2SerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSerializer2SerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSerializer2SerializeHandler_mark, LNSerializer2SerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNSerializer2SerializeHandler_OnSerialize_ProcCaller(LNHandle serializer2serializehandler, LNHandle self, LNHandle ar)
{
    Wrap_Serializer2SerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(serializer2serializehandler), Wrap_Serializer2SerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNSerializer2SerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_Serializer2SerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_Serializer2SerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNSerializer2SerializeHandler_Create(Wrap_LNSerializer2SerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "Serializer2SerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// AssetObjectSerializeHandler

struct Wrap_AssetObjectSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_AssetObjectSerializeHandler()
    {}
};

static void LNAssetObjectSerializeHandler_delete(Wrap_AssetObjectSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAssetObjectSerializeHandler_mark(Wrap_AssetObjectSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNAssetObjectSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AssetObjectSerializeHandler* internalObj;

    internalObj = new Wrap_AssetObjectSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAssetObjectSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAssetObjectSerializeHandler_mark, LNAssetObjectSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNAssetObjectSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AssetObjectSerializeHandler* internalObj;

    internalObj = new Wrap_AssetObjectSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAssetObjectSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAssetObjectSerializeHandler_mark, LNAssetObjectSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNAssetObjectSerializeHandler_OnSerialize_ProcCaller(LNHandle assetobjectserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_AssetObjectSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(assetobjectserializehandler), Wrap_AssetObjectSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNAssetObjectSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_AssetObjectSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_AssetObjectSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNAssetObjectSerializeHandler_Create(Wrap_LNAssetObjectSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "AssetObjectSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// AssetImportSettingsSerializeHandler

struct Wrap_AssetImportSettingsSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_AssetImportSettingsSerializeHandler()
    {}
};

static void LNAssetImportSettingsSerializeHandler_delete(Wrap_AssetImportSettingsSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAssetImportSettingsSerializeHandler_mark(Wrap_AssetImportSettingsSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNAssetImportSettingsSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AssetImportSettingsSerializeHandler* internalObj;

    internalObj = new Wrap_AssetImportSettingsSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAssetImportSettingsSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAssetImportSettingsSerializeHandler_mark, LNAssetImportSettingsSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNAssetImportSettingsSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AssetImportSettingsSerializeHandler* internalObj;

    internalObj = new Wrap_AssetImportSettingsSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAssetImportSettingsSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAssetImportSettingsSerializeHandler_mark, LNAssetImportSettingsSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNAssetImportSettingsSerializeHandler_OnSerialize_ProcCaller(LNHandle assetimportsettingsserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_AssetImportSettingsSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(assetimportsettingsserializehandler), Wrap_AssetImportSettingsSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNAssetImportSettingsSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_AssetImportSettingsSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_AssetImportSettingsSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNAssetImportSettingsSerializeHandler_Create(Wrap_LNAssetImportSettingsSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "AssetImportSettingsSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// AssetModelSerializeHandler

struct Wrap_AssetModelSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_AssetModelSerializeHandler()
    {}
};

static void LNAssetModelSerializeHandler_delete(Wrap_AssetModelSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAssetModelSerializeHandler_mark(Wrap_AssetModelSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNAssetModelSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AssetModelSerializeHandler* internalObj;

    internalObj = new Wrap_AssetModelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAssetModelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAssetModelSerializeHandler_mark, LNAssetModelSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNAssetModelSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AssetModelSerializeHandler* internalObj;

    internalObj = new Wrap_AssetModelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAssetModelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAssetModelSerializeHandler_mark, LNAssetModelSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNAssetModelSerializeHandler_OnSerialize_ProcCaller(LNHandle assetmodelserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_AssetModelSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(assetmodelserializehandler), Wrap_AssetModelSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNAssetModelSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_AssetModelSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_AssetModelSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNAssetModelSerializeHandler_Create(Wrap_LNAssetModelSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "AssetModelSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// SoundSerializeHandler

struct Wrap_SoundSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_SoundSerializeHandler()
    {}
};

static void LNSoundSerializeHandler_delete(Wrap_SoundSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSoundSerializeHandler_mark(Wrap_SoundSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNSoundSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SoundSerializeHandler* internalObj;

    internalObj = new Wrap_SoundSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSoundSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSoundSerializeHandler_mark, LNSoundSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNSoundSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SoundSerializeHandler* internalObj;

    internalObj = new Wrap_SoundSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSoundSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSoundSerializeHandler_mark, LNSoundSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNSoundSerializeHandler_OnSerialize_ProcCaller(LNHandle soundserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_SoundSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(soundserializehandler), Wrap_SoundSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNSoundSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_SoundSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_SoundSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNSoundSerializeHandler_Create(Wrap_LNSoundSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "SoundSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// TextureSerializeHandler

struct Wrap_TextureSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_TextureSerializeHandler()
    {}
};

static void LNTextureSerializeHandler_delete(Wrap_TextureSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNTextureSerializeHandler_mark(Wrap_TextureSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNTextureSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_TextureSerializeHandler* internalObj;

    internalObj = new Wrap_TextureSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTextureSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNTextureSerializeHandler_mark, LNTextureSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNTextureSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_TextureSerializeHandler* internalObj;

    internalObj = new Wrap_TextureSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTextureSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNTextureSerializeHandler_mark, LNTextureSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNTextureSerializeHandler_OnSerialize_ProcCaller(LNHandle textureserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_TextureSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(textureserializehandler), Wrap_TextureSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNTextureSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_TextureSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_TextureSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNTextureSerializeHandler_Create(Wrap_LNTextureSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "TextureSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// Texture2DSerializeHandler

struct Wrap_Texture2DSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_Texture2DSerializeHandler()
    {}
};

static void LNTexture2DSerializeHandler_delete(Wrap_Texture2DSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNTexture2DSerializeHandler_mark(Wrap_Texture2DSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNTexture2DSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_Texture2DSerializeHandler* internalObj;

    internalObj = new Wrap_Texture2DSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTexture2DSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNTexture2DSerializeHandler_mark, LNTexture2DSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNTexture2DSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_Texture2DSerializeHandler* internalObj;

    internalObj = new Wrap_Texture2DSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTexture2DSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNTexture2DSerializeHandler_mark, LNTexture2DSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNTexture2DSerializeHandler_OnSerialize_ProcCaller(LNHandle texture2dserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_Texture2DSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(texture2dserializehandler), Wrap_Texture2DSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNTexture2DSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_Texture2DSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_Texture2DSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNTexture2DSerializeHandler_Create(Wrap_LNTexture2DSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "Texture2DSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ShaderSerializeHandler

struct Wrap_ShaderSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ShaderSerializeHandler()
    {}
};

static void LNShaderSerializeHandler_delete(Wrap_ShaderSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNShaderSerializeHandler_mark(Wrap_ShaderSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNShaderSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ShaderSerializeHandler* internalObj;

    internalObj = new Wrap_ShaderSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNShaderSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNShaderSerializeHandler_mark, LNShaderSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNShaderSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ShaderSerializeHandler* internalObj;

    internalObj = new Wrap_ShaderSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNShaderSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNShaderSerializeHandler_mark, LNShaderSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNShaderSerializeHandler_OnSerialize_ProcCaller(LNHandle shaderserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_ShaderSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(shaderserializehandler), Wrap_ShaderSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNShaderSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ShaderSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_ShaderSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNShaderSerializeHandler_Create(Wrap_LNShaderSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ShaderSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// RenderViewSerializeHandler

struct Wrap_RenderViewSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_RenderViewSerializeHandler()
    {}
};

static void LNRenderViewSerializeHandler_delete(Wrap_RenderViewSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNRenderViewSerializeHandler_mark(Wrap_RenderViewSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNRenderViewSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_RenderViewSerializeHandler* internalObj;

    internalObj = new Wrap_RenderViewSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNRenderViewSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNRenderViewSerializeHandler_mark, LNRenderViewSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNRenderViewSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_RenderViewSerializeHandler* internalObj;

    internalObj = new Wrap_RenderViewSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNRenderViewSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNRenderViewSerializeHandler_mark, LNRenderViewSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNRenderViewSerializeHandler_OnSerialize_ProcCaller(LNHandle renderviewserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_RenderViewSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(renderviewserializehandler), Wrap_RenderViewSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNRenderViewSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_RenderViewSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_RenderViewSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNRenderViewSerializeHandler_Create(Wrap_LNRenderViewSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "RenderViewSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// MaterialSerializeHandler

struct Wrap_MaterialSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_MaterialSerializeHandler()
    {}
};

static void LNMaterialSerializeHandler_delete(Wrap_MaterialSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNMaterialSerializeHandler_mark(Wrap_MaterialSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNMaterialSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_MaterialSerializeHandler* internalObj;

    internalObj = new Wrap_MaterialSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMaterialSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNMaterialSerializeHandler_mark, LNMaterialSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNMaterialSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_MaterialSerializeHandler* internalObj;

    internalObj = new Wrap_MaterialSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMaterialSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNMaterialSerializeHandler_mark, LNMaterialSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNMaterialSerializeHandler_OnSerialize_ProcCaller(LNHandle materialserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_MaterialSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(materialserializehandler), Wrap_MaterialSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNMaterialSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_MaterialSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_MaterialSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNMaterialSerializeHandler_Create(Wrap_LNMaterialSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "MaterialSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// MeshNodeSerializeHandler

struct Wrap_MeshNodeSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_MeshNodeSerializeHandler()
    {}
};

static void LNMeshNodeSerializeHandler_delete(Wrap_MeshNodeSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNMeshNodeSerializeHandler_mark(Wrap_MeshNodeSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNMeshNodeSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_MeshNodeSerializeHandler* internalObj;

    internalObj = new Wrap_MeshNodeSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMeshNodeSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNMeshNodeSerializeHandler_mark, LNMeshNodeSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNMeshNodeSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_MeshNodeSerializeHandler* internalObj;

    internalObj = new Wrap_MeshNodeSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMeshNodeSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNMeshNodeSerializeHandler_mark, LNMeshNodeSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNMeshNodeSerializeHandler_OnSerialize_ProcCaller(LNHandle meshnodeserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_MeshNodeSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(meshnodeserializehandler), Wrap_MeshNodeSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNMeshNodeSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_MeshNodeSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_MeshNodeSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNMeshNodeSerializeHandler_Create(Wrap_LNMeshNodeSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "MeshNodeSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// AnimationControllerSerializeHandler

struct Wrap_AnimationControllerSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_AnimationControllerSerializeHandler()
    {}
};

static void LNAnimationControllerSerializeHandler_delete(Wrap_AnimationControllerSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAnimationControllerSerializeHandler_mark(Wrap_AnimationControllerSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNAnimationControllerSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AnimationControllerSerializeHandler* internalObj;

    internalObj = new Wrap_AnimationControllerSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationControllerSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationControllerSerializeHandler_mark, LNAnimationControllerSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNAnimationControllerSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AnimationControllerSerializeHandler* internalObj;

    internalObj = new Wrap_AnimationControllerSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationControllerSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationControllerSerializeHandler_mark, LNAnimationControllerSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNAnimationControllerSerializeHandler_OnSerialize_ProcCaller(LNHandle animationcontrollerserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_AnimationControllerSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(animationcontrollerserializehandler), Wrap_AnimationControllerSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNAnimationControllerSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_AnimationControllerSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_AnimationControllerSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNAnimationControllerSerializeHandler_Create(Wrap_LNAnimationControllerSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "AnimationControllerSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// MeshModelSerializeHandler

struct Wrap_MeshModelSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_MeshModelSerializeHandler()
    {}
};

static void LNMeshModelSerializeHandler_delete(Wrap_MeshModelSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNMeshModelSerializeHandler_mark(Wrap_MeshModelSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNMeshModelSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_MeshModelSerializeHandler* internalObj;

    internalObj = new Wrap_MeshModelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMeshModelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNMeshModelSerializeHandler_mark, LNMeshModelSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNMeshModelSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_MeshModelSerializeHandler* internalObj;

    internalObj = new Wrap_MeshModelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMeshModelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNMeshModelSerializeHandler_mark, LNMeshModelSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNMeshModelSerializeHandler_OnSerialize_ProcCaller(LNHandle meshmodelserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_MeshModelSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(meshmodelserializehandler), Wrap_MeshModelSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNMeshModelSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_MeshModelSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_MeshModelSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNMeshModelSerializeHandler_Create(Wrap_LNMeshModelSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "MeshModelSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// MeshImportSettingsSerializeHandler

struct Wrap_MeshImportSettingsSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_MeshImportSettingsSerializeHandler()
    {}
};

static void LNMeshImportSettingsSerializeHandler_delete(Wrap_MeshImportSettingsSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNMeshImportSettingsSerializeHandler_mark(Wrap_MeshImportSettingsSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNMeshImportSettingsSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_MeshImportSettingsSerializeHandler* internalObj;

    internalObj = new Wrap_MeshImportSettingsSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMeshImportSettingsSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNMeshImportSettingsSerializeHandler_mark, LNMeshImportSettingsSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNMeshImportSettingsSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_MeshImportSettingsSerializeHandler* internalObj;

    internalObj = new Wrap_MeshImportSettingsSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNMeshImportSettingsSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNMeshImportSettingsSerializeHandler_mark, LNMeshImportSettingsSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNMeshImportSettingsSerializeHandler_OnSerialize_ProcCaller(LNHandle meshimportsettingsserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_MeshImportSettingsSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(meshimportsettingsserializehandler), Wrap_MeshImportSettingsSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNMeshImportSettingsSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_MeshImportSettingsSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_MeshImportSettingsSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNMeshImportSettingsSerializeHandler_Create(Wrap_LNMeshImportSettingsSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "MeshImportSettingsSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// SkinnedMeshModelSerializeHandler

struct Wrap_SkinnedMeshModelSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_SkinnedMeshModelSerializeHandler()
    {}
};

static void LNSkinnedMeshModelSerializeHandler_delete(Wrap_SkinnedMeshModelSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSkinnedMeshModelSerializeHandler_mark(Wrap_SkinnedMeshModelSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNSkinnedMeshModelSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SkinnedMeshModelSerializeHandler* internalObj;

    internalObj = new Wrap_SkinnedMeshModelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSkinnedMeshModelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSkinnedMeshModelSerializeHandler_mark, LNSkinnedMeshModelSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNSkinnedMeshModelSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SkinnedMeshModelSerializeHandler* internalObj;

    internalObj = new Wrap_SkinnedMeshModelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSkinnedMeshModelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSkinnedMeshModelSerializeHandler_mark, LNSkinnedMeshModelSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNSkinnedMeshModelSerializeHandler_OnSerialize_ProcCaller(LNHandle skinnedmeshmodelserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_SkinnedMeshModelSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(skinnedmeshmodelserializehandler), Wrap_SkinnedMeshModelSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNSkinnedMeshModelSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_SkinnedMeshModelSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_SkinnedMeshModelSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNSkinnedMeshModelSerializeHandler_Create(Wrap_LNSkinnedMeshModelSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "SkinnedMeshModelSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// CollisionShapeSerializeHandler

struct Wrap_CollisionShapeSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_CollisionShapeSerializeHandler()
    {}
};

static void LNCollisionShapeSerializeHandler_delete(Wrap_CollisionShapeSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNCollisionShapeSerializeHandler_mark(Wrap_CollisionShapeSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNCollisionShapeSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_CollisionShapeSerializeHandler* internalObj;

    internalObj = new Wrap_CollisionShapeSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCollisionShapeSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCollisionShapeSerializeHandler_mark, LNCollisionShapeSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNCollisionShapeSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_CollisionShapeSerializeHandler* internalObj;

    internalObj = new Wrap_CollisionShapeSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCollisionShapeSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCollisionShapeSerializeHandler_mark, LNCollisionShapeSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNCollisionShapeSerializeHandler_OnSerialize_ProcCaller(LNHandle collisionshapeserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_CollisionShapeSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(collisionshapeserializehandler), Wrap_CollisionShapeSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNCollisionShapeSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_CollisionShapeSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_CollisionShapeSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNCollisionShapeSerializeHandler_Create(Wrap_LNCollisionShapeSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "CollisionShapeSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// BoxCollisionShapeSerializeHandler

struct Wrap_BoxCollisionShapeSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_BoxCollisionShapeSerializeHandler()
    {}
};

static void LNBoxCollisionShapeSerializeHandler_delete(Wrap_BoxCollisionShapeSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNBoxCollisionShapeSerializeHandler_mark(Wrap_BoxCollisionShapeSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNBoxCollisionShapeSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_BoxCollisionShapeSerializeHandler* internalObj;

    internalObj = new Wrap_BoxCollisionShapeSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNBoxCollisionShapeSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNBoxCollisionShapeSerializeHandler_mark, LNBoxCollisionShapeSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNBoxCollisionShapeSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_BoxCollisionShapeSerializeHandler* internalObj;

    internalObj = new Wrap_BoxCollisionShapeSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNBoxCollisionShapeSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNBoxCollisionShapeSerializeHandler_mark, LNBoxCollisionShapeSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNBoxCollisionShapeSerializeHandler_OnSerialize_ProcCaller(LNHandle boxcollisionshapeserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_BoxCollisionShapeSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(boxcollisionshapeserializehandler), Wrap_BoxCollisionShapeSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNBoxCollisionShapeSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_BoxCollisionShapeSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_BoxCollisionShapeSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNBoxCollisionShapeSerializeHandler_Create(Wrap_LNBoxCollisionShapeSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "BoxCollisionShapeSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// AnimationCurveSerializeHandler

struct Wrap_AnimationCurveSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_AnimationCurveSerializeHandler()
    {}
};

static void LNAnimationCurveSerializeHandler_delete(Wrap_AnimationCurveSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAnimationCurveSerializeHandler_mark(Wrap_AnimationCurveSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNAnimationCurveSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AnimationCurveSerializeHandler* internalObj;

    internalObj = new Wrap_AnimationCurveSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationCurveSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationCurveSerializeHandler_mark, LNAnimationCurveSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNAnimationCurveSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AnimationCurveSerializeHandler* internalObj;

    internalObj = new Wrap_AnimationCurveSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationCurveSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationCurveSerializeHandler_mark, LNAnimationCurveSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNAnimationCurveSerializeHandler_OnSerialize_ProcCaller(LNHandle animationcurveserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_AnimationCurveSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(animationcurveserializehandler), Wrap_AnimationCurveSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNAnimationCurveSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_AnimationCurveSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_AnimationCurveSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNAnimationCurveSerializeHandler_Create(Wrap_LNAnimationCurveSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "AnimationCurveSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// KeyFrameAnimationCurveSerializeHandler

struct Wrap_KeyFrameAnimationCurveSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_KeyFrameAnimationCurveSerializeHandler()
    {}
};

static void LNKeyFrameAnimationCurveSerializeHandler_delete(Wrap_KeyFrameAnimationCurveSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNKeyFrameAnimationCurveSerializeHandler_mark(Wrap_KeyFrameAnimationCurveSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNKeyFrameAnimationCurveSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_KeyFrameAnimationCurveSerializeHandler* internalObj;

    internalObj = new Wrap_KeyFrameAnimationCurveSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNKeyFrameAnimationCurveSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNKeyFrameAnimationCurveSerializeHandler_mark, LNKeyFrameAnimationCurveSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNKeyFrameAnimationCurveSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_KeyFrameAnimationCurveSerializeHandler* internalObj;

    internalObj = new Wrap_KeyFrameAnimationCurveSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNKeyFrameAnimationCurveSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNKeyFrameAnimationCurveSerializeHandler_mark, LNKeyFrameAnimationCurveSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNKeyFrameAnimationCurveSerializeHandler_OnSerialize_ProcCaller(LNHandle keyframeanimationcurveserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_KeyFrameAnimationCurveSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(keyframeanimationcurveserializehandler), Wrap_KeyFrameAnimationCurveSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNKeyFrameAnimationCurveSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_KeyFrameAnimationCurveSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_KeyFrameAnimationCurveSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNKeyFrameAnimationCurveSerializeHandler_Create(Wrap_LNKeyFrameAnimationCurveSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "KeyFrameAnimationCurveSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// AnimationClipSerializeHandler

struct Wrap_AnimationClipSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_AnimationClipSerializeHandler()
    {}
};

static void LNAnimationClipSerializeHandler_delete(Wrap_AnimationClipSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAnimationClipSerializeHandler_mark(Wrap_AnimationClipSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNAnimationClipSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AnimationClipSerializeHandler* internalObj;

    internalObj = new Wrap_AnimationClipSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationClipSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationClipSerializeHandler_mark, LNAnimationClipSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNAnimationClipSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AnimationClipSerializeHandler* internalObj;

    internalObj = new Wrap_AnimationClipSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationClipSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationClipSerializeHandler_mark, LNAnimationClipSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNAnimationClipSerializeHandler_OnSerialize_ProcCaller(LNHandle animationclipserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_AnimationClipSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(animationclipserializehandler), Wrap_AnimationClipSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNAnimationClipSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_AnimationClipSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_AnimationClipSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNAnimationClipSerializeHandler_Create(Wrap_LNAnimationClipSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "AnimationClipSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// AnimationStateSerializeHandler

struct Wrap_AnimationStateSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_AnimationStateSerializeHandler()
    {}
};

static void LNAnimationStateSerializeHandler_delete(Wrap_AnimationStateSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNAnimationStateSerializeHandler_mark(Wrap_AnimationStateSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNAnimationStateSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_AnimationStateSerializeHandler* internalObj;

    internalObj = new Wrap_AnimationStateSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationStateSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationStateSerializeHandler_mark, LNAnimationStateSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNAnimationStateSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_AnimationStateSerializeHandler* internalObj;

    internalObj = new Wrap_AnimationStateSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNAnimationStateSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNAnimationStateSerializeHandler_mark, LNAnimationStateSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNAnimationStateSerializeHandler_OnSerialize_ProcCaller(LNHandle animationstateserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_AnimationStateSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(animationstateserializehandler), Wrap_AnimationStateSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNAnimationStateSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_AnimationStateSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_AnimationStateSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNAnimationStateSerializeHandler_Create(Wrap_LNAnimationStateSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "AnimationStateSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// EffectResourceSerializeHandler

struct Wrap_EffectResourceSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_EffectResourceSerializeHandler()
    {}
};

static void LNEffectResourceSerializeHandler_delete(Wrap_EffectResourceSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNEffectResourceSerializeHandler_mark(Wrap_EffectResourceSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNEffectResourceSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_EffectResourceSerializeHandler* internalObj;

    internalObj = new Wrap_EffectResourceSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEffectResourceSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNEffectResourceSerializeHandler_mark, LNEffectResourceSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNEffectResourceSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_EffectResourceSerializeHandler* internalObj;

    internalObj = new Wrap_EffectResourceSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEffectResourceSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNEffectResourceSerializeHandler_mark, LNEffectResourceSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNEffectResourceSerializeHandler_OnSerialize_ProcCaller(LNHandle effectresourceserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_EffectResourceSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(effectresourceserializehandler), Wrap_EffectResourceSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNEffectResourceSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_EffectResourceSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_EffectResourceSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNEffectResourceSerializeHandler_Create(Wrap_LNEffectResourceSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "EffectResourceSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ParticleEmitterModelSerializeHandler

struct Wrap_ParticleEmitterModelSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ParticleEmitterModelSerializeHandler()
    {}
};

static void LNParticleEmitterModelSerializeHandler_delete(Wrap_ParticleEmitterModelSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNParticleEmitterModelSerializeHandler_mark(Wrap_ParticleEmitterModelSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNParticleEmitterModelSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ParticleEmitterModelSerializeHandler* internalObj;

    internalObj = new Wrap_ParticleEmitterModelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleEmitterModelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleEmitterModelSerializeHandler_mark, LNParticleEmitterModelSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNParticleEmitterModelSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ParticleEmitterModelSerializeHandler* internalObj;

    internalObj = new Wrap_ParticleEmitterModelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleEmitterModelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleEmitterModelSerializeHandler_mark, LNParticleEmitterModelSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNParticleEmitterModelSerializeHandler_OnSerialize_ProcCaller(LNHandle particleemittermodelserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_ParticleEmitterModelSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(particleemittermodelserializehandler), Wrap_ParticleEmitterModelSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNParticleEmitterModelSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterModelSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterModelSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNParticleEmitterModelSerializeHandler_Create(Wrap_LNParticleEmitterModelSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ParticleEmitterModelSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ParticleModelSerializeHandler

struct Wrap_ParticleModelSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ParticleModelSerializeHandler()
    {}
};

static void LNParticleModelSerializeHandler_delete(Wrap_ParticleModelSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNParticleModelSerializeHandler_mark(Wrap_ParticleModelSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNParticleModelSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ParticleModelSerializeHandler* internalObj;

    internalObj = new Wrap_ParticleModelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleModelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleModelSerializeHandler_mark, LNParticleModelSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNParticleModelSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ParticleModelSerializeHandler* internalObj;

    internalObj = new Wrap_ParticleModelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleModelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleModelSerializeHandler_mark, LNParticleModelSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNParticleModelSerializeHandler_OnSerialize_ProcCaller(LNHandle particlemodelserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_ParticleModelSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(particlemodelserializehandler), Wrap_ParticleModelSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNParticleModelSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleModelSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_ParticleModelSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNParticleModelSerializeHandler_Create(Wrap_LNParticleModelSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ParticleModelSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ComponentSerializeHandler

struct Wrap_ComponentSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ComponentSerializeHandler()
    {}
};

static void LNComponentSerializeHandler_delete(Wrap_ComponentSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNComponentSerializeHandler_mark(Wrap_ComponentSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNComponentSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ComponentSerializeHandler* internalObj;

    internalObj = new Wrap_ComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNComponentSerializeHandler_mark, LNComponentSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNComponentSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ComponentSerializeHandler* internalObj;

    internalObj = new Wrap_ComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNComponentSerializeHandler_mark, LNComponentSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNComponentSerializeHandler_OnSerialize_ProcCaller(LNHandle componentserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_ComponentSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(componentserializehandler), Wrap_ComponentSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNComponentSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ComponentSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_ComponentSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNComponentSerializeHandler_Create(Wrap_LNComponentSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ComponentSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// VisualComponentSerializeHandler

struct Wrap_VisualComponentSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_VisualComponentSerializeHandler()
    {}
};

static void LNVisualComponentSerializeHandler_delete(Wrap_VisualComponentSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNVisualComponentSerializeHandler_mark(Wrap_VisualComponentSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNVisualComponentSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_VisualComponentSerializeHandler* internalObj;

    internalObj = new Wrap_VisualComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVisualComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNVisualComponentSerializeHandler_mark, LNVisualComponentSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNVisualComponentSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_VisualComponentSerializeHandler* internalObj;

    internalObj = new Wrap_VisualComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVisualComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNVisualComponentSerializeHandler_mark, LNVisualComponentSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNVisualComponentSerializeHandler_OnSerialize_ProcCaller(LNHandle visualcomponentserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_VisualComponentSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(visualcomponentserializehandler), Wrap_VisualComponentSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNVisualComponentSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_VisualComponentSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_VisualComponentSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNVisualComponentSerializeHandler_Create(Wrap_LNVisualComponentSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "VisualComponentSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// SpriteComponentSerializeHandler

struct Wrap_SpriteComponentSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_SpriteComponentSerializeHandler()
    {}
};

static void LNSpriteComponentSerializeHandler_delete(Wrap_SpriteComponentSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSpriteComponentSerializeHandler_mark(Wrap_SpriteComponentSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNSpriteComponentSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SpriteComponentSerializeHandler* internalObj;

    internalObj = new Wrap_SpriteComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpriteComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpriteComponentSerializeHandler_mark, LNSpriteComponentSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNSpriteComponentSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SpriteComponentSerializeHandler* internalObj;

    internalObj = new Wrap_SpriteComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpriteComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpriteComponentSerializeHandler_mark, LNSpriteComponentSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNSpriteComponentSerializeHandler_OnSerialize_ProcCaller(LNHandle spritecomponentserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_SpriteComponentSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(spritecomponentserializehandler), Wrap_SpriteComponentSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNSpriteComponentSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpriteComponentSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_SpriteComponentSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNSpriteComponentSerializeHandler_Create(Wrap_LNSpriteComponentSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "SpriteComponentSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// CharacterControllerSerializeHandler

struct Wrap_CharacterControllerSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_CharacterControllerSerializeHandler()
    {}
};

static void LNCharacterControllerSerializeHandler_delete(Wrap_CharacterControllerSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNCharacterControllerSerializeHandler_mark(Wrap_CharacterControllerSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNCharacterControllerSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_CharacterControllerSerializeHandler* internalObj;

    internalObj = new Wrap_CharacterControllerSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCharacterControllerSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCharacterControllerSerializeHandler_mark, LNCharacterControllerSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNCharacterControllerSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_CharacterControllerSerializeHandler* internalObj;

    internalObj = new Wrap_CharacterControllerSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCharacterControllerSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCharacterControllerSerializeHandler_mark, LNCharacterControllerSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNCharacterControllerSerializeHandler_OnSerialize_ProcCaller(LNHandle charactercontrollerserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_CharacterControllerSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(charactercontrollerserializehandler), Wrap_CharacterControllerSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNCharacterControllerSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_CharacterControllerSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_CharacterControllerSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNCharacterControllerSerializeHandler_Create(Wrap_LNCharacterControllerSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "CharacterControllerSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// WorldSerializeHandler

struct Wrap_WorldSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_WorldSerializeHandler()
    {}
};

static void LNWorldSerializeHandler_delete(Wrap_WorldSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNWorldSerializeHandler_mark(Wrap_WorldSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNWorldSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_WorldSerializeHandler* internalObj;

    internalObj = new Wrap_WorldSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldSerializeHandler_mark, LNWorldSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNWorldSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_WorldSerializeHandler* internalObj;

    internalObj = new Wrap_WorldSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldSerializeHandler_mark, LNWorldSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNWorldSerializeHandler_OnSerialize_ProcCaller(LNHandle worldserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_WorldSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(worldserializehandler), Wrap_WorldSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNWorldSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_WorldSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNWorldSerializeHandler_Create(Wrap_LNWorldSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "WorldSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ComponentListSerializeHandler

struct Wrap_ComponentListSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ComponentListSerializeHandler()
    {}
};

static void LNComponentListSerializeHandler_delete(Wrap_ComponentListSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNComponentListSerializeHandler_mark(Wrap_ComponentListSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNComponentListSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ComponentListSerializeHandler* internalObj;

    internalObj = new Wrap_ComponentListSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNComponentListSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNComponentListSerializeHandler_mark, LNComponentListSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNComponentListSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ComponentListSerializeHandler* internalObj;

    internalObj = new Wrap_ComponentListSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNComponentListSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNComponentListSerializeHandler_mark, LNComponentListSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNComponentListSerializeHandler_OnSerialize_ProcCaller(LNHandle componentlistserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_ComponentListSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(componentlistserializehandler), Wrap_ComponentListSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNComponentListSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ComponentListSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_ComponentListSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNComponentListSerializeHandler_Create(Wrap_LNComponentListSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ComponentListSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// WorldObjectSerializeHandler

struct Wrap_WorldObjectSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_WorldObjectSerializeHandler()
    {}
};

static void LNWorldObjectSerializeHandler_delete(Wrap_WorldObjectSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNWorldObjectSerializeHandler_mark(Wrap_WorldObjectSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNWorldObjectSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_WorldObjectSerializeHandler* internalObj;

    internalObj = new Wrap_WorldObjectSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldObjectSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldObjectSerializeHandler_mark, LNWorldObjectSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNWorldObjectSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_WorldObjectSerializeHandler* internalObj;

    internalObj = new Wrap_WorldObjectSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldObjectSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldObjectSerializeHandler_mark, LNWorldObjectSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNWorldObjectSerializeHandler_OnSerialize_ProcCaller(LNHandle worldobjectserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_WorldObjectSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(worldobjectserializehandler), Wrap_WorldObjectSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNWorldObjectSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObjectSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_WorldObjectSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNWorldObjectSerializeHandler_Create(Wrap_LNWorldObjectSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "WorldObjectSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// WorldObjectPreUpdateHandler

struct Wrap_WorldObjectPreUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_WorldObjectPreUpdateHandler()
    {}
};

static void LNWorldObjectPreUpdateHandler_delete(Wrap_WorldObjectPreUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNWorldObjectPreUpdateHandler_mark(Wrap_WorldObjectPreUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNWorldObjectPreUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_WorldObjectPreUpdateHandler* internalObj;

    internalObj = new Wrap_WorldObjectPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldObjectPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldObjectPreUpdateHandler_mark, LNWorldObjectPreUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNWorldObjectPreUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_WorldObjectPreUpdateHandler* internalObj;

    internalObj = new Wrap_WorldObjectPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldObjectPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldObjectPreUpdateHandler_mark, LNWorldObjectPreUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNWorldObjectPreUpdateHandler_OnPreUpdate_ProcCaller(LNHandle worldobjectpreupdatehandler, LNHandle self)
{
    Wrap_WorldObjectPreUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(worldobjectpreupdatehandler), Wrap_WorldObjectPreUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNWorldObjectPreUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObjectPreUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_WorldObjectPreUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNWorldObjectPreUpdateHandler_Create(Wrap_LNWorldObjectPreUpdateHandler_OnPreUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "WorldObjectPreUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// WorldObjectUpdateHandler

struct Wrap_WorldObjectUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_WorldObjectUpdateHandler()
    {}
};

static void LNWorldObjectUpdateHandler_delete(Wrap_WorldObjectUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNWorldObjectUpdateHandler_mark(Wrap_WorldObjectUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNWorldObjectUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_WorldObjectUpdateHandler* internalObj;

    internalObj = new Wrap_WorldObjectUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldObjectUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldObjectUpdateHandler_mark, LNWorldObjectUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNWorldObjectUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_WorldObjectUpdateHandler* internalObj;

    internalObj = new Wrap_WorldObjectUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldObjectUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldObjectUpdateHandler_mark, LNWorldObjectUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNWorldObjectUpdateHandler_OnUpdate_ProcCaller(LNHandle worldobjectupdatehandler, LNHandle self, float elapsedSeconds)
{
    Wrap_WorldObjectUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(worldobjectupdatehandler), Wrap_WorldObjectUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNWorldObjectUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldObjectUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_WorldObjectUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNWorldObjectUpdateHandler_Create(Wrap_LNWorldObjectUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "WorldObjectUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// VisualObjectSerializeHandler

struct Wrap_VisualObjectSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_VisualObjectSerializeHandler()
    {}
};

static void LNVisualObjectSerializeHandler_delete(Wrap_VisualObjectSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNVisualObjectSerializeHandler_mark(Wrap_VisualObjectSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNVisualObjectSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_VisualObjectSerializeHandler* internalObj;

    internalObj = new Wrap_VisualObjectSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVisualObjectSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNVisualObjectSerializeHandler_mark, LNVisualObjectSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNVisualObjectSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_VisualObjectSerializeHandler* internalObj;

    internalObj = new Wrap_VisualObjectSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVisualObjectSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNVisualObjectSerializeHandler_mark, LNVisualObjectSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNVisualObjectSerializeHandler_OnSerialize_ProcCaller(LNHandle visualobjectserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_VisualObjectSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(visualobjectserializehandler), Wrap_VisualObjectSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNVisualObjectSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_VisualObjectSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_VisualObjectSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNVisualObjectSerializeHandler_Create(Wrap_LNVisualObjectSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "VisualObjectSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// VisualObjectPreUpdateHandler

struct Wrap_VisualObjectPreUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_VisualObjectPreUpdateHandler()
    {}
};

static void LNVisualObjectPreUpdateHandler_delete(Wrap_VisualObjectPreUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNVisualObjectPreUpdateHandler_mark(Wrap_VisualObjectPreUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNVisualObjectPreUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_VisualObjectPreUpdateHandler* internalObj;

    internalObj = new Wrap_VisualObjectPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVisualObjectPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNVisualObjectPreUpdateHandler_mark, LNVisualObjectPreUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNVisualObjectPreUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_VisualObjectPreUpdateHandler* internalObj;

    internalObj = new Wrap_VisualObjectPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVisualObjectPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNVisualObjectPreUpdateHandler_mark, LNVisualObjectPreUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNVisualObjectPreUpdateHandler_OnPreUpdate_ProcCaller(LNHandle visualobjectpreupdatehandler, LNHandle self)
{
    Wrap_VisualObjectPreUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(visualobjectpreupdatehandler), Wrap_VisualObjectPreUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNVisualObjectPreUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_VisualObjectPreUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_VisualObjectPreUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNVisualObjectPreUpdateHandler_Create(Wrap_LNVisualObjectPreUpdateHandler_OnPreUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "VisualObjectPreUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// VisualObjectUpdateHandler

struct Wrap_VisualObjectUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_VisualObjectUpdateHandler()
    {}
};

static void LNVisualObjectUpdateHandler_delete(Wrap_VisualObjectUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNVisualObjectUpdateHandler_mark(Wrap_VisualObjectUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNVisualObjectUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_VisualObjectUpdateHandler* internalObj;

    internalObj = new Wrap_VisualObjectUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVisualObjectUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNVisualObjectUpdateHandler_mark, LNVisualObjectUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNVisualObjectUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_VisualObjectUpdateHandler* internalObj;

    internalObj = new Wrap_VisualObjectUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNVisualObjectUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNVisualObjectUpdateHandler_mark, LNVisualObjectUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNVisualObjectUpdateHandler_OnUpdate_ProcCaller(LNHandle visualobjectupdatehandler, LNHandle self, float elapsedSeconds)
{
    Wrap_VisualObjectUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(visualobjectupdatehandler), Wrap_VisualObjectUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNVisualObjectUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_VisualObjectUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_VisualObjectUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNVisualObjectUpdateHandler_Create(Wrap_LNVisualObjectUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "VisualObjectUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// CameraSerializeHandler

struct Wrap_CameraSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_CameraSerializeHandler()
    {}
};

static void LNCameraSerializeHandler_delete(Wrap_CameraSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNCameraSerializeHandler_mark(Wrap_CameraSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNCameraSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_CameraSerializeHandler* internalObj;

    internalObj = new Wrap_CameraSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCameraSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCameraSerializeHandler_mark, LNCameraSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNCameraSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_CameraSerializeHandler* internalObj;

    internalObj = new Wrap_CameraSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCameraSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCameraSerializeHandler_mark, LNCameraSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNCameraSerializeHandler_OnSerialize_ProcCaller(LNHandle cameraserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_CameraSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(cameraserializehandler), Wrap_CameraSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNCameraSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_CameraSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_CameraSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNCameraSerializeHandler_Create(Wrap_LNCameraSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "CameraSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// CameraPreUpdateHandler

struct Wrap_CameraPreUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_CameraPreUpdateHandler()
    {}
};

static void LNCameraPreUpdateHandler_delete(Wrap_CameraPreUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNCameraPreUpdateHandler_mark(Wrap_CameraPreUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNCameraPreUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_CameraPreUpdateHandler* internalObj;

    internalObj = new Wrap_CameraPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCameraPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCameraPreUpdateHandler_mark, LNCameraPreUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNCameraPreUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_CameraPreUpdateHandler* internalObj;

    internalObj = new Wrap_CameraPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCameraPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCameraPreUpdateHandler_mark, LNCameraPreUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNCameraPreUpdateHandler_OnPreUpdate_ProcCaller(LNHandle camerapreupdatehandler, LNHandle self)
{
    Wrap_CameraPreUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(camerapreupdatehandler), Wrap_CameraPreUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNCameraPreUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_CameraPreUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_CameraPreUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNCameraPreUpdateHandler_Create(Wrap_LNCameraPreUpdateHandler_OnPreUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "CameraPreUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// CameraUpdateHandler

struct Wrap_CameraUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_CameraUpdateHandler()
    {}
};

static void LNCameraUpdateHandler_delete(Wrap_CameraUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNCameraUpdateHandler_mark(Wrap_CameraUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNCameraUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_CameraUpdateHandler* internalObj;

    internalObj = new Wrap_CameraUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCameraUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCameraUpdateHandler_mark, LNCameraUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNCameraUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_CameraUpdateHandler* internalObj;

    internalObj = new Wrap_CameraUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCameraUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCameraUpdateHandler_mark, LNCameraUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNCameraUpdateHandler_OnUpdate_ProcCaller(LNHandle cameraupdatehandler, LNHandle self, float elapsedSeconds)
{
    Wrap_CameraUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(cameraupdatehandler), Wrap_CameraUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNCameraUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_CameraUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_CameraUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNCameraUpdateHandler_Create(Wrap_LNCameraUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "CameraUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// EnvironmentLightSerializeHandler

struct Wrap_EnvironmentLightSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_EnvironmentLightSerializeHandler()
    {}
};

static void LNEnvironmentLightSerializeHandler_delete(Wrap_EnvironmentLightSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNEnvironmentLightSerializeHandler_mark(Wrap_EnvironmentLightSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNEnvironmentLightSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_EnvironmentLightSerializeHandler* internalObj;

    internalObj = new Wrap_EnvironmentLightSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEnvironmentLightSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNEnvironmentLightSerializeHandler_mark, LNEnvironmentLightSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNEnvironmentLightSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_EnvironmentLightSerializeHandler* internalObj;

    internalObj = new Wrap_EnvironmentLightSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEnvironmentLightSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNEnvironmentLightSerializeHandler_mark, LNEnvironmentLightSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNEnvironmentLightSerializeHandler_OnSerialize_ProcCaller(LNHandle environmentlightserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_EnvironmentLightSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(environmentlightserializehandler), Wrap_EnvironmentLightSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNEnvironmentLightSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLightSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLightSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNEnvironmentLightSerializeHandler_Create(Wrap_LNEnvironmentLightSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "EnvironmentLightSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// EnvironmentLightPreUpdateHandler

struct Wrap_EnvironmentLightPreUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_EnvironmentLightPreUpdateHandler()
    {}
};

static void LNEnvironmentLightPreUpdateHandler_delete(Wrap_EnvironmentLightPreUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNEnvironmentLightPreUpdateHandler_mark(Wrap_EnvironmentLightPreUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNEnvironmentLightPreUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_EnvironmentLightPreUpdateHandler* internalObj;

    internalObj = new Wrap_EnvironmentLightPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEnvironmentLightPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNEnvironmentLightPreUpdateHandler_mark, LNEnvironmentLightPreUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNEnvironmentLightPreUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_EnvironmentLightPreUpdateHandler* internalObj;

    internalObj = new Wrap_EnvironmentLightPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEnvironmentLightPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNEnvironmentLightPreUpdateHandler_mark, LNEnvironmentLightPreUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNEnvironmentLightPreUpdateHandler_OnPreUpdate_ProcCaller(LNHandle environmentlightpreupdatehandler, LNHandle self)
{
    Wrap_EnvironmentLightPreUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(environmentlightpreupdatehandler), Wrap_EnvironmentLightPreUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNEnvironmentLightPreUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLightPreUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLightPreUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNEnvironmentLightPreUpdateHandler_Create(Wrap_LNEnvironmentLightPreUpdateHandler_OnPreUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "EnvironmentLightPreUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// EnvironmentLightUpdateHandler

struct Wrap_EnvironmentLightUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_EnvironmentLightUpdateHandler()
    {}
};

static void LNEnvironmentLightUpdateHandler_delete(Wrap_EnvironmentLightUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNEnvironmentLightUpdateHandler_mark(Wrap_EnvironmentLightUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNEnvironmentLightUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_EnvironmentLightUpdateHandler* internalObj;

    internalObj = new Wrap_EnvironmentLightUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEnvironmentLightUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNEnvironmentLightUpdateHandler_mark, LNEnvironmentLightUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNEnvironmentLightUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_EnvironmentLightUpdateHandler* internalObj;

    internalObj = new Wrap_EnvironmentLightUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNEnvironmentLightUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNEnvironmentLightUpdateHandler_mark, LNEnvironmentLightUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNEnvironmentLightUpdateHandler_OnUpdate_ProcCaller(LNHandle environmentlightupdatehandler, LNHandle self, float elapsedSeconds)
{
    Wrap_EnvironmentLightUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(environmentlightupdatehandler), Wrap_EnvironmentLightUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNEnvironmentLightUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_EnvironmentLightUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_EnvironmentLightUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNEnvironmentLightUpdateHandler_Create(Wrap_LNEnvironmentLightUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "EnvironmentLightUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// DirectionalLightSerializeHandler

struct Wrap_DirectionalLightSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_DirectionalLightSerializeHandler()
    {}
};

static void LNDirectionalLightSerializeHandler_delete(Wrap_DirectionalLightSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNDirectionalLightSerializeHandler_mark(Wrap_DirectionalLightSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNDirectionalLightSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_DirectionalLightSerializeHandler* internalObj;

    internalObj = new Wrap_DirectionalLightSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNDirectionalLightSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNDirectionalLightSerializeHandler_mark, LNDirectionalLightSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNDirectionalLightSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_DirectionalLightSerializeHandler* internalObj;

    internalObj = new Wrap_DirectionalLightSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNDirectionalLightSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNDirectionalLightSerializeHandler_mark, LNDirectionalLightSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNDirectionalLightSerializeHandler_OnSerialize_ProcCaller(LNHandle directionallightserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_DirectionalLightSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(directionallightserializehandler), Wrap_DirectionalLightSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNDirectionalLightSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLightSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLightSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNDirectionalLightSerializeHandler_Create(Wrap_LNDirectionalLightSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "DirectionalLightSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// DirectionalLightPreUpdateHandler

struct Wrap_DirectionalLightPreUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_DirectionalLightPreUpdateHandler()
    {}
};

static void LNDirectionalLightPreUpdateHandler_delete(Wrap_DirectionalLightPreUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNDirectionalLightPreUpdateHandler_mark(Wrap_DirectionalLightPreUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNDirectionalLightPreUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_DirectionalLightPreUpdateHandler* internalObj;

    internalObj = new Wrap_DirectionalLightPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNDirectionalLightPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNDirectionalLightPreUpdateHandler_mark, LNDirectionalLightPreUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNDirectionalLightPreUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_DirectionalLightPreUpdateHandler* internalObj;

    internalObj = new Wrap_DirectionalLightPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNDirectionalLightPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNDirectionalLightPreUpdateHandler_mark, LNDirectionalLightPreUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNDirectionalLightPreUpdateHandler_OnPreUpdate_ProcCaller(LNHandle directionallightpreupdatehandler, LNHandle self)
{
    Wrap_DirectionalLightPreUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(directionallightpreupdatehandler), Wrap_DirectionalLightPreUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNDirectionalLightPreUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLightPreUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLightPreUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNDirectionalLightPreUpdateHandler_Create(Wrap_LNDirectionalLightPreUpdateHandler_OnPreUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "DirectionalLightPreUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// DirectionalLightUpdateHandler

struct Wrap_DirectionalLightUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_DirectionalLightUpdateHandler()
    {}
};

static void LNDirectionalLightUpdateHandler_delete(Wrap_DirectionalLightUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNDirectionalLightUpdateHandler_mark(Wrap_DirectionalLightUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNDirectionalLightUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_DirectionalLightUpdateHandler* internalObj;

    internalObj = new Wrap_DirectionalLightUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNDirectionalLightUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNDirectionalLightUpdateHandler_mark, LNDirectionalLightUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNDirectionalLightUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_DirectionalLightUpdateHandler* internalObj;

    internalObj = new Wrap_DirectionalLightUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNDirectionalLightUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNDirectionalLightUpdateHandler_mark, LNDirectionalLightUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNDirectionalLightUpdateHandler_OnUpdate_ProcCaller(LNHandle directionallightupdatehandler, LNHandle self, float elapsedSeconds)
{
    Wrap_DirectionalLightUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(directionallightupdatehandler), Wrap_DirectionalLightUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNDirectionalLightUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_DirectionalLightUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_DirectionalLightUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNDirectionalLightUpdateHandler_Create(Wrap_LNDirectionalLightUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "DirectionalLightUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// PointLightSerializeHandler

struct Wrap_PointLightSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_PointLightSerializeHandler()
    {}
};

static void LNPointLightSerializeHandler_delete(Wrap_PointLightSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNPointLightSerializeHandler_mark(Wrap_PointLightSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNPointLightSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_PointLightSerializeHandler* internalObj;

    internalObj = new Wrap_PointLightSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPointLightSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNPointLightSerializeHandler_mark, LNPointLightSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNPointLightSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_PointLightSerializeHandler* internalObj;

    internalObj = new Wrap_PointLightSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPointLightSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNPointLightSerializeHandler_mark, LNPointLightSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNPointLightSerializeHandler_OnSerialize_ProcCaller(LNHandle pointlightserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_PointLightSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(pointlightserializehandler), Wrap_PointLightSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNPointLightSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLightSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_PointLightSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNPointLightSerializeHandler_Create(Wrap_LNPointLightSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "PointLightSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// PointLightPreUpdateHandler

struct Wrap_PointLightPreUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_PointLightPreUpdateHandler()
    {}
};

static void LNPointLightPreUpdateHandler_delete(Wrap_PointLightPreUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNPointLightPreUpdateHandler_mark(Wrap_PointLightPreUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNPointLightPreUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_PointLightPreUpdateHandler* internalObj;

    internalObj = new Wrap_PointLightPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPointLightPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNPointLightPreUpdateHandler_mark, LNPointLightPreUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNPointLightPreUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_PointLightPreUpdateHandler* internalObj;

    internalObj = new Wrap_PointLightPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPointLightPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNPointLightPreUpdateHandler_mark, LNPointLightPreUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNPointLightPreUpdateHandler_OnPreUpdate_ProcCaller(LNHandle pointlightpreupdatehandler, LNHandle self)
{
    Wrap_PointLightPreUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(pointlightpreupdatehandler), Wrap_PointLightPreUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNPointLightPreUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLightPreUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_PointLightPreUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNPointLightPreUpdateHandler_Create(Wrap_LNPointLightPreUpdateHandler_OnPreUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "PointLightPreUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// PointLightUpdateHandler

struct Wrap_PointLightUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_PointLightUpdateHandler()
    {}
};

static void LNPointLightUpdateHandler_delete(Wrap_PointLightUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNPointLightUpdateHandler_mark(Wrap_PointLightUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNPointLightUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_PointLightUpdateHandler* internalObj;

    internalObj = new Wrap_PointLightUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPointLightUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNPointLightUpdateHandler_mark, LNPointLightUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNPointLightUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_PointLightUpdateHandler* internalObj;

    internalObj = new Wrap_PointLightUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPointLightUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNPointLightUpdateHandler_mark, LNPointLightUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNPointLightUpdateHandler_OnUpdate_ProcCaller(LNHandle pointlightupdatehandler, LNHandle self, float elapsedSeconds)
{
    Wrap_PointLightUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(pointlightupdatehandler), Wrap_PointLightUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNPointLightUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_PointLightUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_PointLightUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNPointLightUpdateHandler_Create(Wrap_LNPointLightUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "PointLightUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// SpotLightSerializeHandler

struct Wrap_SpotLightSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_SpotLightSerializeHandler()
    {}
};

static void LNSpotLightSerializeHandler_delete(Wrap_SpotLightSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSpotLightSerializeHandler_mark(Wrap_SpotLightSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNSpotLightSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SpotLightSerializeHandler* internalObj;

    internalObj = new Wrap_SpotLightSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpotLightSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpotLightSerializeHandler_mark, LNSpotLightSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNSpotLightSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SpotLightSerializeHandler* internalObj;

    internalObj = new Wrap_SpotLightSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpotLightSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpotLightSerializeHandler_mark, LNSpotLightSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNSpotLightSerializeHandler_OnSerialize_ProcCaller(LNHandle spotlightserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_SpotLightSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(spotlightserializehandler), Wrap_SpotLightSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNSpotLightSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLightSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_SpotLightSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNSpotLightSerializeHandler_Create(Wrap_LNSpotLightSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "SpotLightSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// SpotLightPreUpdateHandler

struct Wrap_SpotLightPreUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_SpotLightPreUpdateHandler()
    {}
};

static void LNSpotLightPreUpdateHandler_delete(Wrap_SpotLightPreUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSpotLightPreUpdateHandler_mark(Wrap_SpotLightPreUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNSpotLightPreUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SpotLightPreUpdateHandler* internalObj;

    internalObj = new Wrap_SpotLightPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpotLightPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpotLightPreUpdateHandler_mark, LNSpotLightPreUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNSpotLightPreUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SpotLightPreUpdateHandler* internalObj;

    internalObj = new Wrap_SpotLightPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpotLightPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpotLightPreUpdateHandler_mark, LNSpotLightPreUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNSpotLightPreUpdateHandler_OnPreUpdate_ProcCaller(LNHandle spotlightpreupdatehandler, LNHandle self)
{
    Wrap_SpotLightPreUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(spotlightpreupdatehandler), Wrap_SpotLightPreUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNSpotLightPreUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLightPreUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_SpotLightPreUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNSpotLightPreUpdateHandler_Create(Wrap_LNSpotLightPreUpdateHandler_OnPreUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "SpotLightPreUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// SpotLightUpdateHandler

struct Wrap_SpotLightUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_SpotLightUpdateHandler()
    {}
};

static void LNSpotLightUpdateHandler_delete(Wrap_SpotLightUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSpotLightUpdateHandler_mark(Wrap_SpotLightUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNSpotLightUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SpotLightUpdateHandler* internalObj;

    internalObj = new Wrap_SpotLightUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpotLightUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpotLightUpdateHandler_mark, LNSpotLightUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNSpotLightUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SpotLightUpdateHandler* internalObj;

    internalObj = new Wrap_SpotLightUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpotLightUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpotLightUpdateHandler_mark, LNSpotLightUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNSpotLightUpdateHandler_OnUpdate_ProcCaller(LNHandle spotlightupdatehandler, LNHandle self, float elapsedSeconds)
{
    Wrap_SpotLightUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(spotlightupdatehandler), Wrap_SpotLightUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNSpotLightUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpotLightUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_SpotLightUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNSpotLightUpdateHandler_Create(Wrap_LNSpotLightUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "SpotLightUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// SpriteSerializeHandler

struct Wrap_SpriteSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_SpriteSerializeHandler()
    {}
};

static void LNSpriteSerializeHandler_delete(Wrap_SpriteSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSpriteSerializeHandler_mark(Wrap_SpriteSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNSpriteSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SpriteSerializeHandler* internalObj;

    internalObj = new Wrap_SpriteSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpriteSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpriteSerializeHandler_mark, LNSpriteSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNSpriteSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SpriteSerializeHandler* internalObj;

    internalObj = new Wrap_SpriteSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpriteSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpriteSerializeHandler_mark, LNSpriteSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNSpriteSerializeHandler_OnSerialize_ProcCaller(LNHandle spriteserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_SpriteSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(spriteserializehandler), Wrap_SpriteSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNSpriteSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpriteSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_SpriteSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNSpriteSerializeHandler_Create(Wrap_LNSpriteSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "SpriteSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// SpritePreUpdateHandler

struct Wrap_SpritePreUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_SpritePreUpdateHandler()
    {}
};

static void LNSpritePreUpdateHandler_delete(Wrap_SpritePreUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSpritePreUpdateHandler_mark(Wrap_SpritePreUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNSpritePreUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SpritePreUpdateHandler* internalObj;

    internalObj = new Wrap_SpritePreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpritePreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpritePreUpdateHandler_mark, LNSpritePreUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNSpritePreUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SpritePreUpdateHandler* internalObj;

    internalObj = new Wrap_SpritePreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpritePreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpritePreUpdateHandler_mark, LNSpritePreUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNSpritePreUpdateHandler_OnPreUpdate_ProcCaller(LNHandle spritepreupdatehandler, LNHandle self)
{
    Wrap_SpritePreUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(spritepreupdatehandler), Wrap_SpritePreUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNSpritePreUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpritePreUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_SpritePreUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNSpritePreUpdateHandler_Create(Wrap_LNSpritePreUpdateHandler_OnPreUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "SpritePreUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// SpriteUpdateHandler

struct Wrap_SpriteUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_SpriteUpdateHandler()
    {}
};

static void LNSpriteUpdateHandler_delete(Wrap_SpriteUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSpriteUpdateHandler_mark(Wrap_SpriteUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNSpriteUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SpriteUpdateHandler* internalObj;

    internalObj = new Wrap_SpriteUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpriteUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpriteUpdateHandler_mark, LNSpriteUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNSpriteUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SpriteUpdateHandler* internalObj;

    internalObj = new Wrap_SpriteUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSpriteUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSpriteUpdateHandler_mark, LNSpriteUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNSpriteUpdateHandler_OnUpdate_ProcCaller(LNHandle spriteupdatehandler, LNHandle self, float elapsedSeconds)
{
    Wrap_SpriteUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(spriteupdatehandler), Wrap_SpriteUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNSpriteUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_SpriteUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_SpriteUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNSpriteUpdateHandler_Create(Wrap_LNSpriteUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "SpriteUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// CameraOrbitControlComponentSerializeHandler

struct Wrap_CameraOrbitControlComponentSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_CameraOrbitControlComponentSerializeHandler()
    {}
};

static void LNCameraOrbitControlComponentSerializeHandler_delete(Wrap_CameraOrbitControlComponentSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNCameraOrbitControlComponentSerializeHandler_mark(Wrap_CameraOrbitControlComponentSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNCameraOrbitControlComponentSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_CameraOrbitControlComponentSerializeHandler* internalObj;

    internalObj = new Wrap_CameraOrbitControlComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCameraOrbitControlComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCameraOrbitControlComponentSerializeHandler_mark, LNCameraOrbitControlComponentSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNCameraOrbitControlComponentSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_CameraOrbitControlComponentSerializeHandler* internalObj;

    internalObj = new Wrap_CameraOrbitControlComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCameraOrbitControlComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCameraOrbitControlComponentSerializeHandler_mark, LNCameraOrbitControlComponentSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNCameraOrbitControlComponentSerializeHandler_OnSerialize_ProcCaller(LNHandle cameraorbitcontrolcomponentserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_CameraOrbitControlComponentSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(cameraorbitcontrolcomponentserializehandler), Wrap_CameraOrbitControlComponentSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNCameraOrbitControlComponentSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_CameraOrbitControlComponentSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_CameraOrbitControlComponentSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNCameraOrbitControlComponentSerializeHandler_Create(Wrap_LNCameraOrbitControlComponentSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "CameraOrbitControlComponentSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// RaycasterSerializeHandler

struct Wrap_RaycasterSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_RaycasterSerializeHandler()
    {}
};

static void LNRaycasterSerializeHandler_delete(Wrap_RaycasterSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNRaycasterSerializeHandler_mark(Wrap_RaycasterSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNRaycasterSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_RaycasterSerializeHandler* internalObj;

    internalObj = new Wrap_RaycasterSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNRaycasterSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNRaycasterSerializeHandler_mark, LNRaycasterSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNRaycasterSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_RaycasterSerializeHandler* internalObj;

    internalObj = new Wrap_RaycasterSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNRaycasterSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNRaycasterSerializeHandler_mark, LNRaycasterSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNRaycasterSerializeHandler_OnSerialize_ProcCaller(LNHandle raycasterserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_RaycasterSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(raycasterserializehandler), Wrap_RaycasterSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNRaycasterSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_RaycasterSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_RaycasterSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNRaycasterSerializeHandler_Create(Wrap_LNRaycasterSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "RaycasterSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// RaycastResultSerializeHandler

struct Wrap_RaycastResultSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_RaycastResultSerializeHandler()
    {}
};

static void LNRaycastResultSerializeHandler_delete(Wrap_RaycastResultSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNRaycastResultSerializeHandler_mark(Wrap_RaycastResultSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNRaycastResultSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_RaycastResultSerializeHandler* internalObj;

    internalObj = new Wrap_RaycastResultSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNRaycastResultSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNRaycastResultSerializeHandler_mark, LNRaycastResultSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNRaycastResultSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_RaycastResultSerializeHandler* internalObj;

    internalObj = new Wrap_RaycastResultSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNRaycastResultSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNRaycastResultSerializeHandler_mark, LNRaycastResultSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNRaycastResultSerializeHandler_OnSerialize_ProcCaller(LNHandle raycastresultserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_RaycastResultSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(raycastresultserializehandler), Wrap_RaycastResultSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNRaycastResultSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_RaycastResultSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_RaycastResultSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNRaycastResultSerializeHandler_Create(Wrap_LNRaycastResultSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "RaycastResultSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// WorldRenderViewSerializeHandler

struct Wrap_WorldRenderViewSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_WorldRenderViewSerializeHandler()
    {}
};

static void LNWorldRenderViewSerializeHandler_delete(Wrap_WorldRenderViewSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNWorldRenderViewSerializeHandler_mark(Wrap_WorldRenderViewSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNWorldRenderViewSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_WorldRenderViewSerializeHandler* internalObj;

    internalObj = new Wrap_WorldRenderViewSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldRenderViewSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldRenderViewSerializeHandler_mark, LNWorldRenderViewSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNWorldRenderViewSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_WorldRenderViewSerializeHandler* internalObj;

    internalObj = new Wrap_WorldRenderViewSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNWorldRenderViewSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNWorldRenderViewSerializeHandler_mark, LNWorldRenderViewSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNWorldRenderViewSerializeHandler_OnSerialize_ProcCaller(LNHandle worldrenderviewserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_WorldRenderViewSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(worldrenderviewserializehandler), Wrap_WorldRenderViewSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNWorldRenderViewSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_WorldRenderViewSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_WorldRenderViewSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNWorldRenderViewSerializeHandler_Create(Wrap_LNWorldRenderViewSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "WorldRenderViewSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// BoxMeshSerializeHandler

struct Wrap_BoxMeshSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_BoxMeshSerializeHandler()
    {}
};

static void LNBoxMeshSerializeHandler_delete(Wrap_BoxMeshSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNBoxMeshSerializeHandler_mark(Wrap_BoxMeshSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNBoxMeshSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_BoxMeshSerializeHandler* internalObj;

    internalObj = new Wrap_BoxMeshSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNBoxMeshSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNBoxMeshSerializeHandler_mark, LNBoxMeshSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNBoxMeshSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_BoxMeshSerializeHandler* internalObj;

    internalObj = new Wrap_BoxMeshSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNBoxMeshSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNBoxMeshSerializeHandler_mark, LNBoxMeshSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNBoxMeshSerializeHandler_OnSerialize_ProcCaller(LNHandle boxmeshserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_BoxMeshSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(boxmeshserializehandler), Wrap_BoxMeshSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNBoxMeshSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_BoxMeshSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_BoxMeshSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNBoxMeshSerializeHandler_Create(Wrap_LNBoxMeshSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "BoxMeshSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// BoxMeshPreUpdateHandler

struct Wrap_BoxMeshPreUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_BoxMeshPreUpdateHandler()
    {}
};

static void LNBoxMeshPreUpdateHandler_delete(Wrap_BoxMeshPreUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNBoxMeshPreUpdateHandler_mark(Wrap_BoxMeshPreUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNBoxMeshPreUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_BoxMeshPreUpdateHandler* internalObj;

    internalObj = new Wrap_BoxMeshPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNBoxMeshPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNBoxMeshPreUpdateHandler_mark, LNBoxMeshPreUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNBoxMeshPreUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_BoxMeshPreUpdateHandler* internalObj;

    internalObj = new Wrap_BoxMeshPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNBoxMeshPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNBoxMeshPreUpdateHandler_mark, LNBoxMeshPreUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNBoxMeshPreUpdateHandler_OnPreUpdate_ProcCaller(LNHandle boxmeshpreupdatehandler, LNHandle self)
{
    Wrap_BoxMeshPreUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(boxmeshpreupdatehandler), Wrap_BoxMeshPreUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNBoxMeshPreUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_BoxMeshPreUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_BoxMeshPreUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNBoxMeshPreUpdateHandler_Create(Wrap_LNBoxMeshPreUpdateHandler_OnPreUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "BoxMeshPreUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// BoxMeshUpdateHandler

struct Wrap_BoxMeshUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_BoxMeshUpdateHandler()
    {}
};

static void LNBoxMeshUpdateHandler_delete(Wrap_BoxMeshUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNBoxMeshUpdateHandler_mark(Wrap_BoxMeshUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNBoxMeshUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_BoxMeshUpdateHandler* internalObj;

    internalObj = new Wrap_BoxMeshUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNBoxMeshUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNBoxMeshUpdateHandler_mark, LNBoxMeshUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNBoxMeshUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_BoxMeshUpdateHandler* internalObj;

    internalObj = new Wrap_BoxMeshUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNBoxMeshUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNBoxMeshUpdateHandler_mark, LNBoxMeshUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNBoxMeshUpdateHandler_OnUpdate_ProcCaller(LNHandle boxmeshupdatehandler, LNHandle self, float elapsedSeconds)
{
    Wrap_BoxMeshUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(boxmeshupdatehandler), Wrap_BoxMeshUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNBoxMeshUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_BoxMeshUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_BoxMeshUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNBoxMeshUpdateHandler_Create(Wrap_LNBoxMeshUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "BoxMeshUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// PlaneMeshSerializeHandler

struct Wrap_PlaneMeshSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_PlaneMeshSerializeHandler()
    {}
};

static void LNPlaneMeshSerializeHandler_delete(Wrap_PlaneMeshSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNPlaneMeshSerializeHandler_mark(Wrap_PlaneMeshSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNPlaneMeshSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_PlaneMeshSerializeHandler* internalObj;

    internalObj = new Wrap_PlaneMeshSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPlaneMeshSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNPlaneMeshSerializeHandler_mark, LNPlaneMeshSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNPlaneMeshSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_PlaneMeshSerializeHandler* internalObj;

    internalObj = new Wrap_PlaneMeshSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPlaneMeshSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNPlaneMeshSerializeHandler_mark, LNPlaneMeshSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNPlaneMeshSerializeHandler_OnSerialize_ProcCaller(LNHandle planemeshserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_PlaneMeshSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(planemeshserializehandler), Wrap_PlaneMeshSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNPlaneMeshSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_PlaneMeshSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_PlaneMeshSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNPlaneMeshSerializeHandler_Create(Wrap_LNPlaneMeshSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "PlaneMeshSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// PlaneMeshPreUpdateHandler

struct Wrap_PlaneMeshPreUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_PlaneMeshPreUpdateHandler()
    {}
};

static void LNPlaneMeshPreUpdateHandler_delete(Wrap_PlaneMeshPreUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNPlaneMeshPreUpdateHandler_mark(Wrap_PlaneMeshPreUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNPlaneMeshPreUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_PlaneMeshPreUpdateHandler* internalObj;

    internalObj = new Wrap_PlaneMeshPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPlaneMeshPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNPlaneMeshPreUpdateHandler_mark, LNPlaneMeshPreUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNPlaneMeshPreUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_PlaneMeshPreUpdateHandler* internalObj;

    internalObj = new Wrap_PlaneMeshPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPlaneMeshPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNPlaneMeshPreUpdateHandler_mark, LNPlaneMeshPreUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNPlaneMeshPreUpdateHandler_OnPreUpdate_ProcCaller(LNHandle planemeshpreupdatehandler, LNHandle self)
{
    Wrap_PlaneMeshPreUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(planemeshpreupdatehandler), Wrap_PlaneMeshPreUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNPlaneMeshPreUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_PlaneMeshPreUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_PlaneMeshPreUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNPlaneMeshPreUpdateHandler_Create(Wrap_LNPlaneMeshPreUpdateHandler_OnPreUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "PlaneMeshPreUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// PlaneMeshUpdateHandler

struct Wrap_PlaneMeshUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_PlaneMeshUpdateHandler()
    {}
};

static void LNPlaneMeshUpdateHandler_delete(Wrap_PlaneMeshUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNPlaneMeshUpdateHandler_mark(Wrap_PlaneMeshUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNPlaneMeshUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_PlaneMeshUpdateHandler* internalObj;

    internalObj = new Wrap_PlaneMeshUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPlaneMeshUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNPlaneMeshUpdateHandler_mark, LNPlaneMeshUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNPlaneMeshUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_PlaneMeshUpdateHandler* internalObj;

    internalObj = new Wrap_PlaneMeshUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNPlaneMeshUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNPlaneMeshUpdateHandler_mark, LNPlaneMeshUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNPlaneMeshUpdateHandler_OnUpdate_ProcCaller(LNHandle planemeshupdatehandler, LNHandle self, float elapsedSeconds)
{
    Wrap_PlaneMeshUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(planemeshupdatehandler), Wrap_PlaneMeshUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNPlaneMeshUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_PlaneMeshUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_PlaneMeshUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNPlaneMeshUpdateHandler_Create(Wrap_LNPlaneMeshUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "PlaneMeshUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// StaticMeshSerializeHandler

struct Wrap_StaticMeshSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_StaticMeshSerializeHandler()
    {}
};

static void LNStaticMeshSerializeHandler_delete(Wrap_StaticMeshSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNStaticMeshSerializeHandler_mark(Wrap_StaticMeshSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNStaticMeshSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_StaticMeshSerializeHandler* internalObj;

    internalObj = new Wrap_StaticMeshSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNStaticMeshSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNStaticMeshSerializeHandler_mark, LNStaticMeshSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNStaticMeshSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_StaticMeshSerializeHandler* internalObj;

    internalObj = new Wrap_StaticMeshSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNStaticMeshSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNStaticMeshSerializeHandler_mark, LNStaticMeshSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNStaticMeshSerializeHandler_OnSerialize_ProcCaller(LNHandle staticmeshserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_StaticMeshSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(staticmeshserializehandler), Wrap_StaticMeshSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNStaticMeshSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_StaticMeshSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_StaticMeshSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNStaticMeshSerializeHandler_Create(Wrap_LNStaticMeshSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "StaticMeshSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// StaticMeshPreUpdateHandler

struct Wrap_StaticMeshPreUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_StaticMeshPreUpdateHandler()
    {}
};

static void LNStaticMeshPreUpdateHandler_delete(Wrap_StaticMeshPreUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNStaticMeshPreUpdateHandler_mark(Wrap_StaticMeshPreUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNStaticMeshPreUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_StaticMeshPreUpdateHandler* internalObj;

    internalObj = new Wrap_StaticMeshPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNStaticMeshPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNStaticMeshPreUpdateHandler_mark, LNStaticMeshPreUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNStaticMeshPreUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_StaticMeshPreUpdateHandler* internalObj;

    internalObj = new Wrap_StaticMeshPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNStaticMeshPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNStaticMeshPreUpdateHandler_mark, LNStaticMeshPreUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNStaticMeshPreUpdateHandler_OnPreUpdate_ProcCaller(LNHandle staticmeshpreupdatehandler, LNHandle self)
{
    Wrap_StaticMeshPreUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(staticmeshpreupdatehandler), Wrap_StaticMeshPreUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNStaticMeshPreUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_StaticMeshPreUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_StaticMeshPreUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNStaticMeshPreUpdateHandler_Create(Wrap_LNStaticMeshPreUpdateHandler_OnPreUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "StaticMeshPreUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// StaticMeshUpdateHandler

struct Wrap_StaticMeshUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_StaticMeshUpdateHandler()
    {}
};

static void LNStaticMeshUpdateHandler_delete(Wrap_StaticMeshUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNStaticMeshUpdateHandler_mark(Wrap_StaticMeshUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNStaticMeshUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_StaticMeshUpdateHandler* internalObj;

    internalObj = new Wrap_StaticMeshUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNStaticMeshUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNStaticMeshUpdateHandler_mark, LNStaticMeshUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNStaticMeshUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_StaticMeshUpdateHandler* internalObj;

    internalObj = new Wrap_StaticMeshUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNStaticMeshUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNStaticMeshUpdateHandler_mark, LNStaticMeshUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNStaticMeshUpdateHandler_OnUpdate_ProcCaller(LNHandle staticmeshupdatehandler, LNHandle self, float elapsedSeconds)
{
    Wrap_StaticMeshUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(staticmeshupdatehandler), Wrap_StaticMeshUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNStaticMeshUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_StaticMeshUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_StaticMeshUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNStaticMeshUpdateHandler_Create(Wrap_LNStaticMeshUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "StaticMeshUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// StaticMeshComponentSerializeHandler

struct Wrap_StaticMeshComponentSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_StaticMeshComponentSerializeHandler()
    {}
};

static void LNStaticMeshComponentSerializeHandler_delete(Wrap_StaticMeshComponentSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNStaticMeshComponentSerializeHandler_mark(Wrap_StaticMeshComponentSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNStaticMeshComponentSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_StaticMeshComponentSerializeHandler* internalObj;

    internalObj = new Wrap_StaticMeshComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNStaticMeshComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNStaticMeshComponentSerializeHandler_mark, LNStaticMeshComponentSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNStaticMeshComponentSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_StaticMeshComponentSerializeHandler* internalObj;

    internalObj = new Wrap_StaticMeshComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNStaticMeshComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNStaticMeshComponentSerializeHandler_mark, LNStaticMeshComponentSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNStaticMeshComponentSerializeHandler_OnSerialize_ProcCaller(LNHandle staticmeshcomponentserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_StaticMeshComponentSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(staticmeshcomponentserializehandler), Wrap_StaticMeshComponentSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNStaticMeshComponentSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_StaticMeshComponentSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_StaticMeshComponentSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNStaticMeshComponentSerializeHandler_Create(Wrap_LNStaticMeshComponentSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "StaticMeshComponentSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// SkinnedMeshComponentSerializeHandler

struct Wrap_SkinnedMeshComponentSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_SkinnedMeshComponentSerializeHandler()
    {}
};

static void LNSkinnedMeshComponentSerializeHandler_delete(Wrap_SkinnedMeshComponentSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNSkinnedMeshComponentSerializeHandler_mark(Wrap_SkinnedMeshComponentSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNSkinnedMeshComponentSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_SkinnedMeshComponentSerializeHandler* internalObj;

    internalObj = new Wrap_SkinnedMeshComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSkinnedMeshComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSkinnedMeshComponentSerializeHandler_mark, LNSkinnedMeshComponentSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNSkinnedMeshComponentSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_SkinnedMeshComponentSerializeHandler* internalObj;

    internalObj = new Wrap_SkinnedMeshComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNSkinnedMeshComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNSkinnedMeshComponentSerializeHandler_mark, LNSkinnedMeshComponentSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNSkinnedMeshComponentSerializeHandler_OnSerialize_ProcCaller(LNHandle skinnedmeshcomponentserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_SkinnedMeshComponentSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(skinnedmeshcomponentserializehandler), Wrap_SkinnedMeshComponentSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNSkinnedMeshComponentSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_SkinnedMeshComponentSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_SkinnedMeshComponentSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNSkinnedMeshComponentSerializeHandler_Create(Wrap_LNSkinnedMeshComponentSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "SkinnedMeshComponentSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// CollisionSerializeHandler

struct Wrap_CollisionSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_CollisionSerializeHandler()
    {}
};

static void LNCollisionSerializeHandler_delete(Wrap_CollisionSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNCollisionSerializeHandler_mark(Wrap_CollisionSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNCollisionSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_CollisionSerializeHandler* internalObj;

    internalObj = new Wrap_CollisionSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCollisionSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCollisionSerializeHandler_mark, LNCollisionSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNCollisionSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_CollisionSerializeHandler* internalObj;

    internalObj = new Wrap_CollisionSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNCollisionSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNCollisionSerializeHandler_mark, LNCollisionSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNCollisionSerializeHandler_OnSerialize_ProcCaller(LNHandle collisionserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_CollisionSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(collisionserializehandler), Wrap_CollisionSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNCollisionSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_CollisionSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_CollisionSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNCollisionSerializeHandler_Create(Wrap_LNCollisionSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "CollisionSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// TriggerBodyComponentSerializeHandler

struct Wrap_TriggerBodyComponentSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_TriggerBodyComponentSerializeHandler()
    {}
};

static void LNTriggerBodyComponentSerializeHandler_delete(Wrap_TriggerBodyComponentSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNTriggerBodyComponentSerializeHandler_mark(Wrap_TriggerBodyComponentSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNTriggerBodyComponentSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_TriggerBodyComponentSerializeHandler* internalObj;

    internalObj = new Wrap_TriggerBodyComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTriggerBodyComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNTriggerBodyComponentSerializeHandler_mark, LNTriggerBodyComponentSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNTriggerBodyComponentSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_TriggerBodyComponentSerializeHandler* internalObj;

    internalObj = new Wrap_TriggerBodyComponentSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNTriggerBodyComponentSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNTriggerBodyComponentSerializeHandler_mark, LNTriggerBodyComponentSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNTriggerBodyComponentSerializeHandler_OnSerialize_ProcCaller(LNHandle triggerbodycomponentserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_TriggerBodyComponentSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(triggerbodycomponentserializehandler), Wrap_TriggerBodyComponentSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNTriggerBodyComponentSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_TriggerBodyComponentSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_TriggerBodyComponentSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNTriggerBodyComponentSerializeHandler_Create(Wrap_LNTriggerBodyComponentSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "TriggerBodyComponentSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ParticleEmitterSerializeHandler

struct Wrap_ParticleEmitterSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ParticleEmitterSerializeHandler()
    {}
};

static void LNParticleEmitterSerializeHandler_delete(Wrap_ParticleEmitterSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNParticleEmitterSerializeHandler_mark(Wrap_ParticleEmitterSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNParticleEmitterSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ParticleEmitterSerializeHandler* internalObj;

    internalObj = new Wrap_ParticleEmitterSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleEmitterSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleEmitterSerializeHandler_mark, LNParticleEmitterSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNParticleEmitterSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ParticleEmitterSerializeHandler* internalObj;

    internalObj = new Wrap_ParticleEmitterSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleEmitterSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleEmitterSerializeHandler_mark, LNParticleEmitterSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNParticleEmitterSerializeHandler_OnSerialize_ProcCaller(LNHandle particleemitterserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_ParticleEmitterSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(particleemitterserializehandler), Wrap_ParticleEmitterSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNParticleEmitterSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNParticleEmitterSerializeHandler_Create(Wrap_LNParticleEmitterSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ParticleEmitterSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ParticleEmitterPreUpdateHandler

struct Wrap_ParticleEmitterPreUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ParticleEmitterPreUpdateHandler()
    {}
};

static void LNParticleEmitterPreUpdateHandler_delete(Wrap_ParticleEmitterPreUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNParticleEmitterPreUpdateHandler_mark(Wrap_ParticleEmitterPreUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNParticleEmitterPreUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ParticleEmitterPreUpdateHandler* internalObj;

    internalObj = new Wrap_ParticleEmitterPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleEmitterPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleEmitterPreUpdateHandler_mark, LNParticleEmitterPreUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNParticleEmitterPreUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ParticleEmitterPreUpdateHandler* internalObj;

    internalObj = new Wrap_ParticleEmitterPreUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleEmitterPreUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleEmitterPreUpdateHandler_mark, LNParticleEmitterPreUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNParticleEmitterPreUpdateHandler_OnPreUpdate_ProcCaller(LNHandle particleemitterpreupdatehandler, LNHandle self)
{
    Wrap_ParticleEmitterPreUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(particleemitterpreupdatehandler), Wrap_ParticleEmitterPreUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNParticleEmitterPreUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterPreUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterPreUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNParticleEmitterPreUpdateHandler_Create(Wrap_LNParticleEmitterPreUpdateHandler_OnPreUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ParticleEmitterPreUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ParticleEmitterUpdateHandler

struct Wrap_ParticleEmitterUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ParticleEmitterUpdateHandler()
    {}
};

static void LNParticleEmitterUpdateHandler_delete(Wrap_ParticleEmitterUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNParticleEmitterUpdateHandler_mark(Wrap_ParticleEmitterUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNParticleEmitterUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ParticleEmitterUpdateHandler* internalObj;

    internalObj = new Wrap_ParticleEmitterUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleEmitterUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleEmitterUpdateHandler_mark, LNParticleEmitterUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNParticleEmitterUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ParticleEmitterUpdateHandler* internalObj;

    internalObj = new Wrap_ParticleEmitterUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNParticleEmitterUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNParticleEmitterUpdateHandler_mark, LNParticleEmitterUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNParticleEmitterUpdateHandler_OnUpdate_ProcCaller(LNHandle particleemitterupdatehandler, LNHandle self, float elapsedSeconds)
{
    Wrap_ParticleEmitterUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(particleemitterupdatehandler), Wrap_ParticleEmitterUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNI_TO_RUBY_VALUE(elapsedSeconds));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNParticleEmitterUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ParticleEmitterUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_ParticleEmitterUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNParticleEmitterUpdateHandler_Create(Wrap_LNParticleEmitterUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ParticleEmitterUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// LevelSerializeHandler

struct Wrap_LevelSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_LevelSerializeHandler()
    {}
};

static void LNLevelSerializeHandler_delete(Wrap_LevelSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNLevelSerializeHandler_mark(Wrap_LevelSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNLevelSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_LevelSerializeHandler* internalObj;

    internalObj = new Wrap_LevelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNLevelSerializeHandler_mark, LNLevelSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNLevelSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_LevelSerializeHandler* internalObj;

    internalObj = new Wrap_LevelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNLevelSerializeHandler_mark, LNLevelSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNLevelSerializeHandler_OnSerialize_ProcCaller(LNHandle levelserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_LevelSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(levelserializehandler), Wrap_LevelSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNLevelSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_LevelSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_LevelSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNLevelSerializeHandler_Create(Wrap_LNLevelSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "LevelSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// LevelStartHandler

struct Wrap_LevelStartHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_LevelStartHandler()
    {}
};

static void LNLevelStartHandler_delete(Wrap_LevelStartHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNLevelStartHandler_mark(Wrap_LevelStartHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNLevelStartHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_LevelStartHandler* internalObj;

    internalObj = new Wrap_LevelStartHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevelStartHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNLevelStartHandler_mark, LNLevelStartHandler_delete, internalObj);

    return obj;
}

static VALUE LNLevelStartHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_LevelStartHandler* internalObj;

    internalObj = new Wrap_LevelStartHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevelStartHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNLevelStartHandler_mark, LNLevelStartHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNLevelStartHandler_OnStart_ProcCaller(LNHandle levelstarthandler, LNHandle self)
{
    Wrap_LevelStartHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(levelstarthandler), Wrap_LevelStartHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNLevelStartHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_LevelStartHandler* selfObj;
    Data_Get_Struct(self, Wrap_LevelStartHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNLevelStartHandler_Create(Wrap_LNLevelStartHandler_OnStart_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "LevelStartHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// LevelStopHandler

struct Wrap_LevelStopHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_LevelStopHandler()
    {}
};

static void LNLevelStopHandler_delete(Wrap_LevelStopHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNLevelStopHandler_mark(Wrap_LevelStopHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNLevelStopHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_LevelStopHandler* internalObj;

    internalObj = new Wrap_LevelStopHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevelStopHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNLevelStopHandler_mark, LNLevelStopHandler_delete, internalObj);

    return obj;
}

static VALUE LNLevelStopHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_LevelStopHandler* internalObj;

    internalObj = new Wrap_LevelStopHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevelStopHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNLevelStopHandler_mark, LNLevelStopHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNLevelStopHandler_OnStop_ProcCaller(LNHandle levelstophandler, LNHandle self)
{
    Wrap_LevelStopHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(levelstophandler), Wrap_LevelStopHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNLevelStopHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_LevelStopHandler* selfObj;
    Data_Get_Struct(self, Wrap_LevelStopHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNLevelStopHandler_Create(Wrap_LNLevelStopHandler_OnStop_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "LevelStopHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// LevelPauseHandler

struct Wrap_LevelPauseHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_LevelPauseHandler()
    {}
};

static void LNLevelPauseHandler_delete(Wrap_LevelPauseHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNLevelPauseHandler_mark(Wrap_LevelPauseHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNLevelPauseHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_LevelPauseHandler* internalObj;

    internalObj = new Wrap_LevelPauseHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevelPauseHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNLevelPauseHandler_mark, LNLevelPauseHandler_delete, internalObj);

    return obj;
}

static VALUE LNLevelPauseHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_LevelPauseHandler* internalObj;

    internalObj = new Wrap_LevelPauseHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevelPauseHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNLevelPauseHandler_mark, LNLevelPauseHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNLevelPauseHandler_OnPause_ProcCaller(LNHandle levelpausehandler, LNHandle self)
{
    Wrap_LevelPauseHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(levelpausehandler), Wrap_LevelPauseHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNLevelPauseHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_LevelPauseHandler* selfObj;
    Data_Get_Struct(self, Wrap_LevelPauseHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNLevelPauseHandler_Create(Wrap_LNLevelPauseHandler_OnPause_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "LevelPauseHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// LevelResumeHandler

struct Wrap_LevelResumeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_LevelResumeHandler()
    {}
};

static void LNLevelResumeHandler_delete(Wrap_LevelResumeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNLevelResumeHandler_mark(Wrap_LevelResumeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNLevelResumeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_LevelResumeHandler* internalObj;

    internalObj = new Wrap_LevelResumeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevelResumeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNLevelResumeHandler_mark, LNLevelResumeHandler_delete, internalObj);

    return obj;
}

static VALUE LNLevelResumeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_LevelResumeHandler* internalObj;

    internalObj = new Wrap_LevelResumeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevelResumeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNLevelResumeHandler_mark, LNLevelResumeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNLevelResumeHandler_OnResume_ProcCaller(LNHandle levelresumehandler, LNHandle self)
{
    Wrap_LevelResumeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(levelresumehandler), Wrap_LevelResumeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNLevelResumeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_LevelResumeHandler* selfObj;
    Data_Get_Struct(self, Wrap_LevelResumeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNLevelResumeHandler_Create(Wrap_LNLevelResumeHandler_OnResume_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "LevelResumeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// LevelUpdateHandler

struct Wrap_LevelUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_LevelUpdateHandler()
    {}
};

static void LNLevelUpdateHandler_delete(Wrap_LevelUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNLevelUpdateHandler_mark(Wrap_LevelUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNLevelUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_LevelUpdateHandler* internalObj;

    internalObj = new Wrap_LevelUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevelUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNLevelUpdateHandler_mark, LNLevelUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNLevelUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_LevelUpdateHandler* internalObj;

    internalObj = new Wrap_LevelUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNLevelUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNLevelUpdateHandler_mark, LNLevelUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNLevelUpdateHandler_OnUpdate_ProcCaller(LNHandle levelupdatehandler, LNHandle self)
{
    Wrap_LevelUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(levelupdatehandler), Wrap_LevelUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNLevelUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_LevelUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_LevelUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNLevelUpdateHandler_Create(Wrap_LNLevelUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "LevelUpdateHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIEventArgsSerializeHandler

struct Wrap_UIEventArgsSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIEventArgsSerializeHandler()
    {}
};

static void LNUIEventArgsSerializeHandler_delete(Wrap_UIEventArgsSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIEventArgsSerializeHandler_mark(Wrap_UIEventArgsSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIEventArgsSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIEventArgsSerializeHandler* internalObj;

    internalObj = new Wrap_UIEventArgsSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIEventArgsSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIEventArgsSerializeHandler_mark, LNUIEventArgsSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIEventArgsSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIEventArgsSerializeHandler* internalObj;

    internalObj = new Wrap_UIEventArgsSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIEventArgsSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIEventArgsSerializeHandler_mark, LNUIEventArgsSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIEventArgsSerializeHandler_OnSerialize_ProcCaller(LNHandle uieventargsserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIEventArgsSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uieventargsserializehandler), Wrap_UIEventArgsSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIEventArgsSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIEventArgsSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIEventArgsSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIEventArgsSerializeHandler_Create(Wrap_LNUIEventArgsSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIEventArgsSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UILayoutElementSerializeHandler

struct Wrap_UILayoutElementSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UILayoutElementSerializeHandler()
    {}
};

static void LNUILayoutElementSerializeHandler_delete(Wrap_UILayoutElementSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUILayoutElementSerializeHandler_mark(Wrap_UILayoutElementSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUILayoutElementSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UILayoutElementSerializeHandler* internalObj;

    internalObj = new Wrap_UILayoutElementSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUILayoutElementSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUILayoutElementSerializeHandler_mark, LNUILayoutElementSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUILayoutElementSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UILayoutElementSerializeHandler* internalObj;

    internalObj = new Wrap_UILayoutElementSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUILayoutElementSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUILayoutElementSerializeHandler_mark, LNUILayoutElementSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUILayoutElementSerializeHandler_OnSerialize_ProcCaller(LNHandle uilayoutelementserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UILayoutElementSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uilayoutelementserializehandler), Wrap_UILayoutElementSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUILayoutElementSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UILayoutElementSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UILayoutElementSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUILayoutElementSerializeHandler_Create(Wrap_LNUILayoutElementSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UILayoutElementSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIElementSerializeHandler

struct Wrap_UIElementSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIElementSerializeHandler()
    {}
};

static void LNUIElementSerializeHandler_delete(Wrap_UIElementSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIElementSerializeHandler_mark(Wrap_UIElementSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIElementSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIElementSerializeHandler* internalObj;

    internalObj = new Wrap_UIElementSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIElementSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIElementSerializeHandler_mark, LNUIElementSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIElementSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIElementSerializeHandler* internalObj;

    internalObj = new Wrap_UIElementSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIElementSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIElementSerializeHandler_mark, LNUIElementSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIElementSerializeHandler_OnSerialize_ProcCaller(LNHandle uielementserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIElementSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uielementserializehandler), Wrap_UIElementSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIElementSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIElementSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIElementSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIElementSerializeHandler_Create(Wrap_LNUIElementSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIElementSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UITextBlockSerializeHandler

struct Wrap_UITextBlockSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UITextBlockSerializeHandler()
    {}
};

static void LNUITextBlockSerializeHandler_delete(Wrap_UITextBlockSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUITextBlockSerializeHandler_mark(Wrap_UITextBlockSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUITextBlockSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UITextBlockSerializeHandler* internalObj;

    internalObj = new Wrap_UITextBlockSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUITextBlockSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUITextBlockSerializeHandler_mark, LNUITextBlockSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUITextBlockSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UITextBlockSerializeHandler* internalObj;

    internalObj = new Wrap_UITextBlockSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUITextBlockSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUITextBlockSerializeHandler_mark, LNUITextBlockSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUITextBlockSerializeHandler_OnSerialize_ProcCaller(LNHandle uitextblockserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UITextBlockSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uitextblockserializehandler), Wrap_UITextBlockSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUITextBlockSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UITextBlockSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UITextBlockSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUITextBlockSerializeHandler_Create(Wrap_LNUITextBlockSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UITextBlockSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UISpriteSerializeHandler

struct Wrap_UISpriteSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UISpriteSerializeHandler()
    {}
};

static void LNUISpriteSerializeHandler_delete(Wrap_UISpriteSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUISpriteSerializeHandler_mark(Wrap_UISpriteSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUISpriteSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UISpriteSerializeHandler* internalObj;

    internalObj = new Wrap_UISpriteSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUISpriteSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUISpriteSerializeHandler_mark, LNUISpriteSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUISpriteSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UISpriteSerializeHandler* internalObj;

    internalObj = new Wrap_UISpriteSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUISpriteSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUISpriteSerializeHandler_mark, LNUISpriteSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUISpriteSerializeHandler_OnSerialize_ProcCaller(LNHandle uispriteserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UISpriteSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uispriteserializehandler), Wrap_UISpriteSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUISpriteSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UISpriteSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UISpriteSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUISpriteSerializeHandler_Create(Wrap_LNUISpriteSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UISpriteSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIIconSerializeHandler

struct Wrap_UIIconSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIIconSerializeHandler()
    {}
};

static void LNUIIconSerializeHandler_delete(Wrap_UIIconSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIIconSerializeHandler_mark(Wrap_UIIconSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIIconSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIIconSerializeHandler* internalObj;

    internalObj = new Wrap_UIIconSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIIconSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIIconSerializeHandler_mark, LNUIIconSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIIconSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIIconSerializeHandler* internalObj;

    internalObj = new Wrap_UIIconSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIIconSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIIconSerializeHandler_mark, LNUIIconSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIIconSerializeHandler_OnSerialize_ProcCaller(LNHandle uiiconserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIIconSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uiiconserializehandler), Wrap_UIIconSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIIconSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIIconSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIIconSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIIconSerializeHandler_Create(Wrap_LNUIIconSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIIconSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIMessageTextAreaSerializeHandler

struct Wrap_UIMessageTextAreaSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIMessageTextAreaSerializeHandler()
    {}
};

static void LNUIMessageTextAreaSerializeHandler_delete(Wrap_UIMessageTextAreaSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIMessageTextAreaSerializeHandler_mark(Wrap_UIMessageTextAreaSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIMessageTextAreaSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIMessageTextAreaSerializeHandler* internalObj;

    internalObj = new Wrap_UIMessageTextAreaSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIMessageTextAreaSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIMessageTextAreaSerializeHandler_mark, LNUIMessageTextAreaSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIMessageTextAreaSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIMessageTextAreaSerializeHandler* internalObj;

    internalObj = new Wrap_UIMessageTextAreaSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIMessageTextAreaSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIMessageTextAreaSerializeHandler_mark, LNUIMessageTextAreaSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIMessageTextAreaSerializeHandler_OnSerialize_ProcCaller(LNHandle uimessagetextareaserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIMessageTextAreaSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uimessagetextareaserializehandler), Wrap_UIMessageTextAreaSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIMessageTextAreaSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIMessageTextAreaSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIMessageTextAreaSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIMessageTextAreaSerializeHandler_Create(Wrap_LNUIMessageTextAreaSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIMessageTextAreaSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UILayoutPanelSerializeHandler

struct Wrap_UILayoutPanelSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UILayoutPanelSerializeHandler()
    {}
};

static void LNUILayoutPanelSerializeHandler_delete(Wrap_UILayoutPanelSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUILayoutPanelSerializeHandler_mark(Wrap_UILayoutPanelSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUILayoutPanelSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UILayoutPanelSerializeHandler* internalObj;

    internalObj = new Wrap_UILayoutPanelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUILayoutPanelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUILayoutPanelSerializeHandler_mark, LNUILayoutPanelSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUILayoutPanelSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UILayoutPanelSerializeHandler* internalObj;

    internalObj = new Wrap_UILayoutPanelSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUILayoutPanelSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUILayoutPanelSerializeHandler_mark, LNUILayoutPanelSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUILayoutPanelSerializeHandler_OnSerialize_ProcCaller(LNHandle uilayoutpanelserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UILayoutPanelSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uilayoutpanelserializehandler), Wrap_UILayoutPanelSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUILayoutPanelSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UILayoutPanelSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UILayoutPanelSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUILayoutPanelSerializeHandler_Create(Wrap_LNUILayoutPanelSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UILayoutPanelSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIBoxLayoutSerializeHandler

struct Wrap_UIBoxLayoutSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIBoxLayoutSerializeHandler()
    {}
};

static void LNUIBoxLayoutSerializeHandler_delete(Wrap_UIBoxLayoutSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIBoxLayoutSerializeHandler_mark(Wrap_UIBoxLayoutSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIBoxLayoutSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIBoxLayoutSerializeHandler* internalObj;

    internalObj = new Wrap_UIBoxLayoutSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIBoxLayoutSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIBoxLayoutSerializeHandler_mark, LNUIBoxLayoutSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIBoxLayoutSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIBoxLayoutSerializeHandler* internalObj;

    internalObj = new Wrap_UIBoxLayoutSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIBoxLayoutSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIBoxLayoutSerializeHandler_mark, LNUIBoxLayoutSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIBoxLayoutSerializeHandler_OnSerialize_ProcCaller(LNHandle uiboxlayoutserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIBoxLayoutSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uiboxlayoutserializehandler), Wrap_UIBoxLayoutSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIBoxLayoutSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIBoxLayoutSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIBoxLayoutSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIBoxLayoutSerializeHandler_Create(Wrap_LNUIBoxLayoutSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIBoxLayoutSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIStackLayoutSerializeHandler

struct Wrap_UIStackLayoutSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIStackLayoutSerializeHandler()
    {}
};

static void LNUIStackLayoutSerializeHandler_delete(Wrap_UIStackLayoutSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIStackLayoutSerializeHandler_mark(Wrap_UIStackLayoutSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIStackLayoutSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIStackLayoutSerializeHandler* internalObj;

    internalObj = new Wrap_UIStackLayoutSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIStackLayoutSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIStackLayoutSerializeHandler_mark, LNUIStackLayoutSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIStackLayoutSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIStackLayoutSerializeHandler* internalObj;

    internalObj = new Wrap_UIStackLayoutSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIStackLayoutSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIStackLayoutSerializeHandler_mark, LNUIStackLayoutSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIStackLayoutSerializeHandler_OnSerialize_ProcCaller(LNHandle uistacklayoutserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIStackLayoutSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uistacklayoutserializehandler), Wrap_UIStackLayoutSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIStackLayoutSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIStackLayoutSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIStackLayoutSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIStackLayoutSerializeHandler_Create(Wrap_LNUIStackLayoutSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIStackLayoutSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIGridLayoutSerializeHandler

struct Wrap_UIGridLayoutSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIGridLayoutSerializeHandler()
    {}
};

static void LNUIGridLayoutSerializeHandler_delete(Wrap_UIGridLayoutSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIGridLayoutSerializeHandler_mark(Wrap_UIGridLayoutSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIGridLayoutSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIGridLayoutSerializeHandler* internalObj;

    internalObj = new Wrap_UIGridLayoutSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIGridLayoutSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIGridLayoutSerializeHandler_mark, LNUIGridLayoutSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIGridLayoutSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIGridLayoutSerializeHandler* internalObj;

    internalObj = new Wrap_UIGridLayoutSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIGridLayoutSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIGridLayoutSerializeHandler_mark, LNUIGridLayoutSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIGridLayoutSerializeHandler_OnSerialize_ProcCaller(LNHandle uigridlayoutserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIGridLayoutSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uigridlayoutserializehandler), Wrap_UIGridLayoutSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIGridLayoutSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIGridLayoutSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIGridLayoutSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIGridLayoutSerializeHandler_Create(Wrap_LNUIGridLayoutSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIGridLayoutSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIControlSerializeHandler

struct Wrap_UIControlSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIControlSerializeHandler()
    {}
};

static void LNUIControlSerializeHandler_delete(Wrap_UIControlSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIControlSerializeHandler_mark(Wrap_UIControlSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIControlSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIControlSerializeHandler* internalObj;

    internalObj = new Wrap_UIControlSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIControlSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIControlSerializeHandler_mark, LNUIControlSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIControlSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIControlSerializeHandler* internalObj;

    internalObj = new Wrap_UIControlSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIControlSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIControlSerializeHandler_mark, LNUIControlSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIControlSerializeHandler_OnSerialize_ProcCaller(LNHandle uicontrolserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIControlSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uicontrolserializehandler), Wrap_UIControlSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIControlSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIControlSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIControlSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIControlSerializeHandler_Create(Wrap_LNUIControlSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIControlSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIButtonBaseSerializeHandler

struct Wrap_UIButtonBaseSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIButtonBaseSerializeHandler()
    {}
};

static void LNUIButtonBaseSerializeHandler_delete(Wrap_UIButtonBaseSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIButtonBaseSerializeHandler_mark(Wrap_UIButtonBaseSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIButtonBaseSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIButtonBaseSerializeHandler* internalObj;

    internalObj = new Wrap_UIButtonBaseSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIButtonBaseSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIButtonBaseSerializeHandler_mark, LNUIButtonBaseSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIButtonBaseSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIButtonBaseSerializeHandler* internalObj;

    internalObj = new Wrap_UIButtonBaseSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIButtonBaseSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIButtonBaseSerializeHandler_mark, LNUIButtonBaseSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIButtonBaseSerializeHandler_OnSerialize_ProcCaller(LNHandle uibuttonbaseserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIButtonBaseSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uibuttonbaseserializehandler), Wrap_UIButtonBaseSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIButtonBaseSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIButtonBaseSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIButtonBaseSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIButtonBaseSerializeHandler_Create(Wrap_LNUIButtonBaseSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIButtonBaseSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIButtonSerializeHandler

struct Wrap_UIButtonSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIButtonSerializeHandler()
    {}
};

static void LNUIButtonSerializeHandler_delete(Wrap_UIButtonSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIButtonSerializeHandler_mark(Wrap_UIButtonSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIButtonSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIButtonSerializeHandler* internalObj;

    internalObj = new Wrap_UIButtonSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIButtonSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIButtonSerializeHandler_mark, LNUIButtonSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIButtonSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIButtonSerializeHandler* internalObj;

    internalObj = new Wrap_UIButtonSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIButtonSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIButtonSerializeHandler_mark, LNUIButtonSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIButtonSerializeHandler_OnSerialize_ProcCaller(LNHandle uibuttonserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIButtonSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uibuttonserializehandler), Wrap_UIButtonSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIButtonSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIButtonSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIButtonSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIButtonSerializeHandler_Create(Wrap_LNUIButtonSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIButtonSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIWindowSerializeHandler

struct Wrap_UIWindowSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIWindowSerializeHandler()
    {}
};

static void LNUIWindowSerializeHandler_delete(Wrap_UIWindowSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIWindowSerializeHandler_mark(Wrap_UIWindowSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIWindowSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIWindowSerializeHandler* internalObj;

    internalObj = new Wrap_UIWindowSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIWindowSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIWindowSerializeHandler_mark, LNUIWindowSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIWindowSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIWindowSerializeHandler* internalObj;

    internalObj = new Wrap_UIWindowSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIWindowSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIWindowSerializeHandler_mark, LNUIWindowSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIWindowSerializeHandler_OnSerialize_ProcCaller(LNHandle uiwindowserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIWindowSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uiwindowserializehandler), Wrap_UIWindowSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIWindowSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIWindowSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIWindowSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIWindowSerializeHandler_Create(Wrap_LNUIWindowSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIWindowSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIListItemSerializeHandler

struct Wrap_UIListItemSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIListItemSerializeHandler()
    {}
};

static void LNUIListItemSerializeHandler_delete(Wrap_UIListItemSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIListItemSerializeHandler_mark(Wrap_UIListItemSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIListItemSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIListItemSerializeHandler* internalObj;

    internalObj = new Wrap_UIListItemSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListItemSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListItemSerializeHandler_mark, LNUIListItemSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIListItemSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIListItemSerializeHandler* internalObj;

    internalObj = new Wrap_UIListItemSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListItemSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListItemSerializeHandler_mark, LNUIListItemSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIListItemSerializeHandler_OnSerialize_ProcCaller(LNHandle uilistitemserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIListItemSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uilistitemserializehandler), Wrap_UIListItemSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIListItemSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIListItemSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIListItemSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIListItemSerializeHandler_Create(Wrap_LNUIListItemSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIListItemSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIListItemsControlSerializeHandler

struct Wrap_UIListItemsControlSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIListItemsControlSerializeHandler()
    {}
};

static void LNUIListItemsControlSerializeHandler_delete(Wrap_UIListItemsControlSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIListItemsControlSerializeHandler_mark(Wrap_UIListItemsControlSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIListItemsControlSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIListItemsControlSerializeHandler* internalObj;

    internalObj = new Wrap_UIListItemsControlSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListItemsControlSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListItemsControlSerializeHandler_mark, LNUIListItemsControlSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIListItemsControlSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIListItemsControlSerializeHandler* internalObj;

    internalObj = new Wrap_UIListItemsControlSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListItemsControlSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListItemsControlSerializeHandler_mark, LNUIListItemsControlSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIListItemsControlSerializeHandler_OnSerialize_ProcCaller(LNHandle uilistitemscontrolserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIListItemsControlSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uilistitemscontrolserializehandler), Wrap_UIListItemsControlSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIListItemsControlSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIListItemsControlSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIListItemsControlSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIListItemsControlSerializeHandler_Create(Wrap_LNUIListItemsControlSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIListItemsControlSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIListBoxItemSerializeHandler

struct Wrap_UIListBoxItemSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIListBoxItemSerializeHandler()
    {}
};

static void LNUIListBoxItemSerializeHandler_delete(Wrap_UIListBoxItemSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIListBoxItemSerializeHandler_mark(Wrap_UIListBoxItemSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIListBoxItemSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIListBoxItemSerializeHandler* internalObj;

    internalObj = new Wrap_UIListBoxItemSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListBoxItemSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListBoxItemSerializeHandler_mark, LNUIListBoxItemSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIListBoxItemSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIListBoxItemSerializeHandler* internalObj;

    internalObj = new Wrap_UIListBoxItemSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListBoxItemSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListBoxItemSerializeHandler_mark, LNUIListBoxItemSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIListBoxItemSerializeHandler_OnSerialize_ProcCaller(LNHandle uilistboxitemserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIListBoxItemSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uilistboxitemserializehandler), Wrap_UIListBoxItemSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIListBoxItemSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIListBoxItemSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIListBoxItemSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIListBoxItemSerializeHandler_Create(Wrap_LNUIListBoxItemSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIListBoxItemSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// UIListBoxSerializeHandler

struct Wrap_UIListBoxSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_UIListBoxSerializeHandler()
    {}
};

static void LNUIListBoxSerializeHandler_delete(Wrap_UIListBoxSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNUIListBoxSerializeHandler_mark(Wrap_UIListBoxSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNUIListBoxSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_UIListBoxSerializeHandler* internalObj;

    internalObj = new Wrap_UIListBoxSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListBoxSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListBoxSerializeHandler_mark, LNUIListBoxSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNUIListBoxSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_UIListBoxSerializeHandler* internalObj;

    internalObj = new Wrap_UIListBoxSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNUIListBoxSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNUIListBoxSerializeHandler_mark, LNUIListBoxSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNUIListBoxSerializeHandler_OnSerialize_ProcCaller(LNHandle uilistboxserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_UIListBoxSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(uilistboxserializehandler), Wrap_UIListBoxSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNUIListBoxSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_UIListBoxSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_UIListBoxSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNUIListBoxSerializeHandler_Create(Wrap_LNUIListBoxSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "UIListBoxSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// InputGestureSerializeHandler

struct Wrap_InputGestureSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_InputGestureSerializeHandler()
    {}
};

static void LNInputGestureSerializeHandler_delete(Wrap_InputGestureSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNInputGestureSerializeHandler_mark(Wrap_InputGestureSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNInputGestureSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_InputGestureSerializeHandler* internalObj;

    internalObj = new Wrap_InputGestureSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInputGestureSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNInputGestureSerializeHandler_mark, LNInputGestureSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNInputGestureSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_InputGestureSerializeHandler* internalObj;

    internalObj = new Wrap_InputGestureSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInputGestureSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNInputGestureSerializeHandler_mark, LNInputGestureSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNInputGestureSerializeHandler_OnSerialize_ProcCaller(LNHandle inputgestureserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_InputGestureSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(inputgestureserializehandler), Wrap_InputGestureSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNInputGestureSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_InputGestureSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_InputGestureSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNInputGestureSerializeHandler_Create(Wrap_LNInputGestureSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "InputGestureSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// KeyGestureSerializeHandler

struct Wrap_KeyGestureSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_KeyGestureSerializeHandler()
    {}
};

static void LNKeyGestureSerializeHandler_delete(Wrap_KeyGestureSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNKeyGestureSerializeHandler_mark(Wrap_KeyGestureSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNKeyGestureSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_KeyGestureSerializeHandler* internalObj;

    internalObj = new Wrap_KeyGestureSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNKeyGestureSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNKeyGestureSerializeHandler_mark, LNKeyGestureSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNKeyGestureSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_KeyGestureSerializeHandler* internalObj;

    internalObj = new Wrap_KeyGestureSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNKeyGestureSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNKeyGestureSerializeHandler_mark, LNKeyGestureSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNKeyGestureSerializeHandler_OnSerialize_ProcCaller(LNHandle keygestureserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_KeyGestureSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(keygestureserializehandler), Wrap_KeyGestureSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNKeyGestureSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_KeyGestureSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_KeyGestureSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNKeyGestureSerializeHandler_Create(Wrap_LNKeyGestureSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "KeyGestureSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// InterpreterCommandSerializeHandler

struct Wrap_InterpreterCommandSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_InterpreterCommandSerializeHandler()
    {}
};

static void LNInterpreterCommandSerializeHandler_delete(Wrap_InterpreterCommandSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNInterpreterCommandSerializeHandler_mark(Wrap_InterpreterCommandSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNInterpreterCommandSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_InterpreterCommandSerializeHandler* internalObj;

    internalObj = new Wrap_InterpreterCommandSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterCommandSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterCommandSerializeHandler_mark, LNInterpreterCommandSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNInterpreterCommandSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_InterpreterCommandSerializeHandler* internalObj;

    internalObj = new Wrap_InterpreterCommandSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterCommandSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterCommandSerializeHandler_mark, LNInterpreterCommandSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNInterpreterCommandSerializeHandler_OnSerialize_ProcCaller(LNHandle interpretercommandserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_InterpreterCommandSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(interpretercommandserializehandler), Wrap_InterpreterCommandSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNInterpreterCommandSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterCommandSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterCommandSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNInterpreterCommandSerializeHandler_Create(Wrap_LNInterpreterCommandSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "InterpreterCommandSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// InterpreterCommandListSerializeHandler

struct Wrap_InterpreterCommandListSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_InterpreterCommandListSerializeHandler()
    {}
};

static void LNInterpreterCommandListSerializeHandler_delete(Wrap_InterpreterCommandListSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNInterpreterCommandListSerializeHandler_mark(Wrap_InterpreterCommandListSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNInterpreterCommandListSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_InterpreterCommandListSerializeHandler* internalObj;

    internalObj = new Wrap_InterpreterCommandListSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterCommandListSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterCommandListSerializeHandler_mark, LNInterpreterCommandListSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNInterpreterCommandListSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_InterpreterCommandListSerializeHandler* internalObj;

    internalObj = new Wrap_InterpreterCommandListSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterCommandListSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterCommandListSerializeHandler_mark, LNInterpreterCommandListSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNInterpreterCommandListSerializeHandler_OnSerialize_ProcCaller(LNHandle interpretercommandlistserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_InterpreterCommandListSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(interpretercommandlistserializehandler), Wrap_InterpreterCommandListSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNInterpreterCommandListSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterCommandListSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterCommandListSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNInterpreterCommandListSerializeHandler_Create(Wrap_LNInterpreterCommandListSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "InterpreterCommandListSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// InterpreterSerializeHandler

struct Wrap_InterpreterSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_InterpreterSerializeHandler()
    {}
};

static void LNInterpreterSerializeHandler_delete(Wrap_InterpreterSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNInterpreterSerializeHandler_mark(Wrap_InterpreterSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNInterpreterSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_InterpreterSerializeHandler* internalObj;

    internalObj = new Wrap_InterpreterSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterSerializeHandler_mark, LNInterpreterSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNInterpreterSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_InterpreterSerializeHandler* internalObj;

    internalObj = new Wrap_InterpreterSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterSerializeHandler_mark, LNInterpreterSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNInterpreterSerializeHandler_OnSerialize_ProcCaller(LNHandle interpreterserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_InterpreterSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(interpreterserializehandler), Wrap_InterpreterSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNInterpreterSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNInterpreterSerializeHandler_Create(Wrap_LNInterpreterSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "InterpreterSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// InterpreterUpdateWaitHandler

struct Wrap_InterpreterUpdateWaitHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_InterpreterUpdateWaitHandler()
    {}
};

static void LNInterpreterUpdateWaitHandler_delete(Wrap_InterpreterUpdateWaitHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNInterpreterUpdateWaitHandler_mark(Wrap_InterpreterUpdateWaitHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNInterpreterUpdateWaitHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_InterpreterUpdateWaitHandler* internalObj;

    internalObj = new Wrap_InterpreterUpdateWaitHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterUpdateWaitHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterUpdateWaitHandler_mark, LNInterpreterUpdateWaitHandler_delete, internalObj);

    return obj;
}

static VALUE LNInterpreterUpdateWaitHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_InterpreterUpdateWaitHandler* internalObj;

    internalObj = new Wrap_InterpreterUpdateWaitHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNInterpreterUpdateWaitHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNInterpreterUpdateWaitHandler_mark, LNInterpreterUpdateWaitHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNInterpreterUpdateWaitHandler_OnUpdateWait_ProcCaller(LNHandle interpreterupdatewaithandler, LNHandle self, LNBool* outReturn)
{
    Wrap_InterpreterUpdateWaitHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(interpreterupdatewaithandler), Wrap_InterpreterUpdateWaitHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    *outReturn = LNRB_VALUE_TO_BOOL(retval);
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNInterpreterUpdateWaitHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_InterpreterUpdateWaitHandler* selfObj;
    Data_Get_Struct(self, Wrap_InterpreterUpdateWaitHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNInterpreterUpdateWaitHandler_Create(Wrap_LNInterpreterUpdateWaitHandler_OnUpdateWait_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "InterpreterUpdateWaitHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ApplicationSerializeHandler

struct Wrap_ApplicationSerializeHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ApplicationSerializeHandler()
    {}
};

static void LNApplicationSerializeHandler_delete(Wrap_ApplicationSerializeHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNApplicationSerializeHandler_mark(Wrap_ApplicationSerializeHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNApplicationSerializeHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ApplicationSerializeHandler* internalObj;

    internalObj = new Wrap_ApplicationSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNApplicationSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNApplicationSerializeHandler_mark, LNApplicationSerializeHandler_delete, internalObj);

    return obj;
}

static VALUE LNApplicationSerializeHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ApplicationSerializeHandler* internalObj;

    internalObj = new Wrap_ApplicationSerializeHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNApplicationSerializeHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNApplicationSerializeHandler_mark, LNApplicationSerializeHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNApplicationSerializeHandler_OnSerialize_ProcCaller(LNHandle applicationserializehandler, LNHandle self, LNHandle ar)
{
    Wrap_ApplicationSerializeHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(applicationserializehandler), Wrap_ApplicationSerializeHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 2, LNRB_HANDLE_WRAP_TO_VALUE(self), LNRB_HANDLE_WRAP_TO_VALUE(ar));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNApplicationSerializeHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ApplicationSerializeHandler* selfObj;
    Data_Get_Struct(self, Wrap_ApplicationSerializeHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNApplicationSerializeHandler_Create(Wrap_LNApplicationSerializeHandler_OnSerialize_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ApplicationSerializeHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ApplicationInitHandler

struct Wrap_ApplicationInitHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ApplicationInitHandler()
    {}
};

static void LNApplicationInitHandler_delete(Wrap_ApplicationInitHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNApplicationInitHandler_mark(Wrap_ApplicationInitHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNApplicationInitHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ApplicationInitHandler* internalObj;

    internalObj = new Wrap_ApplicationInitHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNApplicationInitHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNApplicationInitHandler_mark, LNApplicationInitHandler_delete, internalObj);

    return obj;
}

static VALUE LNApplicationInitHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ApplicationInitHandler* internalObj;

    internalObj = new Wrap_ApplicationInitHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNApplicationInitHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNApplicationInitHandler_mark, LNApplicationInitHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNApplicationInitHandler_OnInit_ProcCaller(LNHandle applicationinithandler, LNHandle self)
{
    Wrap_ApplicationInitHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(applicationinithandler), Wrap_ApplicationInitHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNApplicationInitHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ApplicationInitHandler* selfObj;
    Data_Get_Struct(self, Wrap_ApplicationInitHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNApplicationInitHandler_Create(Wrap_LNApplicationInitHandler_OnInit_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ApplicationInitHandler::init - wrong argument type.");
    return Qnil;
}


//==============================================================================
// ApplicationUpdateHandler

struct Wrap_ApplicationUpdateHandler
    : public Wrap_RubyObject
{

    VALUE m_proc = Qnil;
    Wrap_ApplicationUpdateHandler()
    {}
};

static void LNApplicationUpdateHandler_delete(Wrap_ApplicationUpdateHandler* obj)
{
    LNRB_SAFE_UNREGISTER_WRAPPER_OBJECT(obj->handle);
    delete obj;
}

static void LNApplicationUpdateHandler_mark(Wrap_ApplicationUpdateHandler* obj)
{
	
rb_gc_mark(obj->m_proc);

}

static VALUE LNApplicationUpdateHandler_allocate(VALUE klass)
{
    VALUE obj;
    Wrap_ApplicationUpdateHandler* internalObj;

    internalObj = new Wrap_ApplicationUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNApplicationUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNApplicationUpdateHandler_mark, LNApplicationUpdateHandler_delete, internalObj);

    return obj;
}

static VALUE LNApplicationUpdateHandler_allocateForGetObject(VALUE klass, LNHandle handle)
{
    VALUE obj;
    Wrap_ApplicationUpdateHandler* internalObj;

    internalObj = new Wrap_ApplicationUpdateHandler();
    if (internalObj == NULL) rb_raise(LuminoRubyRuntimeManager::instance->luminoModule(), "Faild alloc - LNApplicationUpdateHandler_allocate");
    obj = Data_Wrap_Struct(klass, LNApplicationUpdateHandler_mark, LNApplicationUpdateHandler_delete, internalObj);
    
    internalObj->handle = handle;
    return obj;
}


static LNResult Wrap_LNApplicationUpdateHandler_OnUpdate_ProcCaller(LNHandle applicationupdatehandler, LNHandle self)
{
    Wrap_ApplicationUpdateHandler* selfObj;
    Data_Get_Struct(LNRB_HANDLE_WRAP_TO_VALUE(applicationupdatehandler), Wrap_ApplicationUpdateHandler, selfObj);
    VALUE retval = rb_funcall(selfObj->m_proc, rb_intern("call"), 1, LNRB_HANDLE_WRAP_TO_VALUE(self));
    return LN_OK;	// TODO: error handling.
}

static VALUE Wrap_LNApplicationUpdateHandler_Create(int argc, VALUE* argv, VALUE self)
{
    Wrap_ApplicationUpdateHandler* selfObj;
    Data_Get_Struct(self, Wrap_ApplicationUpdateHandler, selfObj);
    if (0 <= argc && argc <= 1) {
        VALUE proc, block;
        rb_scan_args(argc, argv, "01&", &proc, &block); // (handler=nil, &block)
        if (proc != Qnil) selfObj->m_proc = proc;
        if (block != Qnil) selfObj->m_proc = block;
        LNResult result = LNApplicationUpdateHandler_Create(Wrap_LNApplicationUpdateHandler_OnUpdate_ProcCaller, &selfObj->handle);
        if (result < 0) rb_raise(rb_eRuntimeError, "Lumino runtime error. (%d)\n%s", result, LNRuntime_GetLastErrorMessage());
        LuminoRubyRuntimeManager::instance->registerWrapperObject(self, false);
        return Qnil;
    }
    rb_raise(rb_eArgError, "ApplicationUpdateHandler::init - wrong argument type.");
    return Qnil;
}




extern "C" void Init_Lumino_RubyExt()
{
    InitLuminoRubyRuntimeManager();
    g_rootModule = rb_define_module("Lumino");

    g_enum_EncodingType = rb_define_module_under(g_rootModule, "EncodingType");
    rb_define_const(g_enum_EncodingType, "UNKNOWN", INT2FIX(0)); 
    rb_define_const(g_enum_EncodingType, "ASCII", INT2FIX(1)); 
    rb_define_const(g_enum_EncodingType, "UTF8", INT2FIX(2)); 
    rb_define_const(g_enum_EncodingType, "UTF8N", INT2FIX(3)); 
    rb_define_const(g_enum_EncodingType, "SJIS", INT2FIX(4)); 

    g_enum_Keys = rb_define_module_under(g_rootModule, "Keys");
    rb_define_const(g_enum_Keys, "UNKNOWN", INT2FIX(0)); 
    rb_define_const(g_enum_Keys, "A", INT2FIX(1)); 
    rb_define_const(g_enum_Keys, "B", INT2FIX(2)); 
    rb_define_const(g_enum_Keys, "C", INT2FIX(3)); 
    rb_define_const(g_enum_Keys, "D", INT2FIX(4)); 
    rb_define_const(g_enum_Keys, "E", INT2FIX(5)); 
    rb_define_const(g_enum_Keys, "F", INT2FIX(6)); 
    rb_define_const(g_enum_Keys, "G", INT2FIX(7)); 
    rb_define_const(g_enum_Keys, "H", INT2FIX(8)); 
    rb_define_const(g_enum_Keys, "I", INT2FIX(9)); 
    rb_define_const(g_enum_Keys, "J", INT2FIX(10)); 
    rb_define_const(g_enum_Keys, "K", INT2FIX(11)); 
    rb_define_const(g_enum_Keys, "L", INT2FIX(12)); 
    rb_define_const(g_enum_Keys, "M", INT2FIX(13)); 
    rb_define_const(g_enum_Keys, "N", INT2FIX(14)); 
    rb_define_const(g_enum_Keys, "O", INT2FIX(15)); 
    rb_define_const(g_enum_Keys, "P", INT2FIX(16)); 
    rb_define_const(g_enum_Keys, "Q", INT2FIX(17)); 
    rb_define_const(g_enum_Keys, "R", INT2FIX(18)); 
    rb_define_const(g_enum_Keys, "S", INT2FIX(19)); 
    rb_define_const(g_enum_Keys, "T", INT2FIX(20)); 
    rb_define_const(g_enum_Keys, "U", INT2FIX(21)); 
    rb_define_const(g_enum_Keys, "V", INT2FIX(22)); 
    rb_define_const(g_enum_Keys, "W", INT2FIX(23)); 
    rb_define_const(g_enum_Keys, "X", INT2FIX(24)); 
    rb_define_const(g_enum_Keys, "Y", INT2FIX(25)); 
    rb_define_const(g_enum_Keys, "Z", INT2FIX(26)); 
    rb_define_const(g_enum_Keys, "D0", INT2FIX(27)); 
    rb_define_const(g_enum_Keys, "D1", INT2FIX(28)); 
    rb_define_const(g_enum_Keys, "D2", INT2FIX(29)); 
    rb_define_const(g_enum_Keys, "D3", INT2FIX(30)); 
    rb_define_const(g_enum_Keys, "D4", INT2FIX(31)); 
    rb_define_const(g_enum_Keys, "D5", INT2FIX(32)); 
    rb_define_const(g_enum_Keys, "D6", INT2FIX(33)); 
    rb_define_const(g_enum_Keys, "D7", INT2FIX(34)); 
    rb_define_const(g_enum_Keys, "D8", INT2FIX(35)); 
    rb_define_const(g_enum_Keys, "D9", INT2FIX(36)); 
    rb_define_const(g_enum_Keys, "F1", INT2FIX(37)); 
    rb_define_const(g_enum_Keys, "F2", INT2FIX(38)); 
    rb_define_const(g_enum_Keys, "F3", INT2FIX(39)); 
    rb_define_const(g_enum_Keys, "F4", INT2FIX(40)); 
    rb_define_const(g_enum_Keys, "F5", INT2FIX(41)); 
    rb_define_const(g_enum_Keys, "F6", INT2FIX(42)); 
    rb_define_const(g_enum_Keys, "F7", INT2FIX(43)); 
    rb_define_const(g_enum_Keys, "F8", INT2FIX(44)); 
    rb_define_const(g_enum_Keys, "F9", INT2FIX(45)); 
    rb_define_const(g_enum_Keys, "F10", INT2FIX(46)); 
    rb_define_const(g_enum_Keys, "F11", INT2FIX(47)); 
    rb_define_const(g_enum_Keys, "F12", INT2FIX(48)); 
    rb_define_const(g_enum_Keys, "SPACE", INT2FIX(49)); 
    rb_define_const(g_enum_Keys, "ESCAPE", INT2FIX(50)); 
    rb_define_const(g_enum_Keys, "UP", INT2FIX(51)); 
    rb_define_const(g_enum_Keys, "DOWN", INT2FIX(52)); 
    rb_define_const(g_enum_Keys, "LEFT", INT2FIX(53)); 
    rb_define_const(g_enum_Keys, "RIGHT", INT2FIX(54)); 
    rb_define_const(g_enum_Keys, "LSHIFT", INT2FIX(55)); 
    rb_define_const(g_enum_Keys, "RSHIFT", INT2FIX(56)); 
    rb_define_const(g_enum_Keys, "LCTRL", INT2FIX(57)); 
    rb_define_const(g_enum_Keys, "RCTRL", INT2FIX(58)); 
    rb_define_const(g_enum_Keys, "LALT", INT2FIX(59)); 
    rb_define_const(g_enum_Keys, "RALT", INT2FIX(60)); 
    rb_define_const(g_enum_Keys, "TAB", INT2FIX(61)); 
    rb_define_const(g_enum_Keys, "ENTER", INT2FIX(62)); 
    rb_define_const(g_enum_Keys, "BACK_SPACE", INT2FIX(63)); 
    rb_define_const(g_enum_Keys, "INSERT", INT2FIX(64)); 
    rb_define_const(g_enum_Keys, "DELETE", INT2FIX(65)); 
    rb_define_const(g_enum_Keys, "PAGE_UP", INT2FIX(66)); 
    rb_define_const(g_enum_Keys, "PAGE_DOWN", INT2FIX(67)); 
    rb_define_const(g_enum_Keys, "HOME", INT2FIX(68)); 
    rb_define_const(g_enum_Keys, "END", INT2FIX(69)); 
    rb_define_const(g_enum_Keys, "COLON", INT2FIX(70)); 
    rb_define_const(g_enum_Keys, "SEMICOLON", INT2FIX(71)); 
    rb_define_const(g_enum_Keys, "COMMA", INT2FIX(72)); 
    rb_define_const(g_enum_Keys, "PERIOD", INT2FIX(73)); 
    rb_define_const(g_enum_Keys, "SLASH", INT2FIX(74)); 
    rb_define_const(g_enum_Keys, "MINUS", INT2FIX(75)); 
    rb_define_const(g_enum_Keys, "BACKSLASH", INT2FIX(76)); 
    rb_define_const(g_enum_Keys, "YEN", INT2FIX(77)); 
    rb_define_const(g_enum_Keys, "CARET", INT2FIX(78)); 
    rb_define_const(g_enum_Keys, "LBRACKET", INT2FIX(79)); 
    rb_define_const(g_enum_Keys, "RBRACKET", INT2FIX(80)); 
    rb_define_const(g_enum_Keys, "ANDROID_PLUS", INT2FIX(81)); 
    rb_define_const(g_enum_Keys, "TERMINATOR", INT2FIX(82)); 

    g_enum_MouseButtons = rb_define_module_under(g_rootModule, "MouseButtons");
    rb_define_const(g_enum_MouseButtons, "NONE", INT2FIX(0)); 
    rb_define_const(g_enum_MouseButtons, "LEFT", INT2FIX(1)); 
    rb_define_const(g_enum_MouseButtons, "RIGHT", INT2FIX(2)); 
    rb_define_const(g_enum_MouseButtons, "MIDDLE", INT2FIX(3)); 
    rb_define_const(g_enum_MouseButtons, "X1", INT2FIX(4)); 
    rb_define_const(g_enum_MouseButtons, "X2", INT2FIX(5)); 

    g_enum_SoundFadeBehavior = rb_define_module_under(g_rootModule, "SoundFadeBehavior");
    rb_define_const(g_enum_SoundFadeBehavior, "CONTINUE", INT2FIX(0)); 
    rb_define_const(g_enum_SoundFadeBehavior, "STOP", INT2FIX(1)); 
    rb_define_const(g_enum_SoundFadeBehavior, "STOP_RESET", INT2FIX(2)); 
    rb_define_const(g_enum_SoundFadeBehavior, "PAUSE", INT2FIX(3)); 
    rb_define_const(g_enum_SoundFadeBehavior, "PAUSE_RESET", INT2FIX(4)); 

    g_enum_GraphicsAPI = rb_define_module_under(g_rootModule, "GraphicsAPI");
    rb_define_const(g_enum_GraphicsAPI, "DEFAULT", INT2FIX(0)); 
    rb_define_const(g_enum_GraphicsAPI, "OPEN_GL", INT2FIX(1)); 
    rb_define_const(g_enum_GraphicsAPI, "VULKAN", INT2FIX(2)); 

    g_enum_PixelFormat = rb_define_module_under(g_rootModule, "PixelFormat");
    rb_define_const(g_enum_PixelFormat, "UNKNOWN", INT2FIX(0)); 
    rb_define_const(g_enum_PixelFormat, "A8", INT2FIX(1)); 
    rb_define_const(g_enum_PixelFormat, "RGBA8", INT2FIX(2)); 
    rb_define_const(g_enum_PixelFormat, "RGB8", INT2FIX(3)); 
    rb_define_const(g_enum_PixelFormat, "RGBA32F", INT2FIX(4)); 
    rb_define_const(g_enum_PixelFormat, "R32S", INT2FIX(5)); 

    g_enum_TextureFormat = rb_define_module_under(g_rootModule, "TextureFormat");
    rb_define_const(g_enum_TextureFormat, "UNKNOWN", INT2FIX(0)); 
    rb_define_const(g_enum_TextureFormat, "RGBA8", INT2FIX(1)); 
    rb_define_const(g_enum_TextureFormat, "RGB8", INT2FIX(2)); 
    rb_define_const(g_enum_TextureFormat, "RGBA16F", INT2FIX(3)); 
    rb_define_const(g_enum_TextureFormat, "RGBA32F", INT2FIX(4)); 
    rb_define_const(g_enum_TextureFormat, "R16F", INT2FIX(5)); 
    rb_define_const(g_enum_TextureFormat, "R32F", INT2FIX(6)); 
    rb_define_const(g_enum_TextureFormat, "R32S", INT2FIX(7)); 

    g_enum_DepthBufferFormat = rb_define_module_under(g_rootModule, "DepthBufferFormat");
    rb_define_const(g_enum_DepthBufferFormat, "D24S8", INT2FIX(0)); 

    g_enum_ShadingModel = rb_define_module_under(g_rootModule, "ShadingModel");
    rb_define_const(g_enum_ShadingModel, "DEFAULT", INT2FIX(0)); 
    rb_define_const(g_enum_ShadingModel, "UNLIT", INT2FIX(1)); 

    g_enum_BlendMode = rb_define_module_under(g_rootModule, "BlendMode");
    rb_define_const(g_enum_BlendMode, "NORMAL", INT2FIX(0)); 
    rb_define_const(g_enum_BlendMode, "ALPHA", INT2FIX(1)); 
    rb_define_const(g_enum_BlendMode, "ADD", INT2FIX(2)); 
    rb_define_const(g_enum_BlendMode, "SUBTRACT", INT2FIX(3)); 
    rb_define_const(g_enum_BlendMode, "MULTIPLY", INT2FIX(4)); 

    g_enum_SceneClearMode = rb_define_module_under(g_rootModule, "SceneClearMode");
    rb_define_const(g_enum_SceneClearMode, "NONE", INT2FIX(0)); 
    rb_define_const(g_enum_SceneClearMode, "COLOR_AND_DEPTH", INT2FIX(1)); 
    rb_define_const(g_enum_SceneClearMode, "SKY", INT2FIX(2)); 
    rb_define_const(g_enum_SceneClearMode, "SKY0", INT2FIX(3)); 
    rb_define_const(g_enum_SceneClearMode, "SKY_DOME", INT2FIX(4)); 

    g_enum_AnimationWrapMode = rb_define_module_under(g_rootModule, "AnimationWrapMode");
    rb_define_const(g_enum_AnimationWrapMode, "ONCE", INT2FIX(0)); 
    rb_define_const(g_enum_AnimationWrapMode, "LOOP", INT2FIX(1)); 
    rb_define_const(g_enum_AnimationWrapMode, "ALTERNATE", INT2FIX(2)); 

    g_enum_HierarchicalAnimationMode = rb_define_module_under(g_rootModule, "HierarchicalAnimationMode");
    rb_define_const(g_enum_HierarchicalAnimationMode, "ALLOW_TRANSLATION_ONLY_ROOT", INT2FIX(0)); 
    rb_define_const(g_enum_HierarchicalAnimationMode, "ALLOW_TRANSLATION_ONLY_ROOT_Y", INT2FIX(1)); 
    rb_define_const(g_enum_HierarchicalAnimationMode, "ALLOW_TRANSLATION", INT2FIX(2)); 
    rb_define_const(g_enum_HierarchicalAnimationMode, "DISABLE_TRANSLATION", INT2FIX(3)); 

    g_enum_TangentMode = rb_define_module_under(g_rootModule, "TangentMode");
    rb_define_const(g_enum_TangentMode, "LINEAR", INT2FIX(0)); 
    rb_define_const(g_enum_TangentMode, "TANGENT", INT2FIX(1)); 
    rb_define_const(g_enum_TangentMode, "AUTO", INT2FIX(2)); 
    rb_define_const(g_enum_TangentMode, "CONSTANT", INT2FIX(3)); 

    g_enum_ParticleEmitterShapeType = rb_define_module_under(g_rootModule, "ParticleEmitterShapeType");
    rb_define_const(g_enum_ParticleEmitterShapeType, "SPHERE", INT2FIX(0)); 
    rb_define_const(g_enum_ParticleEmitterShapeType, "CONE", INT2FIX(1)); 
    rb_define_const(g_enum_ParticleEmitterShapeType, "BOX", INT2FIX(2)); 

    g_enum_ParticleGeometryDirection = rb_define_module_under(g_rootModule, "ParticleGeometryDirection");
    rb_define_const(g_enum_ParticleGeometryDirection, "TO_VIEW", INT2FIX(0)); 
    rb_define_const(g_enum_ParticleGeometryDirection, "TOP", INT2FIX(1)); 
    rb_define_const(g_enum_ParticleGeometryDirection, "VERTICAL_BILLBOARD", INT2FIX(2)); 
    rb_define_const(g_enum_ParticleGeometryDirection, "HORIZONTAL_BILLBOARD", INT2FIX(3)); 

    g_enum_LevelTransitionEffectMode = rb_define_module_under(g_rootModule, "LevelTransitionEffectMode");
    rb_define_const(g_enum_LevelTransitionEffectMode, "NONE", INT2FIX(0)); 
    rb_define_const(g_enum_LevelTransitionEffectMode, "FADE_IN_OUT", INT2FIX(1)); 
    rb_define_const(g_enum_LevelTransitionEffectMode, "CROSS_FADE", INT2FIX(2)); 

    g_enum_UILayoutOrientation = rb_define_module_under(g_rootModule, "UILayoutOrientation");
    rb_define_const(g_enum_UILayoutOrientation, "HORIZONTAL", INT2FIX(0)); 
    rb_define_const(g_enum_UILayoutOrientation, "VERTICAL", INT2FIX(1)); 
    rb_define_const(g_enum_UILayoutOrientation, "REVERSE_HORIZONTAL", INT2FIX(2)); 
    rb_define_const(g_enum_UILayoutOrientation, "REVERSE_VERTICAL", INT2FIX(3)); 

    g_enum_UIVisibility = rb_define_module_under(g_rootModule, "UIVisibility");
    rb_define_const(g_enum_UIVisibility, "VISIBLE", INT2FIX(0)); 
    rb_define_const(g_enum_UIVisibility, "HIDDEN", INT2FIX(1)); 
    rb_define_const(g_enum_UIVisibility, "COLLAPSED", INT2FIX(2)); 

    g_enum_UIColorHues = rb_define_module_under(g_rootModule, "UIColorHues");
    rb_define_const(g_enum_UIColorHues, "RED", INT2FIX(0)); 
    rb_define_const(g_enum_UIColorHues, "PINK", INT2FIX(1)); 
    rb_define_const(g_enum_UIColorHues, "PURPLE", INT2FIX(2)); 
    rb_define_const(g_enum_UIColorHues, "DEEP_PURPLE", INT2FIX(4)); 
    rb_define_const(g_enum_UIColorHues, "INDIGO", INT2FIX(5)); 
    rb_define_const(g_enum_UIColorHues, "BLUE", INT2FIX(6)); 
    rb_define_const(g_enum_UIColorHues, "LIGHT_BLUE", INT2FIX(7)); 
    rb_define_const(g_enum_UIColorHues, "CYAN", INT2FIX(8)); 
    rb_define_const(g_enum_UIColorHues, "TEAL", INT2FIX(9)); 
    rb_define_const(g_enum_UIColorHues, "GREEN", INT2FIX(10)); 
    rb_define_const(g_enum_UIColorHues, "LIGHT_GREEN", INT2FIX(11)); 
    rb_define_const(g_enum_UIColorHues, "LIME", INT2FIX(12)); 
    rb_define_const(g_enum_UIColorHues, "YELLOW", INT2FIX(13)); 
    rb_define_const(g_enum_UIColorHues, "AMBER", INT2FIX(14)); 
    rb_define_const(g_enum_UIColorHues, "ORANGE", INT2FIX(15)); 
    rb_define_const(g_enum_UIColorHues, "DEEP_ORANGE", INT2FIX(16)); 
    rb_define_const(g_enum_UIColorHues, "BROWN", INT2FIX(17)); 
    rb_define_const(g_enum_UIColorHues, "GREY", INT2FIX(18)); 
    rb_define_const(g_enum_UIColorHues, "BLACK", INT2FIX(19)); 
    rb_define_const(g_enum_UIColorHues, "WHITE", INT2FIX(20)); 

    g_enum_UIVAlignment = rb_define_module_under(g_rootModule, "UIVAlignment");
    rb_define_const(g_enum_UIVAlignment, "TOP", INT2FIX(0)); 
    rb_define_const(g_enum_UIVAlignment, "CENTER", INT2FIX(1)); 
    rb_define_const(g_enum_UIVAlignment, "BOTTOM", INT2FIX(2)); 
    rb_define_const(g_enum_UIVAlignment, "STRETCH", INT2FIX(3)); 

    g_enum_UIHAlignment = rb_define_module_under(g_rootModule, "UIHAlignment");
    rb_define_const(g_enum_UIHAlignment, "LEFT", INT2FIX(0)); 
    rb_define_const(g_enum_UIHAlignment, "CENTER", INT2FIX(1)); 
    rb_define_const(g_enum_UIHAlignment, "RIGHT", INT2FIX(2)); 
    rb_define_const(g_enum_UIHAlignment, "STRETCH", INT2FIX(3)); 

    g_enum_UIInlinePlacement = rb_define_module_under(g_rootModule, "UIInlinePlacement");
    rb_define_const(g_enum_UIInlinePlacement, "TOP_LEFT", INT2FIX(0)); 
    rb_define_const(g_enum_UIInlinePlacement, "TOP", INT2FIX(1)); 
    rb_define_const(g_enum_UIInlinePlacement, "TOP_RIGHT", INT2FIX(2)); 
    rb_define_const(g_enum_UIInlinePlacement, "LEFT", INT2FIX(3)); 
    rb_define_const(g_enum_UIInlinePlacement, "CENTER", INT2FIX(4)); 
    rb_define_const(g_enum_UIInlinePlacement, "RIGHT", INT2FIX(5)); 
    rb_define_const(g_enum_UIInlinePlacement, "BOTTOM_LEFT", INT2FIX(6)); 
    rb_define_const(g_enum_UIInlinePlacement, "BOTTOM", INT2FIX(7)); 
    rb_define_const(g_enum_UIInlinePlacement, "BOTTOM_RIGHT", INT2FIX(8)); 

    g_enum_UIListSubmitMode = rb_define_module_under(g_rootModule, "UIListSubmitMode");
    rb_define_const(g_enum_UIListSubmitMode, "SINGLE", INT2FIX(0)); 
    rb_define_const(g_enum_UIListSubmitMode, "DOUBLE", INT2FIX(1));

    g_class_Vector3 = rb_define_class_under(g_rootModule, "Vector3", rb_cObject);
    rb_define_alloc_func(g_class_Vector3, LNVector3_allocate);
    rb_define_method(g_class_Vector3, "x", LN_TO_RUBY_FUNC(Wrap_LNVector3_GetX), -1);
    rb_define_method(g_class_Vector3, "x=", LN_TO_RUBY_FUNC(Wrap_LNVector3_SetX), -1);
    rb_define_method(g_class_Vector3, "y", LN_TO_RUBY_FUNC(Wrap_LNVector3_GetY), -1);
    rb_define_method(g_class_Vector3, "y=", LN_TO_RUBY_FUNC(Wrap_LNVector3_SetY), -1);
    rb_define_method(g_class_Vector3, "z", LN_TO_RUBY_FUNC(Wrap_LNVector3_GetZ), -1);
    rb_define_method(g_class_Vector3, "z=", LN_TO_RUBY_FUNC(Wrap_LNVector3_SetZ), -1);
    rb_define_method(g_class_Vector3, "initialize", LN_TO_RUBY_FUNC(Wrap_LNVector3_Set), -1);
    rb_define_method(g_class_Vector3, "get", LN_TO_RUBY_FUNC(Wrap_LNVector3_Get), -1);
    rb_define_method(g_class_Vector3, "length", LN_TO_RUBY_FUNC(Wrap_LNVector3_Length), -1);
    rb_define_method(g_class_Vector3, "length_squared", LN_TO_RUBY_FUNC(Wrap_LNVector3_LengthSquared), -1);
    rb_define_method(g_class_Vector3, "mutating_normalize", LN_TO_RUBY_FUNC(Wrap_LNVector3_MutatingNormalize), -1);
    rb_define_method(g_class_Vector3, "normalize", LN_TO_RUBY_FUNC(Wrap_LNVector3_Normalize), -1);

    g_class_Vector4 = rb_define_class_under(g_rootModule, "Vector4", rb_cObject);
    rb_define_alloc_func(g_class_Vector4, LNVector4_allocate);
    rb_define_method(g_class_Vector4, "x", LN_TO_RUBY_FUNC(Wrap_LNVector4_GetX), -1);
    rb_define_method(g_class_Vector4, "x=", LN_TO_RUBY_FUNC(Wrap_LNVector4_SetX), -1);
    rb_define_method(g_class_Vector4, "y", LN_TO_RUBY_FUNC(Wrap_LNVector4_GetY), -1);
    rb_define_method(g_class_Vector4, "y=", LN_TO_RUBY_FUNC(Wrap_LNVector4_SetY), -1);
    rb_define_method(g_class_Vector4, "z", LN_TO_RUBY_FUNC(Wrap_LNVector4_GetZ), -1);
    rb_define_method(g_class_Vector4, "z=", LN_TO_RUBY_FUNC(Wrap_LNVector4_SetZ), -1);
    rb_define_method(g_class_Vector4, "w", LN_TO_RUBY_FUNC(Wrap_LNVector4_GetW), -1);
    rb_define_method(g_class_Vector4, "w=", LN_TO_RUBY_FUNC(Wrap_LNVector4_SetW), -1);
    rb_define_method(g_class_Vector4, "initialize", LN_TO_RUBY_FUNC(Wrap_LNVector4_Set), -1);

    g_class_Quaternion = rb_define_class_under(g_rootModule, "Quaternion", rb_cObject);
    rb_define_alloc_func(g_class_Quaternion, LNQuaternion_allocate);
    rb_define_method(g_class_Quaternion, "x", LN_TO_RUBY_FUNC(Wrap_LNQuaternion_GetX), -1);
    rb_define_method(g_class_Quaternion, "x=", LN_TO_RUBY_FUNC(Wrap_LNQuaternion_SetX), -1);
    rb_define_method(g_class_Quaternion, "y", LN_TO_RUBY_FUNC(Wrap_LNQuaternion_GetY), -1);
    rb_define_method(g_class_Quaternion, "y=", LN_TO_RUBY_FUNC(Wrap_LNQuaternion_SetY), -1);
    rb_define_method(g_class_Quaternion, "z", LN_TO_RUBY_FUNC(Wrap_LNQuaternion_GetZ), -1);
    rb_define_method(g_class_Quaternion, "z=", LN_TO_RUBY_FUNC(Wrap_LNQuaternion_SetZ), -1);
    rb_define_method(g_class_Quaternion, "w", LN_TO_RUBY_FUNC(Wrap_LNQuaternion_GetW), -1);
    rb_define_method(g_class_Quaternion, "w=", LN_TO_RUBY_FUNC(Wrap_LNQuaternion_SetW), -1);
    rb_define_method(g_class_Quaternion, "initialize", LN_TO_RUBY_FUNC(Wrap_LNQuaternion_Set), -1);

    g_class_Matrix = rb_define_class_under(g_rootModule, "Matrix", rb_cObject);
    rb_define_alloc_func(g_class_Matrix, LNMatrix_allocate);
    rb_define_method(g_class_Matrix, "row_0", LN_TO_RUBY_FUNC(Wrap_LNMatrix_GetRow0), -1);
    rb_define_method(g_class_Matrix, "row_0=", LN_TO_RUBY_FUNC(Wrap_LNMatrix_SetRow0), -1);
    rb_define_method(g_class_Matrix, "row_1", LN_TO_RUBY_FUNC(Wrap_LNMatrix_GetRow1), -1);
    rb_define_method(g_class_Matrix, "row_1=", LN_TO_RUBY_FUNC(Wrap_LNMatrix_SetRow1), -1);
    rb_define_method(g_class_Matrix, "row_2", LN_TO_RUBY_FUNC(Wrap_LNMatrix_GetRow2), -1);
    rb_define_method(g_class_Matrix, "row_2=", LN_TO_RUBY_FUNC(Wrap_LNMatrix_SetRow2), -1);
    rb_define_method(g_class_Matrix, "row_3", LN_TO_RUBY_FUNC(Wrap_LNMatrix_GetRow3), -1);
    rb_define_method(g_class_Matrix, "row_3=", LN_TO_RUBY_FUNC(Wrap_LNMatrix_SetRow3), -1);
    rb_define_method(g_class_Matrix, "initialize", LN_TO_RUBY_FUNC(Wrap_LNMatrix_Set), -1);

    g_class_Color = rb_define_class_under(g_rootModule, "Color", rb_cObject);
    rb_define_alloc_func(g_class_Color, LNColor_allocate);
    rb_define_method(g_class_Color, "r", LN_TO_RUBY_FUNC(Wrap_LNColor_GetR), -1);
    rb_define_method(g_class_Color, "r=", LN_TO_RUBY_FUNC(Wrap_LNColor_SetR), -1);
    rb_define_method(g_class_Color, "g", LN_TO_RUBY_FUNC(Wrap_LNColor_GetG), -1);
    rb_define_method(g_class_Color, "g=", LN_TO_RUBY_FUNC(Wrap_LNColor_SetG), -1);
    rb_define_method(g_class_Color, "b", LN_TO_RUBY_FUNC(Wrap_LNColor_GetB), -1);
    rb_define_method(g_class_Color, "b=", LN_TO_RUBY_FUNC(Wrap_LNColor_SetB), -1);
    rb_define_method(g_class_Color, "a", LN_TO_RUBY_FUNC(Wrap_LNColor_GetA), -1);
    rb_define_method(g_class_Color, "a=", LN_TO_RUBY_FUNC(Wrap_LNColor_SetA), -1);
    rb_define_method(g_class_Color, "initialize", LN_TO_RUBY_FUNC(Wrap_LNColor_Set), -1);

    g_class_ColorTone = rb_define_class_under(g_rootModule, "ColorTone", rb_cObject);
    rb_define_alloc_func(g_class_ColorTone, LNColorTone_allocate);
    rb_define_method(g_class_ColorTone, "r", LN_TO_RUBY_FUNC(Wrap_LNColorTone_GetR), -1);
    rb_define_method(g_class_ColorTone, "r=", LN_TO_RUBY_FUNC(Wrap_LNColorTone_SetR), -1);
    rb_define_method(g_class_ColorTone, "g", LN_TO_RUBY_FUNC(Wrap_LNColorTone_GetG), -1);
    rb_define_method(g_class_ColorTone, "g=", LN_TO_RUBY_FUNC(Wrap_LNColorTone_SetG), -1);
    rb_define_method(g_class_ColorTone, "b", LN_TO_RUBY_FUNC(Wrap_LNColorTone_GetB), -1);
    rb_define_method(g_class_ColorTone, "b=", LN_TO_RUBY_FUNC(Wrap_LNColorTone_SetB), -1);
    rb_define_method(g_class_ColorTone, "s", LN_TO_RUBY_FUNC(Wrap_LNColorTone_GetS), -1);
    rb_define_method(g_class_ColorTone, "s=", LN_TO_RUBY_FUNC(Wrap_LNColorTone_SetS), -1);
    rb_define_method(g_class_ColorTone, "initialize", LN_TO_RUBY_FUNC(Wrap_LNColorTone_Set), -1);

    g_class_Point = rb_define_class_under(g_rootModule, "Point", rb_cObject);
    rb_define_alloc_func(g_class_Point, LNPoint_allocate);
    rb_define_method(g_class_Point, "x", LN_TO_RUBY_FUNC(Wrap_LNPoint_GetX), -1);
    rb_define_method(g_class_Point, "x=", LN_TO_RUBY_FUNC(Wrap_LNPoint_SetX), -1);
    rb_define_method(g_class_Point, "y", LN_TO_RUBY_FUNC(Wrap_LNPoint_GetY), -1);
    rb_define_method(g_class_Point, "y=", LN_TO_RUBY_FUNC(Wrap_LNPoint_SetY), -1);
    rb_define_method(g_class_Point, "initialize", LN_TO_RUBY_FUNC(Wrap_LNPoint_Set), -1);

    g_class_Size = rb_define_class_under(g_rootModule, "Size", rb_cObject);
    rb_define_alloc_func(g_class_Size, LNSize_allocate);
    rb_define_method(g_class_Size, "width", LN_TO_RUBY_FUNC(Wrap_LNSize_GetWidth), -1);
    rb_define_method(g_class_Size, "width=", LN_TO_RUBY_FUNC(Wrap_LNSize_SetWidth), -1);
    rb_define_method(g_class_Size, "height", LN_TO_RUBY_FUNC(Wrap_LNSize_GetHeight), -1);
    rb_define_method(g_class_Size, "height=", LN_TO_RUBY_FUNC(Wrap_LNSize_SetHeight), -1);
    rb_define_method(g_class_Size, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSize_Set), -1);

    g_class_Rect = rb_define_class_under(g_rootModule, "Rect", rb_cObject);
    rb_define_alloc_func(g_class_Rect, LNRect_allocate);
    rb_define_method(g_class_Rect, "x", LN_TO_RUBY_FUNC(Wrap_LNRect_GetX), -1);
    rb_define_method(g_class_Rect, "x=", LN_TO_RUBY_FUNC(Wrap_LNRect_SetX), -1);
    rb_define_method(g_class_Rect, "y", LN_TO_RUBY_FUNC(Wrap_LNRect_GetY), -1);
    rb_define_method(g_class_Rect, "y=", LN_TO_RUBY_FUNC(Wrap_LNRect_SetY), -1);
    rb_define_method(g_class_Rect, "width", LN_TO_RUBY_FUNC(Wrap_LNRect_GetWidth), -1);
    rb_define_method(g_class_Rect, "width=", LN_TO_RUBY_FUNC(Wrap_LNRect_SetWidth), -1);
    rb_define_method(g_class_Rect, "height", LN_TO_RUBY_FUNC(Wrap_LNRect_GetHeight), -1);
    rb_define_method(g_class_Rect, "height=", LN_TO_RUBY_FUNC(Wrap_LNRect_SetHeight), -1);
    rb_define_method(g_class_Rect, "initialize", LN_TO_RUBY_FUNC(Wrap_LNRect_Set), -1);
    rb_define_method(g_class_Rect, "get_left", LN_TO_RUBY_FUNC(Wrap_LNRect_GetLeft), -1);
    rb_define_method(g_class_Rect, "size=", LN_TO_RUBY_FUNC(Wrap_LNRect_SetSize), -1);
    rb_define_method(g_class_Rect, "size", LN_TO_RUBY_FUNC(Wrap_LNRect_GetSize), -1);

    g_class_Thickness = rb_define_class_under(g_rootModule, "Thickness", rb_cObject);
    rb_define_alloc_func(g_class_Thickness, LNThickness_allocate);
    rb_define_method(g_class_Thickness, "left", LN_TO_RUBY_FUNC(Wrap_LNThickness_GetLeft), -1);
    rb_define_method(g_class_Thickness, "left=", LN_TO_RUBY_FUNC(Wrap_LNThickness_SetLeft), -1);
    rb_define_method(g_class_Thickness, "top", LN_TO_RUBY_FUNC(Wrap_LNThickness_GetTop), -1);
    rb_define_method(g_class_Thickness, "top=", LN_TO_RUBY_FUNC(Wrap_LNThickness_SetTop), -1);
    rb_define_method(g_class_Thickness, "right", LN_TO_RUBY_FUNC(Wrap_LNThickness_GetRight), -1);
    rb_define_method(g_class_Thickness, "right=", LN_TO_RUBY_FUNC(Wrap_LNThickness_SetRight), -1);
    rb_define_method(g_class_Thickness, "bottom", LN_TO_RUBY_FUNC(Wrap_LNThickness_GetBottom), -1);
    rb_define_method(g_class_Thickness, "bottom=", LN_TO_RUBY_FUNC(Wrap_LNThickness_SetBottom), -1);
    rb_define_method(g_class_Thickness, "initialize", LN_TO_RUBY_FUNC(Wrap_LNThickness_Set), -1);

    g_class_CornerRadius = rb_define_class_under(g_rootModule, "CornerRadius", rb_cObject);
    rb_define_alloc_func(g_class_CornerRadius, LNCornerRadius_allocate);
    rb_define_method(g_class_CornerRadius, "topleft", LN_TO_RUBY_FUNC(Wrap_LNCornerRadius_GetTopleft), -1);
    rb_define_method(g_class_CornerRadius, "topleft=", LN_TO_RUBY_FUNC(Wrap_LNCornerRadius_SetTopleft), -1);
    rb_define_method(g_class_CornerRadius, "topright", LN_TO_RUBY_FUNC(Wrap_LNCornerRadius_GetTopright), -1);
    rb_define_method(g_class_CornerRadius, "topright=", LN_TO_RUBY_FUNC(Wrap_LNCornerRadius_SetTopright), -1);
    rb_define_method(g_class_CornerRadius, "bottomright", LN_TO_RUBY_FUNC(Wrap_LNCornerRadius_GetBottomright), -1);
    rb_define_method(g_class_CornerRadius, "bottomright=", LN_TO_RUBY_FUNC(Wrap_LNCornerRadius_SetBottomright), -1);
    rb_define_method(g_class_CornerRadius, "bottomleft", LN_TO_RUBY_FUNC(Wrap_LNCornerRadius_GetBottomleft), -1);
    rb_define_method(g_class_CornerRadius, "bottomleft=", LN_TO_RUBY_FUNC(Wrap_LNCornerRadius_SetBottomleft), -1);
    rb_define_method(g_class_CornerRadius, "initialize", LN_TO_RUBY_FUNC(Wrap_LNCornerRadius_Set), -1);

    g_class_Object = rb_define_class_under(g_rootModule, "Object", rb_cObject);
    rb_define_alloc_func(g_class_Object, LNObject_allocate);
    rb_define_method(g_class_Object, "on_serialize", LN_TO_RUBY_FUNC(Wrap_LNObject_OnSerialize), -1);
    rb_define_method(g_class_Object, "release", LN_TO_RUBY_FUNC(Wrap_LNObject_Release), -1);
    rb_define_method(g_class_Object, "retain", LN_TO_RUBY_FUNC(Wrap_LNObject_Retain), -1);
    rb_define_method(g_class_Object, "get_reference_count", LN_TO_RUBY_FUNC(Wrap_LNObject_GetReferenceCount), -1);
    LNObject_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Object, LNObject_allocateForGetObject));
    LNObject_OnSerialize_SetOverrideCallback(Wrap_LNObject_OnSerialize_OverrideCallback);

    g_class_EventConnection = rb_define_class_under(g_rootModule, "EventConnection", g_class_Object);
    rb_define_alloc_func(g_class_EventConnection, LNEventConnection_allocate);
    LNEventConnection_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_EventConnection, LNEventConnection_allocateForGetObject));
    LNEventConnection_OnSerialize_SetOverrideCallback(Wrap_LNEventConnection_OnSerialize_OverrideCallback);

    g_class_PromiseFailureDelegate = rb_define_class_under(g_rootModule, "PromiseFailureDelegate", g_class_Object);
    rb_define_alloc_func(g_class_PromiseFailureDelegate, LNPromiseFailureDelegate_allocate);
    rb_define_private_method(g_class_PromiseFailureDelegate, "initialize", LN_TO_RUBY_FUNC(Wrap_LNPromiseFailureDelegate_Create), -1);
    LNPromiseFailureDelegate_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_PromiseFailureDelegate, LNPromiseFailureDelegate_allocateForGetObject));

    g_class_Variant = rb_define_class_under(g_rootModule, "Variant", g_class_Object);
    rb_define_alloc_func(g_class_Variant, LNVariant_allocate);
    rb_define_private_method(g_class_Variant, "initialize", LN_TO_RUBY_FUNC(Wrap_LNVariant_Create), -1);
    rb_define_method(g_class_Variant, "set_int", LN_TO_RUBY_FUNC(Wrap_LNVariant_SetInt), -1);
    rb_define_method(g_class_Variant, "get_int", LN_TO_RUBY_FUNC(Wrap_LNVariant_GetInt), -1);
    LNVariant_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Variant, LNVariant_allocateForGetObject));
    LNVariant_OnSerialize_SetOverrideCallback(Wrap_LNVariant_OnSerialize_OverrideCallback);

    g_class_ZVTestDelegate1 = rb_define_class_under(g_rootModule, "ZVTestDelegate1", g_class_Object);
    rb_define_alloc_func(g_class_ZVTestDelegate1, LNZVTestDelegate1_allocate);
    rb_define_private_method(g_class_ZVTestDelegate1, "initialize", LN_TO_RUBY_FUNC(Wrap_LNZVTestDelegate1_Create), -1);
    LNZVTestDelegate1_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ZVTestDelegate1, LNZVTestDelegate1_allocateForGetObject));

    g_class_ZVTestDelegate2 = rb_define_class_under(g_rootModule, "ZVTestDelegate2", g_class_Object);
    rb_define_alloc_func(g_class_ZVTestDelegate2, LNZVTestDelegate2_allocate);
    rb_define_private_method(g_class_ZVTestDelegate2, "initialize", LN_TO_RUBY_FUNC(Wrap_LNZVTestDelegate2_Create), -1);
    LNZVTestDelegate2_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ZVTestDelegate2, LNZVTestDelegate2_allocateForGetObject));

    g_class_ZVTestDelegate3 = rb_define_class_under(g_rootModule, "ZVTestDelegate3", g_class_Object);
    rb_define_alloc_func(g_class_ZVTestDelegate3, LNZVTestDelegate3_allocate);
    rb_define_private_method(g_class_ZVTestDelegate3, "initialize", LN_TO_RUBY_FUNC(Wrap_LNZVTestDelegate3_Create), -1);
    LNZVTestDelegate3_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ZVTestDelegate3, LNZVTestDelegate3_allocateForGetObject));

    g_class_ZVTestEventHandler1 = rb_define_class_under(g_rootModule, "ZVTestEventHandler1", g_class_Object);
    rb_define_alloc_func(g_class_ZVTestEventHandler1, LNZVTestEventHandler1_allocate);
    rb_define_private_method(g_class_ZVTestEventHandler1, "initialize", LN_TO_RUBY_FUNC(Wrap_LNZVTestEventHandler1_Create), -1);
    LNZVTestEventHandler1_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ZVTestEventHandler1, LNZVTestEventHandler1_allocateForGetObject));

    g_class_ZVTestEventHandler2 = rb_define_class_under(g_rootModule, "ZVTestEventHandler2", g_class_Object);
    rb_define_alloc_func(g_class_ZVTestEventHandler2, LNZVTestEventHandler2_allocate);
    rb_define_private_method(g_class_ZVTestEventHandler2, "initialize", LN_TO_RUBY_FUNC(Wrap_LNZVTestEventHandler2_Create), -1);
    LNZVTestEventHandler2_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ZVTestEventHandler2, LNZVTestEventHandler2_allocateForGetObject));

    g_class_ZVTestPromise1 = rb_define_class_under(g_rootModule, "ZVTestPromise1", g_class_Object);
    rb_define_alloc_func(g_class_ZVTestPromise1, LNZVTestPromise1_allocate);
    rb_define_method(g_class_ZVTestPromise1, "then_with", LN_TO_RUBY_FUNC(Wrap_LNZVTestPromise1_ThenWith), -1);
    rb_define_method(g_class_ZVTestPromise1, "catch_with", LN_TO_RUBY_FUNC(Wrap_LNZVTestPromise1_CatchWith), -1);
    LNZVTestPromise1_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ZVTestPromise1, LNZVTestPromise1_allocateForGetObject));

    g_class_ZVTestPromise2 = rb_define_class_under(g_rootModule, "ZVTestPromise2", g_class_Object);
    rb_define_alloc_func(g_class_ZVTestPromise2, LNZVTestPromise2_allocate);
    rb_define_method(g_class_ZVTestPromise2, "then_with", LN_TO_RUBY_FUNC(Wrap_LNZVTestPromise2_ThenWith), -1);
    rb_define_method(g_class_ZVTestPromise2, "catch_with", LN_TO_RUBY_FUNC(Wrap_LNZVTestPromise2_CatchWith), -1);
    LNZVTestPromise2_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ZVTestPromise2, LNZVTestPromise2_allocateForGetObject));

    g_class_ZVTestClass1 = rb_define_class_under(g_rootModule, "ZVTestClass1", g_class_Object);
    rb_define_alloc_func(g_class_ZVTestClass1, LNZVTestClass1_allocate);
    rb_define_private_method(g_class_ZVTestClass1, "initialize", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_Create), -1);
    rb_define_method(g_class_ZVTestClass1, "set_test_delegate_1", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_SetTestDelegate1), -1);
    rb_define_method(g_class_ZVTestClass1, "set_test_delegate_2", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_SetTestDelegate2), -1);
    rb_define_method(g_class_ZVTestClass1, "set_test_delegate_3", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_SetTestDelegate3), -1);
    rb_define_method(g_class_ZVTestClass1, "call_test_delegate_1", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_CallTestDelegate1), -1);
    rb_define_method(g_class_ZVTestClass1, "call_test_delegate_2", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_CallTestDelegate2), -1);
    rb_define_method(g_class_ZVTestClass1, "call_test_delegate_3", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_CallTestDelegate3), -1);
    rb_define_singleton_method(g_class_ZVTestClass1, "load_async", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_LoadAsync), -1);
    rb_define_method(g_class_ZVTestClass1, "execute_async", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_ExecuteAsync), -1);
    rb_define_method(g_class_ZVTestClass1, "file_path", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_GetFilePath), -1);
    rb_define_method(g_class_ZVTestClass1, "connect_on_event_1", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_ConnectOnEvent1), -1);
    rb_define_method(g_class_ZVTestClass1, "raise_event_1", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_RaiseEvent1), -1);
    rb_define_method(g_class_ZVTestClass1, "connect_on_event_2", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_ConnectOnEvent2), -1);
    rb_define_method(g_class_ZVTestClass1, "raise_event_2", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1_RaiseEvent2), -1);
    LNZVTestClass1_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ZVTestClass1, LNZVTestClass1_allocateForGetObject));
    LNZVTestClass1_OnSerialize_SetOverrideCallback(Wrap_LNZVTestClass1_OnSerialize_OverrideCallback);

    g_class_ZVTestEventArgs1 = rb_define_class_under(g_rootModule, "ZVTestEventArgs1", g_class_Object);
    rb_define_alloc_func(g_class_ZVTestEventArgs1, LNZVTestEventArgs1_allocate);
    rb_define_private_method(g_class_ZVTestEventArgs1, "initialize", LN_TO_RUBY_FUNC(Wrap_LNZVTestEventArgs1_Create), -1);
    rb_define_method(g_class_ZVTestEventArgs1, "value", LN_TO_RUBY_FUNC(Wrap_LNZVTestEventArgs1_GetValue), -1);
    LNZVTestEventArgs1_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ZVTestEventArgs1, LNZVTestEventArgs1_allocateForGetObject));
    LNZVTestEventArgs1_OnSerialize_SetOverrideCallback(Wrap_LNZVTestEventArgs1_OnSerialize_OverrideCallback);

    g_class_Serializer2 = rb_define_class_under(g_rootModule, "Serializer2", g_class_Object);
    rb_define_alloc_func(g_class_Serializer2, LNSerializer2_allocate);
    LNSerializer2_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Serializer2, LNSerializer2_allocateForGetObject));
    LNSerializer2_OnSerialize_SetOverrideCallback(Wrap_LNSerializer2_OnSerialize_OverrideCallback);

    g_class_AssetObject = rb_define_class_under(g_rootModule, "AssetObject", g_class_Object);
    rb_define_alloc_func(g_class_AssetObject, LNAssetObject_allocate);
    LNAssetObject_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AssetObject, LNAssetObject_allocateForGetObject));
    LNAssetObject_OnSerialize_SetOverrideCallback(Wrap_LNAssetObject_OnSerialize_OverrideCallback);

    g_class_AssetImportSettings = rb_define_class_under(g_rootModule, "AssetImportSettings", g_class_Object);
    rb_define_alloc_func(g_class_AssetImportSettings, LNAssetImportSettings_allocate);
    LNAssetImportSettings_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AssetImportSettings, LNAssetImportSettings_allocateForGetObject));
    LNAssetImportSettings_OnSerialize_SetOverrideCallback(Wrap_LNAssetImportSettings_OnSerialize_OverrideCallback);

    g_class_AssetModel = rb_define_class_under(g_rootModule, "AssetModel", g_class_Object);
    rb_define_alloc_func(g_class_AssetModel, LNAssetModel_allocate);
    rb_define_private_method(g_class_AssetModel, "initialize", LN_TO_RUBY_FUNC(Wrap_LNAssetModel_Create), -1);
    rb_define_method(g_class_AssetModel, "target", LN_TO_RUBY_FUNC(Wrap_LNAssetModel_Target), -1);
    LNAssetModel_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AssetModel, LNAssetModel_allocateForGetObject));
    LNAssetModel_OnSerialize_SetOverrideCallback(Wrap_LNAssetModel_OnSerialize_OverrideCallback);

    g_class_Assets = rb_define_class_under(g_rootModule, "Assets", rb_cObject);
    rb_define_singleton_method(g_class_Assets, "save_asset_to_local_file", LN_TO_RUBY_FUNC(Wrap_LNAssets_SaveAssetToLocalFile), -1);
    rb_define_singleton_method(g_class_Assets, "load_asset_from_local_file", LN_TO_RUBY_FUNC(Wrap_LNAssets_LoadAssetFromLocalFile), -1);
    rb_define_singleton_method(g_class_Assets, "load_asset", LN_TO_RUBY_FUNC(Wrap_LNAssets_LoadAsset), -1);
    rb_define_singleton_method(g_class_Assets, "reload_asset", LN_TO_RUBY_FUNC(Wrap_LNAssets_ReloadAsset), -1);
    rb_define_singleton_method(g_class_Assets, "read_all_text", LN_TO_RUBY_FUNC(Wrap_LNAssets_ReadAllText), -1);

    g_class_Sound = rb_define_class_under(g_rootModule, "Sound", g_class_Object);
    rb_define_alloc_func(g_class_Sound, LNSound_allocate);
    rb_define_method(g_class_Sound, "volume=", LN_TO_RUBY_FUNC(Wrap_LNSound_SetVolume), -1);
    rb_define_method(g_class_Sound, "volume", LN_TO_RUBY_FUNC(Wrap_LNSound_GetVolume), -1);
    rb_define_method(g_class_Sound, "pitch=", LN_TO_RUBY_FUNC(Wrap_LNSound_SetPitch), -1);
    rb_define_method(g_class_Sound, "pitch", LN_TO_RUBY_FUNC(Wrap_LNSound_GetPitch), -1);
    rb_define_method(g_class_Sound, "loop_enabled=", LN_TO_RUBY_FUNC(Wrap_LNSound_SetLoopEnabled), -1);
    rb_define_method(g_class_Sound, "loop_enabled?", LN_TO_RUBY_FUNC(Wrap_LNSound_IsLoopEnabled), -1);
    rb_define_method(g_class_Sound, "set_loop_range", LN_TO_RUBY_FUNC(Wrap_LNSound_SetLoopRange), -1);
    rb_define_method(g_class_Sound, "play", LN_TO_RUBY_FUNC(Wrap_LNSound_Play), -1);
    rb_define_method(g_class_Sound, "stop", LN_TO_RUBY_FUNC(Wrap_LNSound_Stop), -1);
    rb_define_method(g_class_Sound, "pause", LN_TO_RUBY_FUNC(Wrap_LNSound_Pause), -1);
    rb_define_method(g_class_Sound, "resume", LN_TO_RUBY_FUNC(Wrap_LNSound_Resume), -1);
    rb_define_method(g_class_Sound, "fade_volume", LN_TO_RUBY_FUNC(Wrap_LNSound_FadeVolume), -1);
    LNSound_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Sound, LNSound_allocateForGetObject));
    LNSound_OnSerialize_SetOverrideCallback(Wrap_LNSound_OnSerialize_OverrideCallback);

    g_class_Audio = rb_define_class_under(g_rootModule, "Audio", rb_cObject);
    rb_define_singleton_method(g_class_Audio, "play_bgm", LN_TO_RUBY_FUNC(Wrap_LNAudio_PlayBGM), -1);
    rb_define_singleton_method(g_class_Audio, "stop_bgm", LN_TO_RUBY_FUNC(Wrap_LNAudio_StopBGM), -1);
    rb_define_singleton_method(g_class_Audio, "play_bgs", LN_TO_RUBY_FUNC(Wrap_LNAudio_PlayBGS), -1);
    rb_define_singleton_method(g_class_Audio, "stop_bgs", LN_TO_RUBY_FUNC(Wrap_LNAudio_StopBGS), -1);
    rb_define_singleton_method(g_class_Audio, "play_me", LN_TO_RUBY_FUNC(Wrap_LNAudio_PlayME), -1);
    rb_define_singleton_method(g_class_Audio, "stop_me", LN_TO_RUBY_FUNC(Wrap_LNAudio_StopME), -1);
    rb_define_singleton_method(g_class_Audio, "play_se", LN_TO_RUBY_FUNC(Wrap_LNAudio_PlaySE), -1);
    rb_define_singleton_method(g_class_Audio, "play_se3d", LN_TO_RUBY_FUNC(Wrap_LNAudio_PlaySE3D), -1);
    rb_define_singleton_method(g_class_Audio, "stop_se", LN_TO_RUBY_FUNC(Wrap_LNAudio_StopSE), -1);

    g_class_Texture2DDelegate = rb_define_class_under(g_rootModule, "Texture2DDelegate", g_class_Object);
    rb_define_alloc_func(g_class_Texture2DDelegate, LNTexture2DDelegate_allocate);
    rb_define_private_method(g_class_Texture2DDelegate, "initialize", LN_TO_RUBY_FUNC(Wrap_LNTexture2DDelegate_Create), -1);
    LNTexture2DDelegate_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Texture2DDelegate, LNTexture2DDelegate_allocateForGetObject));

    g_class_Texture2DPromise = rb_define_class_under(g_rootModule, "Texture2DPromise", g_class_Object);
    rb_define_alloc_func(g_class_Texture2DPromise, LNTexture2DPromise_allocate);
    rb_define_method(g_class_Texture2DPromise, "then_with", LN_TO_RUBY_FUNC(Wrap_LNTexture2DPromise_ThenWith), -1);
    rb_define_method(g_class_Texture2DPromise, "catch_with", LN_TO_RUBY_FUNC(Wrap_LNTexture2DPromise_CatchWith), -1);
    LNTexture2DPromise_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Texture2DPromise, LNTexture2DPromise_allocateForGetObject));

    g_class_Graphics = rb_define_class_under(g_rootModule, "Graphics", rb_cObject);
    rb_define_singleton_method(g_class_Graphics, "active_graphics_api", LN_TO_RUBY_FUNC(Wrap_LNGraphics_GetActiveGraphicsAPI), -1);

    g_class_Texture = rb_define_class_under(g_rootModule, "Texture", g_class_AssetObject);
    rb_define_alloc_func(g_class_Texture, LNTexture_allocate);
    LNTexture_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Texture, LNTexture_allocateForGetObject));
    LNTexture_OnSerialize_SetOverrideCallback(Wrap_LNTexture_OnSerialize_OverrideCallback);

    g_class_Texture2D = rb_define_class_under(g_rootModule, "Texture2D", g_class_Texture);
    rb_define_alloc_func(g_class_Texture2D, LNTexture2D_allocate);
    rb_define_private_method(g_class_Texture2D, "initialize", LN_TO_RUBY_FUNC(Wrap_LNTexture2D_Create), -1);
    rb_define_singleton_method(g_class_Texture2D, "load", LN_TO_RUBY_FUNC(Wrap_LNTexture2D_Load), -1);
    rb_define_singleton_method(g_class_Texture2D, "load_emoji", LN_TO_RUBY_FUNC(Wrap_LNTexture2D_LoadEmoji), -1);
    LNTexture2D_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Texture2D, LNTexture2D_allocateForGetObject));
    LNTexture2D_OnSerialize_SetOverrideCallback(Wrap_LNTexture2D_OnSerialize_OverrideCallback);

    g_class_Shader = rb_define_class_under(g_rootModule, "Shader", g_class_AssetObject);
    rb_define_alloc_func(g_class_Shader, LNShader_allocate);
    rb_define_singleton_method(g_class_Shader, "load", LN_TO_RUBY_FUNC(Wrap_LNShader_Load), -1);
    rb_define_method(g_class_Shader, "set_float", LN_TO_RUBY_FUNC(Wrap_LNShader_SetFloat), -1);
    rb_define_method(g_class_Shader, "set_vector", LN_TO_RUBY_FUNC(Wrap_LNShader_SetVector3), -1);
    rb_define_method(g_class_Shader, "set_texture", LN_TO_RUBY_FUNC(Wrap_LNShader_SetTexture), -1);
    LNShader_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Shader, LNShader_allocateForGetObject));
    LNShader_OnSerialize_SetOverrideCallback(Wrap_LNShader_OnSerialize_OverrideCallback);

    g_class_RenderView = rb_define_class_under(g_rootModule, "RenderView", g_class_Object);
    rb_define_alloc_func(g_class_RenderView, LNRenderView_allocate);
    LNRenderView_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_RenderView, LNRenderView_allocateForGetObject));
    LNRenderView_OnSerialize_SetOverrideCallback(Wrap_LNRenderView_OnSerialize_OverrideCallback);

    g_class_Material = rb_define_class_under(g_rootModule, "Material", g_class_Object);
    rb_define_alloc_func(g_class_Material, LNMaterial_allocate);
    rb_define_private_method(g_class_Material, "initialize", LN_TO_RUBY_FUNC(Wrap_LNMaterial_Create), -1);
    rb_define_method(g_class_Material, "main_texture=", LN_TO_RUBY_FUNC(Wrap_LNMaterial_SetMainTexture), -1);
    rb_define_method(g_class_Material, "main_texture", LN_TO_RUBY_FUNC(Wrap_LNMaterial_GetMainTexture), -1);
    rb_define_method(g_class_Material, "color=", LN_TO_RUBY_FUNC(Wrap_LNMaterial_SetColor), -1);
    rb_define_method(g_class_Material, "roughness=", LN_TO_RUBY_FUNC(Wrap_LNMaterial_SetRoughness), -1);
    rb_define_method(g_class_Material, "metallic=", LN_TO_RUBY_FUNC(Wrap_LNMaterial_SetMetallic), -1);
    rb_define_method(g_class_Material, "emissive=", LN_TO_RUBY_FUNC(Wrap_LNMaterial_SetEmissive), -1);
    rb_define_method(g_class_Material, "shading_model=", LN_TO_RUBY_FUNC(Wrap_LNMaterial_SetShadingModel), -1);
    rb_define_method(g_class_Material, "shading_model", LN_TO_RUBY_FUNC(Wrap_LNMaterial_GetShadingModel), -1);
    rb_define_method(g_class_Material, "shader=", LN_TO_RUBY_FUNC(Wrap_LNMaterial_SetShader), -1);
    rb_define_method(g_class_Material, "shader", LN_TO_RUBY_FUNC(Wrap_LNMaterial_GetShader), -1);
    LNMaterial_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Material, LNMaterial_allocateForGetObject));
    LNMaterial_OnSerialize_SetOverrideCallback(Wrap_LNMaterial_OnSerialize_OverrideCallback);

    g_class_MeshNode = rb_define_class_under(g_rootModule, "MeshNode", g_class_Object);
    rb_define_alloc_func(g_class_MeshNode, LNMeshNode_allocate);
    rb_define_method(g_class_MeshNode, "visible=", LN_TO_RUBY_FUNC(Wrap_LNMeshNode_SetVisible), -1);
    rb_define_method(g_class_MeshNode, "visible?", LN_TO_RUBY_FUNC(Wrap_LNMeshNode_IsVisible), -1);
    LNMeshNode_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_MeshNode, LNMeshNode_allocateForGetObject));
    LNMeshNode_OnSerialize_SetOverrideCallback(Wrap_LNMeshNode_OnSerialize_OverrideCallback);

    g_class_AnimationController = rb_define_class_under(g_rootModule, "AnimationController", g_class_Object);
    rb_define_alloc_func(g_class_AnimationController, LNAnimationController_allocate);
    rb_define_method(g_class_AnimationController, "add_clip", LN_TO_RUBY_FUNC(Wrap_LNAnimationController_AddClip), -1);
    rb_define_method(g_class_AnimationController, "play", LN_TO_RUBY_FUNC(Wrap_LNAnimationController_Play), -1);
    LNAnimationController_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AnimationController, LNAnimationController_allocateForGetObject));
    LNAnimationController_OnSerialize_SetOverrideCallback(Wrap_LNAnimationController_OnSerialize_OverrideCallback);

    g_class_MeshModel = rb_define_class_under(g_rootModule, "MeshModel", g_class_Object);
    rb_define_alloc_func(g_class_MeshModel, LNMeshModel_allocate);
    rb_define_singleton_method(g_class_MeshModel, "load", LN_TO_RUBY_FUNC(Wrap_LNMeshModel_Load), -1);
    rb_define_method(g_class_MeshModel, "find_node", LN_TO_RUBY_FUNC(Wrap_LNMeshModel_FindNode), -1);
    rb_define_method(g_class_MeshModel, "find_material", LN_TO_RUBY_FUNC(Wrap_LNMeshModel_FindMaterial), -1);
    rb_define_method(g_class_MeshModel, "material_count", LN_TO_RUBY_FUNC(Wrap_LNMeshModel_MaterialCount), -1);
    rb_define_method(g_class_MeshModel, "material", LN_TO_RUBY_FUNC(Wrap_LNMeshModel_Material), -1);
    rb_define_method(g_class_MeshModel, "animation_controller", LN_TO_RUBY_FUNC(Wrap_LNMeshModel_GetAnimationController), -1);
    LNMeshModel_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_MeshModel, LNMeshModel_allocateForGetObject));
    LNMeshModel_OnSerialize_SetOverrideCallback(Wrap_LNMeshModel_OnSerialize_OverrideCallback);

    g_class_MeshImportSettings = rb_define_class_under(g_rootModule, "MeshImportSettings", g_class_Object);
    rb_define_alloc_func(g_class_MeshImportSettings, LNMeshImportSettings_allocate);
    rb_define_private_method(g_class_MeshImportSettings, "initialize", LN_TO_RUBY_FUNC(Wrap_LNMeshImportSettings_Create), -1);
    LNMeshImportSettings_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_MeshImportSettings, LNMeshImportSettings_allocateForGetObject));
    LNMeshImportSettings_OnSerialize_SetOverrideCallback(Wrap_LNMeshImportSettings_OnSerialize_OverrideCallback);

    g_class_SkinnedMeshModel = rb_define_class_under(g_rootModule, "SkinnedMeshModel", g_class_MeshModel);
    rb_define_alloc_func(g_class_SkinnedMeshModel, LNSkinnedMeshModel_allocate);
    LNSkinnedMeshModel_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SkinnedMeshModel, LNSkinnedMeshModel_allocateForGetObject));
    LNSkinnedMeshModel_OnSerialize_SetOverrideCallback(Wrap_LNSkinnedMeshModel_OnSerialize_OverrideCallback);

    g_class_CollisionShape = rb_define_class_under(g_rootModule, "CollisionShape", g_class_Object);
    rb_define_alloc_func(g_class_CollisionShape, LNCollisionShape_allocate);
    LNCollisionShape_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_CollisionShape, LNCollisionShape_allocateForGetObject));
    LNCollisionShape_OnSerialize_SetOverrideCallback(Wrap_LNCollisionShape_OnSerialize_OverrideCallback);

    g_class_BoxCollisionShape = rb_define_class_under(g_rootModule, "BoxCollisionShape", g_class_CollisionShape);
    rb_define_alloc_func(g_class_BoxCollisionShape, LNBoxCollisionShape_allocate);
    rb_define_private_method(g_class_BoxCollisionShape, "initialize", LN_TO_RUBY_FUNC(Wrap_LNBoxCollisionShape_Create), -1);
    LNBoxCollisionShape_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_BoxCollisionShape, LNBoxCollisionShape_allocateForGetObject));
    LNBoxCollisionShape_OnSerialize_SetOverrideCallback(Wrap_LNBoxCollisionShape_OnSerialize_OverrideCallback);

    g_class_AnimationCurve = rb_define_class_under(g_rootModule, "AnimationCurve", g_class_Object);
    rb_define_alloc_func(g_class_AnimationCurve, LNAnimationCurve_allocate);
    rb_define_method(g_class_AnimationCurve, "evaluate", LN_TO_RUBY_FUNC(Wrap_LNAnimationCurve_Evaluate), -1);
    LNAnimationCurve_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AnimationCurve, LNAnimationCurve_allocateForGetObject));
    LNAnimationCurve_OnSerialize_SetOverrideCallback(Wrap_LNAnimationCurve_OnSerialize_OverrideCallback);

    g_class_KeyFrameAnimationCurve = rb_define_class_under(g_rootModule, "KeyFrameAnimationCurve", g_class_AnimationCurve);
    rb_define_alloc_func(g_class_KeyFrameAnimationCurve, LNKeyFrameAnimationCurve_allocate);
    rb_define_private_method(g_class_KeyFrameAnimationCurve, "initialize", LN_TO_RUBY_FUNC(Wrap_LNKeyFrameAnimationCurve_Create), -1);
    rb_define_method(g_class_KeyFrameAnimationCurve, "add_key_frame", LN_TO_RUBY_FUNC(Wrap_LNKeyFrameAnimationCurve_AddKeyFrame), -1);
    LNKeyFrameAnimationCurve_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_KeyFrameAnimationCurve, LNKeyFrameAnimationCurve_allocateForGetObject));
    LNKeyFrameAnimationCurve_OnSerialize_SetOverrideCallback(Wrap_LNKeyFrameAnimationCurve_OnSerialize_OverrideCallback);

    g_class_AnimationClip = rb_define_class_under(g_rootModule, "AnimationClip", g_class_AssetObject);
    rb_define_alloc_func(g_class_AnimationClip, LNAnimationClip_allocate);
    rb_define_singleton_method(g_class_AnimationClip, "load", LN_TO_RUBY_FUNC(Wrap_LNAnimationClip_Load), -1);
    rb_define_method(g_class_AnimationClip, "wrap_mode=", LN_TO_RUBY_FUNC(Wrap_LNAnimationClip_SetWrapMode), -1);
    rb_define_method(g_class_AnimationClip, "wrap_mode", LN_TO_RUBY_FUNC(Wrap_LNAnimationClip_GetWrapMode), -1);
    rb_define_method(g_class_AnimationClip, "hierarchical_animation_mode=", LN_TO_RUBY_FUNC(Wrap_LNAnimationClip_SetHierarchicalAnimationMode), -1);
    rb_define_method(g_class_AnimationClip, "hierarchical_animation_mode", LN_TO_RUBY_FUNC(Wrap_LNAnimationClip_GetHierarchicalAnimationMode), -1);
    LNAnimationClip_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AnimationClip, LNAnimationClip_allocateForGetObject));
    LNAnimationClip_OnSerialize_SetOverrideCallback(Wrap_LNAnimationClip_OnSerialize_OverrideCallback);

    g_class_AnimationState = rb_define_class_under(g_rootModule, "AnimationState", g_class_Object);
    rb_define_alloc_func(g_class_AnimationState, LNAnimationState_allocate);
    LNAnimationState_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AnimationState, LNAnimationState_allocateForGetObject));
    LNAnimationState_OnSerialize_SetOverrideCallback(Wrap_LNAnimationState_OnSerialize_OverrideCallback);

    g_class_EffectResource = rb_define_class_under(g_rootModule, "EffectResource", g_class_AssetObject);
    rb_define_alloc_func(g_class_EffectResource, LNEffectResource_allocate);
    LNEffectResource_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_EffectResource, LNEffectResource_allocateForGetObject));
    LNEffectResource_OnSerialize_SetOverrideCallback(Wrap_LNEffectResource_OnSerialize_OverrideCallback);

    g_class_ParticleEmitterModel = rb_define_class_under(g_rootModule, "ParticleEmitterModel", g_class_Object);
    rb_define_alloc_func(g_class_ParticleEmitterModel, LNParticleEmitterModel_allocate);
    rb_define_private_method(g_class_ParticleEmitterModel, "initialize", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModel_Create), -1);
    rb_define_method(g_class_ParticleEmitterModel, "max_particles=", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModel_SetMaxParticles), -1);
    rb_define_method(g_class_ParticleEmitterModel, "spawn_rate=", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModel_SetSpawnRate), -1);
    rb_define_method(g_class_ParticleEmitterModel, "life_time=", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModel_SetLifeTime), -1);
    rb_define_method(g_class_ParticleEmitterModel, "up_box_shape=", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModel_SetupBoxShape), -1);
    rb_define_method(g_class_ParticleEmitterModel, "size=", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModel_SetSize), -1);
    rb_define_method(g_class_ParticleEmitterModel, "size_velocity=", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModel_SetSizeVelocity), -1);
    rb_define_method(g_class_ParticleEmitterModel, "size_acceleration=", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModel_SetSizeAcceleration), -1);
    rb_define_method(g_class_ParticleEmitterModel, "forward_velocity_min=", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModel_SetForwardVelocityMin), -1);
    rb_define_method(g_class_ParticleEmitterModel, "forward_velocity_max=", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModel_SetForwardVelocityMax), -1);
    rb_define_method(g_class_ParticleEmitterModel, "forward_scale=", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModel_SetForwardScale), -1);
    rb_define_method(g_class_ParticleEmitterModel, "geometry_direction=", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModel_SetGeometryDirection), -1);
    rb_define_method(g_class_ParticleEmitterModel, "setup_sprite_module", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModel_SetupSpriteModule), -1);
    LNParticleEmitterModel_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ParticleEmitterModel, LNParticleEmitterModel_allocateForGetObject));
    LNParticleEmitterModel_OnSerialize_SetOverrideCallback(Wrap_LNParticleEmitterModel_OnSerialize_OverrideCallback);

    g_class_ParticleModel = rb_define_class_under(g_rootModule, "ParticleModel", g_class_EffectResource);
    rb_define_alloc_func(g_class_ParticleModel, LNParticleModel_allocate);
    rb_define_private_method(g_class_ParticleModel, "initialize", LN_TO_RUBY_FUNC(Wrap_LNParticleModel_Create), -1);
    rb_define_method(g_class_ParticleModel, "loop=", LN_TO_RUBY_FUNC(Wrap_LNParticleModel_SetLoop), -1);
    rb_define_method(g_class_ParticleModel, "loop?", LN_TO_RUBY_FUNC(Wrap_LNParticleModel_IsLoop), -1);
    rb_define_method(g_class_ParticleModel, "add_emitter", LN_TO_RUBY_FUNC(Wrap_LNParticleModel_AddEmitter), -1);
    LNParticleModel_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ParticleModel, LNParticleModel_allocateForGetObject));
    LNParticleModel_OnSerialize_SetOverrideCallback(Wrap_LNParticleModel_OnSerialize_OverrideCallback);

    g_class_Component = rb_define_class_under(g_rootModule, "Component", g_class_Object);
    rb_define_alloc_func(g_class_Component, LNComponent_allocate);
    LNComponent_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Component, LNComponent_allocateForGetObject));
    LNComponent_OnSerialize_SetOverrideCallback(Wrap_LNComponent_OnSerialize_OverrideCallback);

    g_class_VisualComponent = rb_define_class_under(g_rootModule, "VisualComponent", g_class_Component);
    rb_define_alloc_func(g_class_VisualComponent, LNVisualComponent_allocate);
    rb_define_method(g_class_VisualComponent, "visible=", LN_TO_RUBY_FUNC(Wrap_LNVisualComponent_SetVisible), -1);
    rb_define_method(g_class_VisualComponent, "visible?", LN_TO_RUBY_FUNC(Wrap_LNVisualComponent_IsVisible), -1);
    LNVisualComponent_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_VisualComponent, LNVisualComponent_allocateForGetObject));
    LNVisualComponent_OnSerialize_SetOverrideCallback(Wrap_LNVisualComponent_OnSerialize_OverrideCallback);

    g_class_SpriteComponent = rb_define_class_under(g_rootModule, "SpriteComponent", g_class_VisualComponent);
    rb_define_alloc_func(g_class_SpriteComponent, LNSpriteComponent_allocate);
    rb_define_method(g_class_SpriteComponent, "texture=", LN_TO_RUBY_FUNC(Wrap_LNSpriteComponent_SetTexture), -1);
    LNSpriteComponent_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SpriteComponent, LNSpriteComponent_allocateForGetObject));
    LNSpriteComponent_OnSerialize_SetOverrideCallback(Wrap_LNSpriteComponent_OnSerialize_OverrideCallback);

    g_class_CollisionEventHandler = rb_define_class_under(g_rootModule, "CollisionEventHandler", g_class_Object);
    rb_define_alloc_func(g_class_CollisionEventHandler, LNCollisionEventHandler_allocate);
    rb_define_private_method(g_class_CollisionEventHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNCollisionEventHandler_Create), -1);
    LNCollisionEventHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_CollisionEventHandler, LNCollisionEventHandler_allocateForGetObject));

    g_class_CharacterController = rb_define_class_under(g_rootModule, "CharacterController", g_class_Component);
    rb_define_alloc_func(g_class_CharacterController, LNCharacterController_allocate);
    rb_define_private_method(g_class_CharacterController, "initialize", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_Create), -1);
    rb_define_method(g_class_CharacterController, "walk_velocity=", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_SetWalkVelocity), -1);
    rb_define_method(g_class_CharacterController, "walk_velocity", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_GetWalkVelocity), -1);
    rb_define_method(g_class_CharacterController, "velocity=", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_SetVelocity), -1);
    rb_define_method(g_class_CharacterController, "velocity", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_GetVelocity), -1);
    rb_define_method(g_class_CharacterController, "input_control_enabled=", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_SetInputControlEnabled), -1);
    rb_define_method(g_class_CharacterController, "camera_control_enabled=", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_SetCameraControlEnabled), -1);
    rb_define_method(g_class_CharacterController, "height=", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_SetHeight), -1);
    rb_define_method(g_class_CharacterController, "height", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_GetHeight), -1);
    rb_define_method(g_class_CharacterController, "camera_radius=", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_SetCameraRadius), -1);
    rb_define_method(g_class_CharacterController, "camera_radius", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_GetCameraRadius), -1);
    rb_define_method(g_class_CharacterController, "set_collision_enter", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_SetCollisionEnter), -1);
    rb_define_method(g_class_CharacterController, "set_collision_leave", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_SetCollisionLeave), -1);
    rb_define_method(g_class_CharacterController, "set_collision_stay", LN_TO_RUBY_FUNC(Wrap_LNCharacterController_SetCollisionStay), -1);
    LNCharacterController_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_CharacterController, LNCharacterController_allocateForGetObject));
    LNCharacterController_OnSerialize_SetOverrideCallback(Wrap_LNCharacterController_OnSerialize_OverrideCallback);

    g_class_World = rb_define_class_under(g_rootModule, "World", g_class_Object);
    rb_define_alloc_func(g_class_World, LNWorld_allocate);
    rb_define_method(g_class_World, "add", LN_TO_RUBY_FUNC(Wrap_LNWorld_Add), -1);
    LNWorld_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_World, LNWorld_allocateForGetObject));
    LNWorld_OnSerialize_SetOverrideCallback(Wrap_LNWorld_OnSerialize_OverrideCallback);

    g_class_ComponentList = rb_define_class_under(g_rootModule, "ComponentList", g_class_Object);
    rb_define_alloc_func(g_class_ComponentList, LNComponentList_allocate);
    rb_define_method(g_class_ComponentList, "get_length", LN_TO_RUBY_FUNC(Wrap_LNComponentList_GetLength), -1);
    rb_define_method(g_class_ComponentList, "get_item", LN_TO_RUBY_FUNC(Wrap_LNComponentList_GetItem), -1);
    LNComponentList_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ComponentList, LNComponentList_allocateForGetObject));
    LNComponentList_OnSerialize_SetOverrideCallback(Wrap_LNComponentList_OnSerialize_OverrideCallback);

    g_class_WorldObject = rb_define_class_under(g_rootModule, "WorldObject", g_class_Object);
    rb_define_alloc_func(g_class_WorldObject, LNWorldObject_allocate);
    rb_define_private_method(g_class_WorldObject, "initialize", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_Create), -1);
    rb_define_method(g_class_WorldObject, "position=", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_SetPosition), -1);
    rb_define_method(g_class_WorldObject, "set_position", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_SetPosition), -1);
    rb_define_method(g_class_WorldObject, "position", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_GetPosition), -1);
    rb_define_method(g_class_WorldObject, "set_rotation", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_SetRotation), -1);
    rb_define_method(g_class_WorldObject, "rotation", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_GetRotation), -1);
    rb_define_method(g_class_WorldObject, "scale=", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_SetScale), -1);
    rb_define_method(g_class_WorldObject, "set_scale", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_SetScale), -1);
    rb_define_method(g_class_WorldObject, "scale", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_GetScale), -1);
    rb_define_method(g_class_WorldObject, "center_point=", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_SetCenterPoint), -1);
    rb_define_method(g_class_WorldObject, "set_center_point", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_SetCenterPoint), -1);
    rb_define_method(g_class_WorldObject, "center_point", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_GetCenterPoint), -1);
    rb_define_method(g_class_WorldObject, "look_at", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_LookAt), -1);
    rb_define_method(g_class_WorldObject, "add_component", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_AddComponent), -1);
    rb_define_method(g_class_WorldObject, "remove_component", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_RemoveComponent), -1);
    rb_define_method(g_class_WorldObject, "add_tag", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_AddTag), -1);
    rb_define_method(g_class_WorldObject, "remove_tag", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_RemoveTag), -1);
    rb_define_method(g_class_WorldObject, "has_tag", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_HasTag), -1);
    rb_define_method(g_class_WorldObject, "destroy", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_Destroy), -1);
    rb_define_method(g_class_WorldObject, "components", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_GetComponents), -1);
    rb_define_method(g_class_WorldObject, "on_pre_update", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_OnPreUpdate), -1);
    rb_define_method(g_class_WorldObject, "on_update", LN_TO_RUBY_FUNC(Wrap_LNWorldObject_OnUpdate), -1);
    LNWorldObject_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_WorldObject, LNWorldObject_allocateForGetObject));
    LNWorldObject_OnSerialize_SetOverrideCallback(Wrap_LNWorldObject_OnSerialize_OverrideCallback);
    LNWorldObject_OnPreUpdate_SetOverrideCallback(Wrap_LNWorldObject_OnPreUpdate_OverrideCallback);
    LNWorldObject_OnUpdate_SetOverrideCallback(Wrap_LNWorldObject_OnUpdate_OverrideCallback);

    g_class_VisualObject = rb_define_class_under(g_rootModule, "VisualObject", g_class_WorldObject);
    rb_define_alloc_func(g_class_VisualObject, LNVisualObject_allocate);
    rb_define_method(g_class_VisualObject, "visible=", LN_TO_RUBY_FUNC(Wrap_LNVisualObject_SetVisible), -1);
    rb_define_method(g_class_VisualObject, "visible?", LN_TO_RUBY_FUNC(Wrap_LNVisualObject_IsVisible), -1);
    rb_define_method(g_class_VisualObject, "blend_mode_2=", LN_TO_RUBY_FUNC(Wrap_LNVisualObject_SetBlendMode2), -1);
    rb_define_method(g_class_VisualObject, "opacity=", LN_TO_RUBY_FUNC(Wrap_LNVisualObject_SetOpacity), -1);
    rb_define_method(g_class_VisualObject, "opacity", LN_TO_RUBY_FUNC(Wrap_LNVisualObject_GetOpacity), -1);
    LNVisualObject_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_VisualObject, LNVisualObject_allocateForGetObject));
    LNVisualObject_OnSerialize_SetOverrideCallback(Wrap_LNVisualObject_OnSerialize_OverrideCallback);
    LNVisualObject_OnPreUpdate_SetOverrideCallback(Wrap_LNVisualObject_OnPreUpdate_OverrideCallback);
    LNVisualObject_OnUpdate_SetOverrideCallback(Wrap_LNVisualObject_OnUpdate_OverrideCallback);

    g_class_Camera = rb_define_class_under(g_rootModule, "Camera", g_class_WorldObject);
    rb_define_alloc_func(g_class_Camera, LNCamera_allocate);
    LNCamera_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Camera, LNCamera_allocateForGetObject));
    LNCamera_OnSerialize_SetOverrideCallback(Wrap_LNCamera_OnSerialize_OverrideCallback);
    LNCamera_OnPreUpdate_SetOverrideCallback(Wrap_LNCamera_OnPreUpdate_OverrideCallback);
    LNCamera_OnUpdate_SetOverrideCallback(Wrap_LNCamera_OnUpdate_OverrideCallback);

    g_class_EnvironmentLight = rb_define_class_under(g_rootModule, "EnvironmentLight", g_class_WorldObject);
    rb_define_alloc_func(g_class_EnvironmentLight, LNEnvironmentLight_allocate);
    rb_define_method(g_class_EnvironmentLight, "enabled=", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_SetEnabled), -1);
    rb_define_method(g_class_EnvironmentLight, "enabled?", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_IsEnabled), -1);
    rb_define_method(g_class_EnvironmentLight, "color=", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_SetColor), -1);
    rb_define_method(g_class_EnvironmentLight, "color", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_GetColor), -1);
    rb_define_method(g_class_EnvironmentLight, "ambient_color=", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_SetAmbientColor), -1);
    rb_define_method(g_class_EnvironmentLight, "ambient_color", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_GetAmbientColor), -1);
    rb_define_method(g_class_EnvironmentLight, "sky_color", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_GetSkyColor), -1);
    rb_define_method(g_class_EnvironmentLight, "sky_color=", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_SetSkyColor), -1);
    rb_define_method(g_class_EnvironmentLight, "ground_color", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_GetGroundColor), -1);
    rb_define_method(g_class_EnvironmentLight, "ground_color=", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_SetGroundColor), -1);
    rb_define_method(g_class_EnvironmentLight, "intensity=", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_SetIntensity), -1);
    rb_define_method(g_class_EnvironmentLight, "intensity", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_GetIntensity), -1);
    rb_define_method(g_class_EnvironmentLight, "shadow_effective_distance=", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_SetShadowEffectiveDistance), -1);
    rb_define_method(g_class_EnvironmentLight, "shadow_effective_distance", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_GetShadowEffectiveDistance), -1);
    rb_define_method(g_class_EnvironmentLight, "shadow_effective_depth=", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_SetShadowEffectiveDepth), -1);
    rb_define_method(g_class_EnvironmentLight, "shadow_effective_depth", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLight_GetShadowEffectiveDepth), -1);
    LNEnvironmentLight_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_EnvironmentLight, LNEnvironmentLight_allocateForGetObject));
    LNEnvironmentLight_OnSerialize_SetOverrideCallback(Wrap_LNEnvironmentLight_OnSerialize_OverrideCallback);
    LNEnvironmentLight_OnPreUpdate_SetOverrideCallback(Wrap_LNEnvironmentLight_OnPreUpdate_OverrideCallback);
    LNEnvironmentLight_OnUpdate_SetOverrideCallback(Wrap_LNEnvironmentLight_OnUpdate_OverrideCallback);

    g_class_DirectionalLight = rb_define_class_under(g_rootModule, "DirectionalLight", g_class_WorldObject);
    rb_define_alloc_func(g_class_DirectionalLight, LNDirectionalLight_allocate);
    rb_define_private_method(g_class_DirectionalLight, "initialize", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLight_Create), -1);
    rb_define_method(g_class_DirectionalLight, "enabled=", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLight_SetEnabled), -1);
    rb_define_method(g_class_DirectionalLight, "enabled?", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLight_IsEnabled), -1);
    rb_define_method(g_class_DirectionalLight, "color=", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLight_SetColor), -1);
    rb_define_method(g_class_DirectionalLight, "color", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLight_GetColor), -1);
    rb_define_method(g_class_DirectionalLight, "intensity=", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLight_SetIntensity), -1);
    rb_define_method(g_class_DirectionalLight, "intensity", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLight_GetIntensity), -1);
    rb_define_method(g_class_DirectionalLight, "shadow_effective_distance=", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLight_SetShadowEffectiveDistance), -1);
    rb_define_method(g_class_DirectionalLight, "shadow_effective_distance", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLight_GetShadowEffectiveDistance), -1);
    rb_define_method(g_class_DirectionalLight, "shadow_effective_depth=", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLight_SetShadowEffectiveDepth), -1);
    rb_define_method(g_class_DirectionalLight, "shadow_effective_depth", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLight_GetShadowEffectiveDepth), -1);
    LNDirectionalLight_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_DirectionalLight, LNDirectionalLight_allocateForGetObject));
    LNDirectionalLight_OnSerialize_SetOverrideCallback(Wrap_LNDirectionalLight_OnSerialize_OverrideCallback);
    LNDirectionalLight_OnPreUpdate_SetOverrideCallback(Wrap_LNDirectionalLight_OnPreUpdate_OverrideCallback);
    LNDirectionalLight_OnUpdate_SetOverrideCallback(Wrap_LNDirectionalLight_OnUpdate_OverrideCallback);

    g_class_PointLight = rb_define_class_under(g_rootModule, "PointLight", g_class_WorldObject);
    rb_define_alloc_func(g_class_PointLight, LNPointLight_allocate);
    rb_define_private_method(g_class_PointLight, "initialize", LN_TO_RUBY_FUNC(Wrap_LNPointLight_Create), -1);
    rb_define_method(g_class_PointLight, "enabled=", LN_TO_RUBY_FUNC(Wrap_LNPointLight_SetEnabled), -1);
    rb_define_method(g_class_PointLight, "enabled?", LN_TO_RUBY_FUNC(Wrap_LNPointLight_IsEnabled), -1);
    rb_define_method(g_class_PointLight, "color=", LN_TO_RUBY_FUNC(Wrap_LNPointLight_SetColor), -1);
    rb_define_method(g_class_PointLight, "color", LN_TO_RUBY_FUNC(Wrap_LNPointLight_GetColor), -1);
    rb_define_method(g_class_PointLight, "intensity=", LN_TO_RUBY_FUNC(Wrap_LNPointLight_SetIntensity), -1);
    rb_define_method(g_class_PointLight, "intensity", LN_TO_RUBY_FUNC(Wrap_LNPointLight_GetIntensity), -1);
    rb_define_method(g_class_PointLight, "range=", LN_TO_RUBY_FUNC(Wrap_LNPointLight_SetRange), -1);
    rb_define_method(g_class_PointLight, "range", LN_TO_RUBY_FUNC(Wrap_LNPointLight_GetRange), -1);
    rb_define_method(g_class_PointLight, "attenuation=", LN_TO_RUBY_FUNC(Wrap_LNPointLight_SetAttenuation), -1);
    rb_define_method(g_class_PointLight, "attenuation", LN_TO_RUBY_FUNC(Wrap_LNPointLight_GetAttenuation), -1);
    LNPointLight_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_PointLight, LNPointLight_allocateForGetObject));
    LNPointLight_OnSerialize_SetOverrideCallback(Wrap_LNPointLight_OnSerialize_OverrideCallback);
    LNPointLight_OnPreUpdate_SetOverrideCallback(Wrap_LNPointLight_OnPreUpdate_OverrideCallback);
    LNPointLight_OnUpdate_SetOverrideCallback(Wrap_LNPointLight_OnUpdate_OverrideCallback);

    g_class_SpotLight = rb_define_class_under(g_rootModule, "SpotLight", g_class_WorldObject);
    rb_define_alloc_func(g_class_SpotLight, LNSpotLight_allocate);
    rb_define_private_method(g_class_SpotLight, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_Create), -1);
    rb_define_method(g_class_SpotLight, "enabled=", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_SetEnabled), -1);
    rb_define_method(g_class_SpotLight, "enabled?", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_IsEnabled), -1);
    rb_define_method(g_class_SpotLight, "color=", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_SetColor), -1);
    rb_define_method(g_class_SpotLight, "color", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_GetColor), -1);
    rb_define_method(g_class_SpotLight, "intensity=", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_SetIntensity), -1);
    rb_define_method(g_class_SpotLight, "intensity", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_GetIntensity), -1);
    rb_define_method(g_class_SpotLight, "range=", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_SetRange), -1);
    rb_define_method(g_class_SpotLight, "range", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_GetRange), -1);
    rb_define_method(g_class_SpotLight, "attenuation=", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_SetAttenuation), -1);
    rb_define_method(g_class_SpotLight, "attenuation", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_GetAttenuation), -1);
    rb_define_method(g_class_SpotLight, "angle=", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_SetAngle), -1);
    rb_define_method(g_class_SpotLight, "angle", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_GetAngle), -1);
    rb_define_method(g_class_SpotLight, "penumbra=", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_SetPenumbra), -1);
    rb_define_method(g_class_SpotLight, "penumbra", LN_TO_RUBY_FUNC(Wrap_LNSpotLight_GetPenumbra), -1);
    LNSpotLight_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SpotLight, LNSpotLight_allocateForGetObject));
    LNSpotLight_OnSerialize_SetOverrideCallback(Wrap_LNSpotLight_OnSerialize_OverrideCallback);
    LNSpotLight_OnPreUpdate_SetOverrideCallback(Wrap_LNSpotLight_OnPreUpdate_OverrideCallback);
    LNSpotLight_OnUpdate_SetOverrideCallback(Wrap_LNSpotLight_OnUpdate_OverrideCallback);

    g_class_TestDelegate = rb_define_class_under(g_rootModule, "TestDelegate", g_class_Object);
    rb_define_alloc_func(g_class_TestDelegate, LNTestDelegate_allocate);
    rb_define_private_method(g_class_TestDelegate, "initialize", LN_TO_RUBY_FUNC(Wrap_LNTestDelegate_Create), -1);
    LNTestDelegate_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_TestDelegate, LNTestDelegate_allocateForGetObject));

    g_class_Sprite = rb_define_class_under(g_rootModule, "Sprite", g_class_VisualObject);
    rb_define_alloc_func(g_class_Sprite, LNSprite_allocate);
    rb_define_private_method(g_class_Sprite, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSprite_Create), -1);
    rb_define_method(g_class_Sprite, "texture=", LN_TO_RUBY_FUNC(Wrap_LNSprite_SetTexture), -1);
    rb_define_method(g_class_Sprite, "size=", LN_TO_RUBY_FUNC(Wrap_LNSprite_SetSize), -1);
    rb_define_method(g_class_Sprite, "set_size", LN_TO_RUBY_FUNC(Wrap_LNSprite_SetSize), -1);
    rb_define_method(g_class_Sprite, "set_source_rect", LN_TO_RUBY_FUNC(Wrap_LNSprite_SetSourceRectXYWH), -1);
    rb_define_method(g_class_Sprite, "set_caller_test", LN_TO_RUBY_FUNC(Wrap_LNSprite_SetCallerTest), -1);
    LNSprite_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Sprite, LNSprite_allocateForGetObject));
    LNSprite_OnSerialize_SetOverrideCallback(Wrap_LNSprite_OnSerialize_OverrideCallback);
    LNSprite_OnPreUpdate_SetOverrideCallback(Wrap_LNSprite_OnPreUpdate_OverrideCallback);
    LNSprite_OnUpdate_SetOverrideCallback(Wrap_LNSprite_OnUpdate_OverrideCallback);

    g_class_CameraOrbitControlComponent = rb_define_class_under(g_rootModule, "CameraOrbitControlComponent", g_class_Component);
    rb_define_alloc_func(g_class_CameraOrbitControlComponent, LNCameraOrbitControlComponent_allocate);
    rb_define_private_method(g_class_CameraOrbitControlComponent, "initialize", LN_TO_RUBY_FUNC(Wrap_LNCameraOrbitControlComponent_Create), -1);
    LNCameraOrbitControlComponent_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_CameraOrbitControlComponent, LNCameraOrbitControlComponent_allocateForGetObject));
    LNCameraOrbitControlComponent_OnSerialize_SetOverrideCallback(Wrap_LNCameraOrbitControlComponent_OnSerialize_OverrideCallback);

    g_class_Raycaster = rb_define_class_under(g_rootModule, "Raycaster", g_class_Object);
    rb_define_alloc_func(g_class_Raycaster, LNRaycaster_allocate);
    rb_define_singleton_method(g_class_Raycaster, "from_screen", LN_TO_RUBY_FUNC(Wrap_LNRaycaster_FromScreen), -1);
    rb_define_method(g_class_Raycaster, "intersect_plane", LN_TO_RUBY_FUNC(Wrap_LNRaycaster_IntersectPlane), -1);
    LNRaycaster_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Raycaster, LNRaycaster_allocateForGetObject));
    LNRaycaster_OnSerialize_SetOverrideCallback(Wrap_LNRaycaster_OnSerialize_OverrideCallback);

    g_class_RaycastResult = rb_define_class_under(g_rootModule, "RaycastResult", g_class_Object);
    rb_define_alloc_func(g_class_RaycastResult, LNRaycastResult_allocate);
    rb_define_method(g_class_RaycastResult, "point", LN_TO_RUBY_FUNC(Wrap_LNRaycastResult_GetPoint), -1);
    LNRaycastResult_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_RaycastResult, LNRaycastResult_allocateForGetObject));
    LNRaycastResult_OnSerialize_SetOverrideCallback(Wrap_LNRaycastResult_OnSerialize_OverrideCallback);

    g_class_WorldRenderView = rb_define_class_under(g_rootModule, "WorldRenderView", g_class_RenderView);
    rb_define_alloc_func(g_class_WorldRenderView, LNWorldRenderView_allocate);
    rb_define_method(g_class_WorldRenderView, "guide_grid_enabled=", LN_TO_RUBY_FUNC(Wrap_LNWorldRenderView_SetGuideGridEnabled), -1);
    rb_define_method(g_class_WorldRenderView, "guide_grid_enabled?", LN_TO_RUBY_FUNC(Wrap_LNWorldRenderView_GetGuideGridEnabled), -1);
    LNWorldRenderView_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_WorldRenderView, LNWorldRenderView_allocateForGetObject));
    LNWorldRenderView_OnSerialize_SetOverrideCallback(Wrap_LNWorldRenderView_OnSerialize_OverrideCallback);

    g_class_BoxMesh = rb_define_class_under(g_rootModule, "BoxMesh", g_class_VisualObject);
    rb_define_alloc_func(g_class_BoxMesh, LNBoxMesh_allocate);
    rb_define_private_method(g_class_BoxMesh, "initialize", LN_TO_RUBY_FUNC(Wrap_LNBoxMesh_Create), -1);
    LNBoxMesh_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_BoxMesh, LNBoxMesh_allocateForGetObject));
    LNBoxMesh_OnSerialize_SetOverrideCallback(Wrap_LNBoxMesh_OnSerialize_OverrideCallback);
    LNBoxMesh_OnPreUpdate_SetOverrideCallback(Wrap_LNBoxMesh_OnPreUpdate_OverrideCallback);
    LNBoxMesh_OnUpdate_SetOverrideCallback(Wrap_LNBoxMesh_OnUpdate_OverrideCallback);

    g_class_PlaneMesh = rb_define_class_under(g_rootModule, "PlaneMesh", g_class_VisualObject);
    rb_define_alloc_func(g_class_PlaneMesh, LNPlaneMesh_allocate);
    rb_define_private_method(g_class_PlaneMesh, "initialize", LN_TO_RUBY_FUNC(Wrap_LNPlaneMesh_Create), -1);
    LNPlaneMesh_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_PlaneMesh, LNPlaneMesh_allocateForGetObject));
    LNPlaneMesh_OnSerialize_SetOverrideCallback(Wrap_LNPlaneMesh_OnSerialize_OverrideCallback);
    LNPlaneMesh_OnPreUpdate_SetOverrideCallback(Wrap_LNPlaneMesh_OnPreUpdate_OverrideCallback);
    LNPlaneMesh_OnUpdate_SetOverrideCallback(Wrap_LNPlaneMesh_OnUpdate_OverrideCallback);

    g_class_StaticMesh = rb_define_class_under(g_rootModule, "StaticMesh", g_class_VisualObject);
    rb_define_alloc_func(g_class_StaticMesh, LNStaticMesh_allocate);
    rb_define_singleton_method(g_class_StaticMesh, "load", LN_TO_RUBY_FUNC(Wrap_LNStaticMesh_Load), -1);
    rb_define_method(g_class_StaticMesh, "model", LN_TO_RUBY_FUNC(Wrap_LNStaticMesh_GetModel), -1);
    rb_define_method(g_class_StaticMesh, "make_collision_body", LN_TO_RUBY_FUNC(Wrap_LNStaticMesh_MakeCollisionBody), -1);
    LNStaticMesh_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_StaticMesh, LNStaticMesh_allocateForGetObject));
    LNStaticMesh_OnSerialize_SetOverrideCallback(Wrap_LNStaticMesh_OnSerialize_OverrideCallback);
    LNStaticMesh_OnPreUpdate_SetOverrideCallback(Wrap_LNStaticMesh_OnPreUpdate_OverrideCallback);
    LNStaticMesh_OnUpdate_SetOverrideCallback(Wrap_LNStaticMesh_OnUpdate_OverrideCallback);

    g_class_StaticMeshComponent = rb_define_class_under(g_rootModule, "StaticMeshComponent", g_class_VisualComponent);
    rb_define_alloc_func(g_class_StaticMeshComponent, LNStaticMeshComponent_allocate);
    rb_define_private_method(g_class_StaticMeshComponent, "initialize", LN_TO_RUBY_FUNC(Wrap_LNStaticMeshComponent_Create), -1);
    rb_define_method(g_class_StaticMeshComponent, "set_model", LN_TO_RUBY_FUNC(Wrap_LNStaticMeshComponent_SetModel), -1);
    rb_define_method(g_class_StaticMeshComponent, "make_collision_body", LN_TO_RUBY_FUNC(Wrap_LNStaticMeshComponent_MakeCollisionBody), -1);
    LNStaticMeshComponent_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_StaticMeshComponent, LNStaticMeshComponent_allocateForGetObject));
    LNStaticMeshComponent_OnSerialize_SetOverrideCallback(Wrap_LNStaticMeshComponent_OnSerialize_OverrideCallback);

    g_class_SkinnedMeshComponent = rb_define_class_under(g_rootModule, "SkinnedMeshComponent", g_class_StaticMeshComponent);
    rb_define_alloc_func(g_class_SkinnedMeshComponent, LNSkinnedMeshComponent_allocate);
    rb_define_private_method(g_class_SkinnedMeshComponent, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSkinnedMeshComponent_Create), -1);
    LNSkinnedMeshComponent_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SkinnedMeshComponent, LNSkinnedMeshComponent_allocateForGetObject));
    LNSkinnedMeshComponent_OnSerialize_SetOverrideCallback(Wrap_LNSkinnedMeshComponent_OnSerialize_OverrideCallback);

    g_class_Collision = rb_define_class_under(g_rootModule, "Collision", g_class_Object);
    rb_define_alloc_func(g_class_Collision, LNCollision_allocate);
    rb_define_method(g_class_Collision, "world_object", LN_TO_RUBY_FUNC(Wrap_LNCollision_GetWorldObject), -1);
    LNCollision_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Collision, LNCollision_allocateForGetObject));
    LNCollision_OnSerialize_SetOverrideCallback(Wrap_LNCollision_OnSerialize_OverrideCallback);

    g_class_TriggerBodyComponent = rb_define_class_under(g_rootModule, "TriggerBodyComponent", g_class_Component);
    rb_define_alloc_func(g_class_TriggerBodyComponent, LNTriggerBodyComponent_allocate);
    rb_define_private_method(g_class_TriggerBodyComponent, "initialize", LN_TO_RUBY_FUNC(Wrap_LNTriggerBodyComponent_Create), -1);
    rb_define_method(g_class_TriggerBodyComponent, "add_collision_shape", LN_TO_RUBY_FUNC(Wrap_LNTriggerBodyComponent_AddCollisionShape), -1);
    LNTriggerBodyComponent_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_TriggerBodyComponent, LNTriggerBodyComponent_allocateForGetObject));
    LNTriggerBodyComponent_OnSerialize_SetOverrideCallback(Wrap_LNTriggerBodyComponent_OnSerialize_OverrideCallback);

    g_class_ParticleEmitter = rb_define_class_under(g_rootModule, "ParticleEmitter", g_class_VisualObject);
    rb_define_alloc_func(g_class_ParticleEmitter, LNParticleEmitter_allocate);
    rb_define_private_method(g_class_ParticleEmitter, "initialize", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitter_Create), -1);
    LNParticleEmitter_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ParticleEmitter, LNParticleEmitter_allocateForGetObject));
    LNParticleEmitter_OnSerialize_SetOverrideCallback(Wrap_LNParticleEmitter_OnSerialize_OverrideCallback);
    LNParticleEmitter_OnPreUpdate_SetOverrideCallback(Wrap_LNParticleEmitter_OnPreUpdate_OverrideCallback);
    LNParticleEmitter_OnUpdate_SetOverrideCallback(Wrap_LNParticleEmitter_OnUpdate_OverrideCallback);

    g_class_Scene = rb_define_class_under(g_rootModule, "Scene", rb_cObject);
    rb_define_singleton_method(g_class_Scene, "set_clear_mode", LN_TO_RUBY_FUNC(Wrap_LNScene_SetClearMode), -1);
    rb_define_singleton_method(g_class_Scene, "set_sky_color", LN_TO_RUBY_FUNC(Wrap_LNScene_SetSkyColor), -1);
    rb_define_singleton_method(g_class_Scene, "set_sky_horizon_color", LN_TO_RUBY_FUNC(Wrap_LNScene_SetSkyHorizonColor), -1);
    rb_define_singleton_method(g_class_Scene, "set_sky_cloud_color", LN_TO_RUBY_FUNC(Wrap_LNScene_SetSkyCloudColor), -1);
    rb_define_singleton_method(g_class_Scene, "set_sky_overlay_color", LN_TO_RUBY_FUNC(Wrap_LNScene_SetSkyOverlayColor), -1);
    rb_define_singleton_method(g_class_Scene, "goto_level", LN_TO_RUBY_FUNC(Wrap_LNScene_GotoLevel), -1);
    rb_define_singleton_method(g_class_Scene, "call_level", LN_TO_RUBY_FUNC(Wrap_LNScene_CallLevel), -1);
    rb_define_singleton_method(g_class_Scene, "return_level", LN_TO_RUBY_FUNC(Wrap_LNScene_ReturnLevel), -1);
    rb_define_singleton_method(g_class_Scene, "active_level", LN_TO_RUBY_FUNC(Wrap_LNScene_ActiveLevel), -1);
    rb_define_singleton_method(g_class_Scene, "is_transition_effect_running", LN_TO_RUBY_FUNC(Wrap_LNScene_IsTransitionEffectRunning), -1);
    rb_define_singleton_method(g_class_Scene, "set_transition_effect_mode", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTransitionEffectMode), -1);
    rb_define_singleton_method(g_class_Scene, "transition_effect_mode", LN_TO_RUBY_FUNC(Wrap_LNScene_TransitionEffectMode), -1);
    rb_define_singleton_method(g_class_Scene, "set_transition_duration", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTransitionDuration), -1);
    rb_define_singleton_method(g_class_Scene, "transition_duration", LN_TO_RUBY_FUNC(Wrap_LNScene_TransitionDuration), -1);
    rb_define_singleton_method(g_class_Scene, "set_transition_effect_color", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTransitionEffectColor), -1);
    rb_define_singleton_method(g_class_Scene, "transition_effect_color", LN_TO_RUBY_FUNC(Wrap_LNScene_TransitionEffectColor), -1);
    rb_define_singleton_method(g_class_Scene, "set_transition_effect_mask_texture", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTransitionEffectMaskTexture), -1);
    rb_define_singleton_method(g_class_Scene, "transition_effect_mask_texture", LN_TO_RUBY_FUNC(Wrap_LNScene_TransitionEffectMaskTexture), -1);
    rb_define_singleton_method(g_class_Scene, "set_transition_effect_vague", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTransitionEffectVague), -1);
    rb_define_singleton_method(g_class_Scene, "transition_effect_vague", LN_TO_RUBY_FUNC(Wrap_LNScene_TransitionEffectVague), -1);
    rb_define_singleton_method(g_class_Scene, "start_fade_out", LN_TO_RUBY_FUNC(Wrap_LNScene_StartFadeOut), -1);
    rb_define_singleton_method(g_class_Scene, "start_fade_in", LN_TO_RUBY_FUNC(Wrap_LNScene_StartFadeIn), -1);
    rb_define_singleton_method(g_class_Scene, "set_fog_start_distance", LN_TO_RUBY_FUNC(Wrap_LNScene_SetFogStartDistance), -1);
    rb_define_singleton_method(g_class_Scene, "set_fog_color", LN_TO_RUBY_FUNC(Wrap_LNScene_SetFogColor), -1);
    rb_define_singleton_method(g_class_Scene, "set_fog_density", LN_TO_RUBY_FUNC(Wrap_LNScene_SetFogDensity), -1);
    rb_define_singleton_method(g_class_Scene, "set_fog_height_density", LN_TO_RUBY_FUNC(Wrap_LNScene_SetFogHeightDensity), -1);
    rb_define_singleton_method(g_class_Scene, "set_fog_lower_height", LN_TO_RUBY_FUNC(Wrap_LNScene_SetFogLowerHeight), -1);
    rb_define_singleton_method(g_class_Scene, "set_fog_upper_height", LN_TO_RUBY_FUNC(Wrap_LNScene_SetFogUpperHeight), -1);
    rb_define_singleton_method(g_class_Scene, "set_hdr_enabled", LN_TO_RUBY_FUNC(Wrap_LNScene_SetHDREnabled), -1);
    rb_define_singleton_method(g_class_Scene, "is_hdr_enabled", LN_TO_RUBY_FUNC(Wrap_LNScene_IsHDREnabled), -1);
    rb_define_singleton_method(g_class_Scene, "set_screen_blend_color", LN_TO_RUBY_FUNC(Wrap_LNScene_SetScreenBlendColor), -1);
    rb_define_singleton_method(g_class_Scene, "screen_blend_color", LN_TO_RUBY_FUNC(Wrap_LNScene_ScreenBlendColor), -1);
    rb_define_singleton_method(g_class_Scene, "set_color_tone", LN_TO_RUBY_FUNC(Wrap_LNScene_SetColorTone), -1);
    rb_define_singleton_method(g_class_Scene, "color_tone", LN_TO_RUBY_FUNC(Wrap_LNScene_ColorTone), -1);
    rb_define_singleton_method(g_class_Scene, "antialias_enabled=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetAntialiasEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "antialias_enabled?", LN_TO_RUBY_FUNC(Wrap_LNScene_IsAntialiasEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "ssr_enabled=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetSSREnabled), -1);
    rb_define_singleton_method(g_class_Scene, "ssr_enabled?", LN_TO_RUBY_FUNC(Wrap_LNScene_IsSSREnabled), -1);
    rb_define_singleton_method(g_class_Scene, "ssao_enabled=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetSSAOEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "ssao_enabled?", LN_TO_RUBY_FUNC(Wrap_LNScene_IsSSAOEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "bloom_enabled=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetBloomEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "bloom_enabled?", LN_TO_RUBY_FUNC(Wrap_LNScene_IsBloomEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "dof_enabled=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetDOFEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "dof_enabled?", LN_TO_RUBY_FUNC(Wrap_LNScene_IsDOFEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "tonemap_enabled=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTonemapEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "tonemap_enabled?", LN_TO_RUBY_FUNC(Wrap_LNScene_IsTonemapEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "vignette_enabled=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetVignetteEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "vignette_enabled?", LN_TO_RUBY_FUNC(Wrap_LNScene_IsVignetteEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "gamma_enabled=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetGammaEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "gamma_enabled?", LN_TO_RUBY_FUNC(Wrap_LNScene_IsGammaEnabled), -1);
    rb_define_singleton_method(g_class_Scene, "tonemap_exposure=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTonemapExposure), -1);
    rb_define_singleton_method(g_class_Scene, "tonemap_linear_white=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTonemapLinearWhite), -1);
    rb_define_singleton_method(g_class_Scene, "tonemap_shoulder_strength=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTonemapShoulderStrength), -1);
    rb_define_singleton_method(g_class_Scene, "tonemap_linear_strength=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTonemapLinearStrength), -1);
    rb_define_singleton_method(g_class_Scene, "tonemap_linear_angle=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTonemapLinearAngle), -1);
    rb_define_singleton_method(g_class_Scene, "tonemap_toe_strength=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTonemapToeStrength), -1);
    rb_define_singleton_method(g_class_Scene, "tonemap_toe_numerator=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTonemapToeNumerator), -1);
    rb_define_singleton_method(g_class_Scene, "tonemap_toe_denominator=", LN_TO_RUBY_FUNC(Wrap_LNScene_SetTonemapToeDenominator), -1);

    g_class_Level = rb_define_class_under(g_rootModule, "Level", g_class_AssetObject);
    rb_define_alloc_func(g_class_Level, LNLevel_allocate);
    rb_define_private_method(g_class_Level, "initialize", LN_TO_RUBY_FUNC(Wrap_LNLevel_Create), -1);
    rb_define_method(g_class_Level, "add_object", LN_TO_RUBY_FUNC(Wrap_LNLevel_AddObject), -1);
    rb_define_method(g_class_Level, "remove_object", LN_TO_RUBY_FUNC(Wrap_LNLevel_RemoveObject), -1);
    rb_define_method(g_class_Level, "add_sub_level", LN_TO_RUBY_FUNC(Wrap_LNLevel_AddSubLevel), -1);
    rb_define_method(g_class_Level, "remove_sub_level", LN_TO_RUBY_FUNC(Wrap_LNLevel_RemoveSubLevel), -1);
    rb_define_method(g_class_Level, "remove_all_sub_levels", LN_TO_RUBY_FUNC(Wrap_LNLevel_RemoveAllSubLevels), -1);
    rb_define_method(g_class_Level, "on_start", LN_TO_RUBY_FUNC(Wrap_LNLevel_OnStart), -1);
    rb_define_method(g_class_Level, "on_stop", LN_TO_RUBY_FUNC(Wrap_LNLevel_OnStop), -1);
    rb_define_method(g_class_Level, "on_pause", LN_TO_RUBY_FUNC(Wrap_LNLevel_OnPause), -1);
    rb_define_method(g_class_Level, "on_resume", LN_TO_RUBY_FUNC(Wrap_LNLevel_OnResume), -1);
    rb_define_method(g_class_Level, "on_update", LN_TO_RUBY_FUNC(Wrap_LNLevel_OnUpdate), -1);
    LNLevel_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Level, LNLevel_allocateForGetObject));
    LNLevel_OnSerialize_SetOverrideCallback(Wrap_LNLevel_OnSerialize_OverrideCallback);
    LNLevel_OnStart_SetOverrideCallback(Wrap_LNLevel_OnStart_OverrideCallback);
    LNLevel_OnStop_SetOverrideCallback(Wrap_LNLevel_OnStop_OverrideCallback);
    LNLevel_OnPause_SetOverrideCallback(Wrap_LNLevel_OnPause_OverrideCallback);
    LNLevel_OnResume_SetOverrideCallback(Wrap_LNLevel_OnResume_OverrideCallback);
    LNLevel_OnUpdate_SetOverrideCallback(Wrap_LNLevel_OnUpdate_OverrideCallback);

    g_class_UIColors = rb_define_class_under(g_rootModule, "UIColors", rb_cObject);
    rb_define_singleton_method(g_class_UIColors, "red", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Red), -1);
    rb_define_singleton_method(g_class_UIColors, "pink", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Pink), -1);
    rb_define_singleton_method(g_class_UIColors, "purple", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Purple), -1);
    rb_define_singleton_method(g_class_UIColors, "deep_purple", LN_TO_RUBY_FUNC(Wrap_LNUIColors_DeepPurple), -1);
    rb_define_singleton_method(g_class_UIColors, "indigo", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Indigo), -1);
    rb_define_singleton_method(g_class_UIColors, "blue", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Blue), -1);
    rb_define_singleton_method(g_class_UIColors, "light_blue", LN_TO_RUBY_FUNC(Wrap_LNUIColors_LightBlue), -1);
    rb_define_singleton_method(g_class_UIColors, "cyan", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Cyan), -1);
    rb_define_singleton_method(g_class_UIColors, "teal", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Teal), -1);
    rb_define_singleton_method(g_class_UIColors, "green", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Green), -1);
    rb_define_singleton_method(g_class_UIColors, "light_green", LN_TO_RUBY_FUNC(Wrap_LNUIColors_LightGreen), -1);
    rb_define_singleton_method(g_class_UIColors, "lime", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Lime), -1);
    rb_define_singleton_method(g_class_UIColors, "yellow", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Yellow), -1);
    rb_define_singleton_method(g_class_UIColors, "amber", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Amber), -1);
    rb_define_singleton_method(g_class_UIColors, "orange", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Orange), -1);
    rb_define_singleton_method(g_class_UIColors, "deep_orange", LN_TO_RUBY_FUNC(Wrap_LNUIColors_DeepOrange), -1);
    rb_define_singleton_method(g_class_UIColors, "brown", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Brown), -1);
    rb_define_singleton_method(g_class_UIColors, "grey", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Grey), -1);
    rb_define_singleton_method(g_class_UIColors, "get", LN_TO_RUBY_FUNC(Wrap_LNUIColors_Get), -1);

    g_class_UIEventArgs = rb_define_class_under(g_rootModule, "UIEventArgs", g_class_Object);
    rb_define_alloc_func(g_class_UIEventArgs, LNUIEventArgs_allocate);
    rb_define_method(g_class_UIEventArgs, "sender", LN_TO_RUBY_FUNC(Wrap_LNUIEventArgs_Sender), -1);
    LNUIEventArgs_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIEventArgs, LNUIEventArgs_allocateForGetObject));
    LNUIEventArgs_OnSerialize_SetOverrideCallback(Wrap_LNUIEventArgs_OnSerialize_OverrideCallback);

    g_class_UIGeneralEventHandler = rb_define_class_under(g_rootModule, "UIGeneralEventHandler", g_class_Object);
    rb_define_alloc_func(g_class_UIGeneralEventHandler, LNUIGeneralEventHandler_allocate);
    rb_define_private_method(g_class_UIGeneralEventHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIGeneralEventHandler_Create), -1);
    LNUIGeneralEventHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIGeneralEventHandler, LNUIGeneralEventHandler_allocateForGetObject));

    g_class_UIEventHandler = rb_define_class_under(g_rootModule, "UIEventHandler", g_class_Object);
    rb_define_alloc_func(g_class_UIEventHandler, LNUIEventHandler_allocate);
    rb_define_private_method(g_class_UIEventHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIEventHandler_Create), -1);
    LNUIEventHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIEventHandler, LNUIEventHandler_allocateForGetObject));

    g_class_UILayoutElement = rb_define_class_under(g_rootModule, "UILayoutElement", g_class_Object);
    rb_define_alloc_func(g_class_UILayoutElement, LNUILayoutElement_allocate);
    LNUILayoutElement_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UILayoutElement, LNUILayoutElement_allocateForGetObject));
    LNUILayoutElement_OnSerialize_SetOverrideCallback(Wrap_LNUILayoutElement_OnSerialize_OverrideCallback);

    g_class_UIElement = rb_define_class_under(g_rootModule, "UIElement", g_class_UILayoutElement);
    rb_define_alloc_func(g_class_UIElement, LNUIElement_allocate);
    rb_define_method(g_class_UIElement, "set_size", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetSize), -1);
    rb_define_method(g_class_UIElement, "width=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetWidth), -1);
    rb_define_method(g_class_UIElement, "width", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetWidth), -1);
    rb_define_method(g_class_UIElement, "height=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetHeight), -1);
    rb_define_method(g_class_UIElement, "height", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetHeight), -1);
    rb_define_method(g_class_UIElement, "margin=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetMargin), -1);
    rb_define_method(g_class_UIElement, "margin", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetMargin), -1);
    rb_define_method(g_class_UIElement, "padding=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetPadding), -1);
    rb_define_method(g_class_UIElement, "padding", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetPadding), -1);
    rb_define_method(g_class_UIElement, "h_alignment=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetHAlignment), -1);
    rb_define_method(g_class_UIElement, "h_alignment", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetHAlignment), -1);
    rb_define_method(g_class_UIElement, "v_alignment=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetVAlignment), -1);
    rb_define_method(g_class_UIElement, "v_alignment", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetVAlignment), -1);
    rb_define_method(g_class_UIElement, "set_alignments", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetAlignments), -1);
    rb_define_method(g_class_UIElement, "position=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetPosition), -1);
    rb_define_method(g_class_UIElement, "set_position", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetPosition), -1);
    rb_define_method(g_class_UIElement, "position", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetPosition), -1);
    rb_define_method(g_class_UIElement, "rotation=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetRotation), -1);
    rb_define_method(g_class_UIElement, "set_euler_angles", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetEulerAngles), -1);
    rb_define_method(g_class_UIElement, "rotation", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetRotation), -1);
    rb_define_method(g_class_UIElement, "scale=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetScale), -1);
    rb_define_method(g_class_UIElement, "set_scale", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetScale), -1);
    rb_define_method(g_class_UIElement, "scale", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetScale), -1);
    rb_define_method(g_class_UIElement, "center_point=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetCenterPoint), -1);
    rb_define_method(g_class_UIElement, "set_center_point", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetCenterPoint), -1);
    rb_define_method(g_class_UIElement, "center_point", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetCenterPoint), -1);
    rb_define_method(g_class_UIElement, "enabled=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetEnabled), -1);
    rb_define_method(g_class_UIElement, "enabled?", LN_TO_RUBY_FUNC(Wrap_LNUIElement_IsEnabled), -1);
    rb_define_method(g_class_UIElement, "data=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetData), -1);
    rb_define_method(g_class_UIElement, "data", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetData), -1);
    rb_define_method(g_class_UIElement, "background_color=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetBackgroundColor), -1);
    rb_define_method(g_class_UIElement, "background_color", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetBackgroundColor), -1);
    rb_define_method(g_class_UIElement, "border_thickness=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetBorderThickness), -1);
    rb_define_method(g_class_UIElement, "border_thickness", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetBorderThickness), -1);
    rb_define_method(g_class_UIElement, "border_color=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetBorderColor), -1);
    rb_define_method(g_class_UIElement, "border_color", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetBorderColor), -1);
    rb_define_method(g_class_UIElement, "corner_radius=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetCornerRadius), -1);
    rb_define_method(g_class_UIElement, "corner_radius", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetCornerRadius), -1);
    rb_define_method(g_class_UIElement, "visibility=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetVisibility), -1);
    rb_define_method(g_class_UIElement, "visibility", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetVisibility), -1);
    rb_define_method(g_class_UIElement, "opacity=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetOpacity), -1);
    rb_define_method(g_class_UIElement, "opacity", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetOpacity), -1);
    rb_define_method(g_class_UIElement, "add_child", LN_TO_RUBY_FUNC(Wrap_LNUIElement_AddChild), -1);
    rb_define_method(g_class_UIElement, "focusable=", LN_TO_RUBY_FUNC(Wrap_LNUIElement_SetFocusable), -1);
    rb_define_method(g_class_UIElement, "focusable?", LN_TO_RUBY_FUNC(Wrap_LNUIElement_GetFocusable), -1);
    LNUIElement_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIElement, LNUIElement_allocateForGetObject));
    LNUIElement_OnSerialize_SetOverrideCallback(Wrap_LNUIElement_OnSerialize_OverrideCallback);

    g_class_UITextBlock = rb_define_class_under(g_rootModule, "UITextBlock", g_class_UIElement);
    rb_define_alloc_func(g_class_UITextBlock, LNUITextBlock_allocate);
    rb_define_private_method(g_class_UITextBlock, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUITextBlock_Create), -1);
    rb_define_method(g_class_UITextBlock, "text=", LN_TO_RUBY_FUNC(Wrap_LNUITextBlock_SetText), -1);
    rb_define_method(g_class_UITextBlock, "text", LN_TO_RUBY_FUNC(Wrap_LNUITextBlock_GetText), -1);
    LNUITextBlock_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UITextBlock, LNUITextBlock_allocateForGetObject));
    LNUITextBlock_OnSerialize_SetOverrideCallback(Wrap_LNUITextBlock_OnSerialize_OverrideCallback);

    g_class_UISprite = rb_define_class_under(g_rootModule, "UISprite", g_class_UIElement);
    rb_define_alloc_func(g_class_UISprite, LNUISprite_allocate);
    rb_define_private_method(g_class_UISprite, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUISprite_Create), -1);
    rb_define_method(g_class_UISprite, "texture=", LN_TO_RUBY_FUNC(Wrap_LNUISprite_SetTexture), -1);
    rb_define_method(g_class_UISprite, "source_rect=", LN_TO_RUBY_FUNC(Wrap_LNUISprite_SetSourceRect), -1);
    rb_define_method(g_class_UISprite, "set_source_rect", LN_TO_RUBY_FUNC(Wrap_LNUISprite_SetSourceRect), -1);
    rb_define_method(g_class_UISprite, "source_rect", LN_TO_RUBY_FUNC(Wrap_LNUISprite_GetSourceRect), -1);
    rb_define_method(g_class_UISprite, "shader=", LN_TO_RUBY_FUNC(Wrap_LNUISprite_SetShader), -1);
    LNUISprite_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UISprite, LNUISprite_allocateForGetObject));
    LNUISprite_OnSerialize_SetOverrideCallback(Wrap_LNUISprite_OnSerialize_OverrideCallback);

    g_class_UIIcon = rb_define_class_under(g_rootModule, "UIIcon", g_class_UIElement);
    rb_define_alloc_func(g_class_UIIcon, LNUIIcon_allocate);
    rb_define_singleton_method(g_class_UIIcon, "load_font_icon", LN_TO_RUBY_FUNC(Wrap_LNUIIcon_LoadFontIcon), -1);
    LNUIIcon_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIIcon, LNUIIcon_allocateForGetObject));
    LNUIIcon_OnSerialize_SetOverrideCallback(Wrap_LNUIIcon_OnSerialize_OverrideCallback);

    g_class_UIMessageTextArea = rb_define_class_under(g_rootModule, "UIMessageTextArea", g_class_UIElement);
    rb_define_alloc_func(g_class_UIMessageTextArea, LNUIMessageTextArea_allocate);
    rb_define_private_method(g_class_UIMessageTextArea, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIMessageTextArea_Create), -1);
    rb_define_method(g_class_UIMessageTextArea, "text=", LN_TO_RUBY_FUNC(Wrap_LNUIMessageTextArea_SetText), -1);
    rb_define_method(g_class_UIMessageTextArea, "typing_speed=", LN_TO_RUBY_FUNC(Wrap_LNUIMessageTextArea_SetTypingSpeed), -1);
    LNUIMessageTextArea_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIMessageTextArea, LNUIMessageTextArea_allocateForGetObject));
    LNUIMessageTextArea_OnSerialize_SetOverrideCallback(Wrap_LNUIMessageTextArea_OnSerialize_OverrideCallback);

    g_class_UI = rb_define_class_under(g_rootModule, "UI", rb_cObject);
    rb_define_singleton_method(g_class_UI, "add", LN_TO_RUBY_FUNC(Wrap_LNUI_Add), -1);
    rb_define_singleton_method(g_class_UI, "remove", LN_TO_RUBY_FUNC(Wrap_LNUI_Remove), -1);

    g_class_UILayoutPanel = rb_define_class_under(g_rootModule, "UILayoutPanel", g_class_UIElement);
    rb_define_alloc_func(g_class_UILayoutPanel, LNUILayoutPanel_allocate);
    LNUILayoutPanel_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UILayoutPanel, LNUILayoutPanel_allocateForGetObject));
    LNUILayoutPanel_OnSerialize_SetOverrideCallback(Wrap_LNUILayoutPanel_OnSerialize_OverrideCallback);

    g_class_UIBoxLayout = rb_define_class_under(g_rootModule, "UIBoxLayout", g_class_UILayoutPanel);
    rb_define_alloc_func(g_class_UIBoxLayout, LNUIBoxLayout_allocate);
    rb_define_private_method(g_class_UIBoxLayout, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIBoxLayout_Create), -1);
    rb_define_method(g_class_UIBoxLayout, "orientation=", LN_TO_RUBY_FUNC(Wrap_LNUIBoxLayout_SetOrientation), -1);
    rb_define_method(g_class_UIBoxLayout, "orientation", LN_TO_RUBY_FUNC(Wrap_LNUIBoxLayout_GetOrientation), -1);
    LNUIBoxLayout_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIBoxLayout, LNUIBoxLayout_allocateForGetObject));
    LNUIBoxLayout_OnSerialize_SetOverrideCallback(Wrap_LNUIBoxLayout_OnSerialize_OverrideCallback);

    g_class_UIStackLayout = rb_define_class_under(g_rootModule, "UIStackLayout", g_class_UILayoutPanel);
    rb_define_alloc_func(g_class_UIStackLayout, LNUIStackLayout_allocate);
    rb_define_private_method(g_class_UIStackLayout, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIStackLayout_Create), -1);
    rb_define_method(g_class_UIStackLayout, "orientation=", LN_TO_RUBY_FUNC(Wrap_LNUIStackLayout_SetOrientation), -1);
    rb_define_method(g_class_UIStackLayout, "orientation", LN_TO_RUBY_FUNC(Wrap_LNUIStackLayout_GetOrientation), -1);
    LNUIStackLayout_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIStackLayout, LNUIStackLayout_allocateForGetObject));
    LNUIStackLayout_OnSerialize_SetOverrideCallback(Wrap_LNUIStackLayout_OnSerialize_OverrideCallback);

    g_class_UIGridLayout = rb_define_class_under(g_rootModule, "UIGridLayout", g_class_UILayoutPanel);
    rb_define_alloc_func(g_class_UIGridLayout, LNUIGridLayout_allocate);
    rb_define_private_method(g_class_UIGridLayout, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIGridLayout_Create), -1);
    rb_define_method(g_class_UIGridLayout, "column_count=", LN_TO_RUBY_FUNC(Wrap_LNUIGridLayout_SetColumnCount), -1);
    rb_define_singleton_method(g_class_UIGridLayout, "set_row", LN_TO_RUBY_FUNC(Wrap_LNUIGridLayout_SetRow), -1);
    rb_define_singleton_method(g_class_UIGridLayout, "set_column", LN_TO_RUBY_FUNC(Wrap_LNUIGridLayout_SetColumn), -1);
    rb_define_singleton_method(g_class_UIGridLayout, "set_placement", LN_TO_RUBY_FUNC(Wrap_LNUIGridLayout_SetPlacement), -1);
    LNUIGridLayout_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIGridLayout, LNUIGridLayout_allocateForGetObject));
    LNUIGridLayout_OnSerialize_SetOverrideCallback(Wrap_LNUIGridLayout_OnSerialize_OverrideCallback);

    g_class_UIControl = rb_define_class_under(g_rootModule, "UIControl", g_class_UIElement);
    rb_define_alloc_func(g_class_UIControl, LNUIControl_allocate);
    rb_define_private_method(g_class_UIControl, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIControl_Create), -1);
    rb_define_method(g_class_UIControl, "add_inline_visual", LN_TO_RUBY_FUNC(Wrap_LNUIControl_AddInlineVisual), -1);
    LNUIControl_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIControl, LNUIControl_allocateForGetObject));
    LNUIControl_OnSerialize_SetOverrideCallback(Wrap_LNUIControl_OnSerialize_OverrideCallback);

    g_class_UIButtonBase = rb_define_class_under(g_rootModule, "UIButtonBase", g_class_UIControl);
    rb_define_alloc_func(g_class_UIButtonBase, LNUIButtonBase_allocate);
    rb_define_method(g_class_UIButtonBase, "set_text", LN_TO_RUBY_FUNC(Wrap_LNUIButtonBase_SetText), -1);
    LNUIButtonBase_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIButtonBase, LNUIButtonBase_allocateForGetObject));
    LNUIButtonBase_OnSerialize_SetOverrideCallback(Wrap_LNUIButtonBase_OnSerialize_OverrideCallback);

    g_class_UIButton = rb_define_class_under(g_rootModule, "UIButton", g_class_UIButtonBase);
    rb_define_alloc_func(g_class_UIButton, LNUIButton_allocate);
    rb_define_private_method(g_class_UIButton, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIButton_Create), -1);
    rb_define_method(g_class_UIButton, "connect_on_clicked", LN_TO_RUBY_FUNC(Wrap_LNUIButton_ConnectOnClicked), -1);
    LNUIButton_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIButton, LNUIButton_allocateForGetObject));
    LNUIButton_OnSerialize_SetOverrideCallback(Wrap_LNUIButton_OnSerialize_OverrideCallback);

    g_class_UIWindow = rb_define_class_under(g_rootModule, "UIWindow", g_class_UIControl);
    rb_define_alloc_func(g_class_UIWindow, LNUIWindow_allocate);
    rb_define_private_method(g_class_UIWindow, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIWindow_Create), -1);
    LNUIWindow_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIWindow, LNUIWindow_allocateForGetObject));
    LNUIWindow_OnSerialize_SetOverrideCallback(Wrap_LNUIWindow_OnSerialize_OverrideCallback);

    g_class_UIListItem = rb_define_class_under(g_rootModule, "UIListItem", g_class_UIControl);
    rb_define_alloc_func(g_class_UIListItem, LNUIListItem_allocate);
    rb_define_method(g_class_UIListItem, "connect_on_submit", LN_TO_RUBY_FUNC(Wrap_LNUIListItem_ConnectOnSubmit), -1);
    LNUIListItem_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIListItem, LNUIListItem_allocateForGetObject));
    LNUIListItem_OnSerialize_SetOverrideCallback(Wrap_LNUIListItem_OnSerialize_OverrideCallback);

    g_class_UIListItemsControl = rb_define_class_under(g_rootModule, "UIListItemsControl", g_class_UIControl);
    rb_define_alloc_func(g_class_UIListItemsControl, LNUIListItemsControl_allocate);
    rb_define_method(g_class_UIListItemsControl, "items_layout_panel=", LN_TO_RUBY_FUNC(Wrap_LNUIListItemsControl_SetItemsLayoutPanel), -1);
    rb_define_method(g_class_UIListItemsControl, "submit_mode=", LN_TO_RUBY_FUNC(Wrap_LNUIListItemsControl_SetSubmitMode), -1);
    rb_define_method(g_class_UIListItemsControl, "submit_mode", LN_TO_RUBY_FUNC(Wrap_LNUIListItemsControl_GetSubmitMode), -1);
    LNUIListItemsControl_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIListItemsControl, LNUIListItemsControl_allocateForGetObject));
    LNUIListItemsControl_OnSerialize_SetOverrideCallback(Wrap_LNUIListItemsControl_OnSerialize_OverrideCallback);

    g_class_UIListBoxItem = rb_define_class_under(g_rootModule, "UIListBoxItem", g_class_UIListItem);
    rb_define_alloc_func(g_class_UIListBoxItem, LNUIListBoxItem_allocate);
    rb_define_private_method(g_class_UIListBoxItem, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIListBoxItem_Create), -1);
    LNUIListBoxItem_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIListBoxItem, LNUIListBoxItem_allocateForGetObject));
    LNUIListBoxItem_OnSerialize_SetOverrideCallback(Wrap_LNUIListBoxItem_OnSerialize_OverrideCallback);

    g_class_UIListBox = rb_define_class_under(g_rootModule, "UIListBox", g_class_UIListItemsControl);
    rb_define_alloc_func(g_class_UIListBox, LNUIListBox_allocate);
    rb_define_private_method(g_class_UIListBox, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIListBox_Create), -1);
    rb_define_method(g_class_UIListBox, "add_item", LN_TO_RUBY_FUNC(Wrap_LNUIListBox_AddItem), -1);
    LNUIListBox_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIListBox, LNUIListBox_allocateForGetObject));
    LNUIListBox_OnSerialize_SetOverrideCallback(Wrap_LNUIListBox_OnSerialize_OverrideCallback);

    g_class_InputGesture = rb_define_class_under(g_rootModule, "InputGesture", g_class_Object);
    rb_define_alloc_func(g_class_InputGesture, LNInputGesture_allocate);
    LNInputGesture_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_InputGesture, LNInputGesture_allocateForGetObject));
    LNInputGesture_OnSerialize_SetOverrideCallback(Wrap_LNInputGesture_OnSerialize_OverrideCallback);

    g_class_KeyGesture = rb_define_class_under(g_rootModule, "KeyGesture", g_class_InputGesture);
    rb_define_alloc_func(g_class_KeyGesture, LNKeyGesture_allocate);
    rb_define_private_method(g_class_KeyGesture, "initialize", LN_TO_RUBY_FUNC(Wrap_LNKeyGesture_Create), -1);
    LNKeyGesture_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_KeyGesture, LNKeyGesture_allocateForGetObject));
    LNKeyGesture_OnSerialize_SetOverrideCallback(Wrap_LNKeyGesture_OnSerialize_OverrideCallback);

    g_class_Input = rb_define_class_under(g_rootModule, "Input", rb_cObject);
    rb_define_singleton_method(g_class_Input, "is_pressed", LN_TO_RUBY_FUNC(Wrap_LNInput_IsPressed), -1);
    rb_define_singleton_method(g_class_Input, "is_triggered", LN_TO_RUBY_FUNC(Wrap_LNInput_IsTriggered), -1);
    rb_define_singleton_method(g_class_Input, "is_triggered_off", LN_TO_RUBY_FUNC(Wrap_LNInput_IsTriggeredOff), -1);
    rb_define_singleton_method(g_class_Input, "is_repeated", LN_TO_RUBY_FUNC(Wrap_LNInput_IsRepeated), -1);
    rb_define_singleton_method(g_class_Input, "get_axis_value", LN_TO_RUBY_FUNC(Wrap_LNInput_GetAxisValue), -1);
    rb_define_singleton_method(g_class_Input, "add_binding", LN_TO_RUBY_FUNC(Wrap_LNInput_AddBinding), -1);
    rb_define_singleton_method(g_class_Input, "remove_binding", LN_TO_RUBY_FUNC(Wrap_LNInput_RemoveBinding), -1);
    rb_define_singleton_method(g_class_Input, "clear_bindings", LN_TO_RUBY_FUNC(Wrap_LNInput_ClearBindings), -1);
    rb_define_singleton_method(g_class_Input, "clear_all_bindings", LN_TO_RUBY_FUNC(Wrap_LNInput_ClearAllBindings), -1);

    g_class_Mouse = rb_define_class_under(g_rootModule, "Mouse", rb_cObject);
    rb_define_singleton_method(g_class_Mouse, "pressed", LN_TO_RUBY_FUNC(Wrap_LNMouse_Pressed), -1);
    rb_define_singleton_method(g_class_Mouse, "triggered", LN_TO_RUBY_FUNC(Wrap_LNMouse_Triggered), -1);
    rb_define_singleton_method(g_class_Mouse, "triggered_off", LN_TO_RUBY_FUNC(Wrap_LNMouse_TriggeredOff), -1);
    rb_define_singleton_method(g_class_Mouse, "repeated", LN_TO_RUBY_FUNC(Wrap_LNMouse_Repeated), -1);
    rb_define_singleton_method(g_class_Mouse, "position", LN_TO_RUBY_FUNC(Wrap_LNMouse_Position), -1);

    g_class_InterpreterCommand = rb_define_class_under(g_rootModule, "InterpreterCommand", g_class_Object);
    rb_define_alloc_func(g_class_InterpreterCommand, LNInterpreterCommand_allocate);
    rb_define_method(g_class_InterpreterCommand, "code", LN_TO_RUBY_FUNC(Wrap_LNInterpreterCommand_Code), -1);
    rb_define_method(g_class_InterpreterCommand, "params_count", LN_TO_RUBY_FUNC(Wrap_LNInterpreterCommand_ParamsCount), -1);
    rb_define_method(g_class_InterpreterCommand, "param", LN_TO_RUBY_FUNC(Wrap_LNInterpreterCommand_Param), -1);
    LNInterpreterCommand_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_InterpreterCommand, LNInterpreterCommand_allocateForGetObject));
    LNInterpreterCommand_OnSerialize_SetOverrideCallback(Wrap_LNInterpreterCommand_OnSerialize_OverrideCallback);

    g_class_InterpreterCommandList = rb_define_class_under(g_rootModule, "InterpreterCommandList", g_class_Object);
    rb_define_alloc_func(g_class_InterpreterCommandList, LNInterpreterCommandList_allocate);
    rb_define_private_method(g_class_InterpreterCommandList, "initialize", LN_TO_RUBY_FUNC(Wrap_LNInterpreterCommandList_Create), -1);
    rb_define_method(g_class_InterpreterCommandList, "add_command", LN_TO_RUBY_FUNC(Wrap_LNInterpreterCommandList_AddCommand), -1);
    rb_define_method(g_class_InterpreterCommandList, "add_command_1", LN_TO_RUBY_FUNC(Wrap_LNInterpreterCommandList_AddCommand1), -1);
    rb_define_method(g_class_InterpreterCommandList, "add_command_2", LN_TO_RUBY_FUNC(Wrap_LNInterpreterCommandList_AddCommand2), -1);
    rb_define_method(g_class_InterpreterCommandList, "add_command_3", LN_TO_RUBY_FUNC(Wrap_LNInterpreterCommandList_AddCommand3), -1);
    rb_define_method(g_class_InterpreterCommandList, "add_command_4", LN_TO_RUBY_FUNC(Wrap_LNInterpreterCommandList_AddCommand4), -1);
    LNInterpreterCommandList_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_InterpreterCommandList, LNInterpreterCommandList_allocateForGetObject));
    LNInterpreterCommandList_OnSerialize_SetOverrideCallback(Wrap_LNInterpreterCommandList_OnSerialize_OverrideCallback);

    g_class_InterpreterCommandDelegate = rb_define_class_under(g_rootModule, "InterpreterCommandDelegate", g_class_Object);
    rb_define_alloc_func(g_class_InterpreterCommandDelegate, LNInterpreterCommandDelegate_allocate);
    rb_define_private_method(g_class_InterpreterCommandDelegate, "initialize", LN_TO_RUBY_FUNC(Wrap_LNInterpreterCommandDelegate_Create), -1);
    LNInterpreterCommandDelegate_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_InterpreterCommandDelegate, LNInterpreterCommandDelegate_allocateForGetObject));

    g_class_Interpreter = rb_define_class_under(g_rootModule, "Interpreter", g_class_Object);
    rb_define_alloc_func(g_class_Interpreter, LNInterpreter_allocate);
    rb_define_private_method(g_class_Interpreter, "initialize", LN_TO_RUBY_FUNC(Wrap_LNInterpreter_Create), -1);
    rb_define_method(g_class_Interpreter, "clear", LN_TO_RUBY_FUNC(Wrap_LNInterpreter_Clear), -1);
    rb_define_method(g_class_Interpreter, "run", LN_TO_RUBY_FUNC(Wrap_LNInterpreter_Run), -1);
    rb_define_method(g_class_Interpreter, "running?", LN_TO_RUBY_FUNC(Wrap_LNInterpreter_IsRunning), -1);
    rb_define_method(g_class_Interpreter, "update", LN_TO_RUBY_FUNC(Wrap_LNInterpreter_Update), -1);
    rb_define_method(g_class_Interpreter, "terminate", LN_TO_RUBY_FUNC(Wrap_LNInterpreter_Terminate), -1);
    rb_define_method(g_class_Interpreter, "register_command_handler", LN_TO_RUBY_FUNC(Wrap_LNInterpreter_RegisterCommandHandler), -1);
    rb_define_method(g_class_Interpreter, "wait_mode=", LN_TO_RUBY_FUNC(Wrap_LNInterpreter_SetWaitMode), -1);
    rb_define_method(g_class_Interpreter, "wait_mode", LN_TO_RUBY_FUNC(Wrap_LNInterpreter_GetWaitMode), -1);
    rb_define_method(g_class_Interpreter, "wait_count=", LN_TO_RUBY_FUNC(Wrap_LNInterpreter_SetWaitCount), -1);
    rb_define_method(g_class_Interpreter, "wait_count", LN_TO_RUBY_FUNC(Wrap_LNInterpreter_GetWaitCount), -1);
    rb_define_method(g_class_Interpreter, "on_update_wait", LN_TO_RUBY_FUNC(Wrap_LNInterpreter_OnUpdateWait), -1);
    LNInterpreter_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Interpreter, LNInterpreter_allocateForGetObject));
    LNInterpreter_OnSerialize_SetOverrideCallback(Wrap_LNInterpreter_OnSerialize_OverrideCallback);
    LNInterpreter_OnUpdateWait_SetOverrideCallback(Wrap_LNInterpreter_OnUpdateWait_OverrideCallback);

    g_class_EngineSettings = rb_define_class_under(g_rootModule, "EngineSettings", rb_cObject);
    rb_define_singleton_method(g_class_EngineSettings, "set_main_window_size", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_SetMainWindowSize), -1);
    rb_define_singleton_method(g_class_EngineSettings, "set_main_world_view_size", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_SetMainWorldViewSize), -1);
    rb_define_singleton_method(g_class_EngineSettings, "set_main_window_title", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_SetMainWindowTitle), -1);
    rb_define_singleton_method(g_class_EngineSettings, "set_main_window_resizable", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_SetMainWindowResizable), -1);
    rb_define_singleton_method(g_class_EngineSettings, "add_asset_directory", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_AddAssetDirectory), -1);
    rb_define_singleton_method(g_class_EngineSettings, "add_asset_archive", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_AddAssetArchive), -1);
    rb_define_singleton_method(g_class_EngineSettings, "set_frame_rate", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_SetFrameRate), -1);
    rb_define_singleton_method(g_class_EngineSettings, "set_ui_theme", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_SetUITheme), -1);
    rb_define_singleton_method(g_class_EngineSettings, "set_font_file", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_SetFontFile), -1);
    rb_define_singleton_method(g_class_EngineSettings, "set_debug_tool_enabled", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_SetDebugToolEnabled), -1);
    rb_define_singleton_method(g_class_EngineSettings, "set_engine_log_enabled", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_SetEngineLogEnabled), -1);
    rb_define_singleton_method(g_class_EngineSettings, "set_engine_log_file_path", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_SetEngineLogFilePath), -1);
    rb_define_singleton_method(g_class_EngineSettings, "set_developer_tool_enabled", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_SetDeveloperToolEnabled), -1);
    rb_define_singleton_method(g_class_EngineSettings, "set_user_main_window", LN_TO_RUBY_FUNC(Wrap_LNEngineSettings_SetUserMainWindow), -1);

    g_class_Engine = rb_define_class_under(g_rootModule, "Engine", rb_cObject);
    rb_define_singleton_method(g_class_Engine, "initialize", LN_TO_RUBY_FUNC(Wrap_LNEngine_Initialize), -1);
    rb_define_singleton_method(g_class_Engine, "terminate", LN_TO_RUBY_FUNC(Wrap_LNEngine_Terminate), -1);
    rb_define_singleton_method(g_class_Engine, "update", LN_TO_RUBY_FUNC(Wrap_LNEngine_Update), -1);
    rb_define_singleton_method(g_class_Engine, "run", LN_TO_RUBY_FUNC(Wrap_LNEngine_Run), -1);
    rb_define_singleton_method(g_class_Engine, "time", LN_TO_RUBY_FUNC(Wrap_LNEngine_GetTime), -1);
    rb_define_singleton_method(g_class_Engine, "world", LN_TO_RUBY_FUNC(Wrap_LNEngine_GetWorld), -1);
    rb_define_singleton_method(g_class_Engine, "camera", LN_TO_RUBY_FUNC(Wrap_LNEngine_GetCamera), -1);
    rb_define_singleton_method(g_class_Engine, "main_light", LN_TO_RUBY_FUNC(Wrap_LNEngine_GetMainLight), -1);
    rb_define_singleton_method(g_class_Engine, "render_view", LN_TO_RUBY_FUNC(Wrap_LNEngine_GetRenderView), -1);

    g_class_Application = rb_define_class_under(g_rootModule, "Application", g_class_Object);
    rb_define_alloc_func(g_class_Application, LNApplication_allocate);
    rb_define_private_method(g_class_Application, "initialize", LN_TO_RUBY_FUNC(Wrap_LNApplication_Create), -1);
    rb_define_method(g_class_Application, "on_init", LN_TO_RUBY_FUNC(Wrap_LNApplication_OnInit), -1);
    rb_define_method(g_class_Application, "on_update", LN_TO_RUBY_FUNC(Wrap_LNApplication_OnUpdate), -1);
    rb_define_method(g_class_Application, "world", LN_TO_RUBY_FUNC(Wrap_LNApplication_World), -1);
    LNApplication_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Application, LNApplication_allocateForGetObject));
    LNApplication_OnSerialize_SetOverrideCallback(Wrap_LNApplication_OnSerialize_OverrideCallback);
    LNApplication_OnInit_SetOverrideCallback(Wrap_LNApplication_OnInit_OverrideCallback);
    LNApplication_OnUpdate_SetOverrideCallback(Wrap_LNApplication_OnUpdate_OverrideCallback);

    g_class_Debug = rb_define_class_under(g_rootModule, "Debug", rb_cObject);
    rb_define_singleton_method(g_class_Debug, "guide_grid_enabled=", LN_TO_RUBY_FUNC(Wrap_LNDebug_SetGuideGridEnabled), -1);
    rb_define_singleton_method(g_class_Debug, "physics_debug_draw_enabled=", LN_TO_RUBY_FUNC(Wrap_LNDebug_SetPhysicsDebugDrawEnabled), -1);
    rb_define_singleton_method(g_class_Debug, "print", LN_TO_RUBY_FUNC(Wrap_LNDebug_Print), -1);

    g_class_ObjectSerializeHandler = rb_define_class_under(g_rootModule, "ObjectSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_ObjectSerializeHandler, LNObjectSerializeHandler_allocate);
    rb_define_private_method(g_class_ObjectSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNObjectSerializeHandler_Create), -1);
    LNObjectSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ObjectSerializeHandler, LNObjectSerializeHandler_allocateForGetObject));

    g_class_EventConnectionSerializeHandler = rb_define_class_under(g_rootModule, "EventConnectionSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_EventConnectionSerializeHandler, LNEventConnectionSerializeHandler_allocate);
    rb_define_private_method(g_class_EventConnectionSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNEventConnectionSerializeHandler_Create), -1);
    LNEventConnectionSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_EventConnectionSerializeHandler, LNEventConnectionSerializeHandler_allocateForGetObject));

    g_class_VariantSerializeHandler = rb_define_class_under(g_rootModule, "VariantSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_VariantSerializeHandler, LNVariantSerializeHandler_allocate);
    rb_define_private_method(g_class_VariantSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNVariantSerializeHandler_Create), -1);
    LNVariantSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_VariantSerializeHandler, LNVariantSerializeHandler_allocateForGetObject));

    g_class_ZVTestClass1SerializeHandler = rb_define_class_under(g_rootModule, "ZVTestClass1SerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_ZVTestClass1SerializeHandler, LNZVTestClass1SerializeHandler_allocate);
    rb_define_private_method(g_class_ZVTestClass1SerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNZVTestClass1SerializeHandler_Create), -1);
    LNZVTestClass1SerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ZVTestClass1SerializeHandler, LNZVTestClass1SerializeHandler_allocateForGetObject));

    g_class_ZVTestEventArgs1SerializeHandler = rb_define_class_under(g_rootModule, "ZVTestEventArgs1SerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_ZVTestEventArgs1SerializeHandler, LNZVTestEventArgs1SerializeHandler_allocate);
    rb_define_private_method(g_class_ZVTestEventArgs1SerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNZVTestEventArgs1SerializeHandler_Create), -1);
    LNZVTestEventArgs1SerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ZVTestEventArgs1SerializeHandler, LNZVTestEventArgs1SerializeHandler_allocateForGetObject));

    g_class_Serializer2SerializeHandler = rb_define_class_under(g_rootModule, "Serializer2SerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_Serializer2SerializeHandler, LNSerializer2SerializeHandler_allocate);
    rb_define_private_method(g_class_Serializer2SerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSerializer2SerializeHandler_Create), -1);
    LNSerializer2SerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Serializer2SerializeHandler, LNSerializer2SerializeHandler_allocateForGetObject));

    g_class_AssetObjectSerializeHandler = rb_define_class_under(g_rootModule, "AssetObjectSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_AssetObjectSerializeHandler, LNAssetObjectSerializeHandler_allocate);
    rb_define_private_method(g_class_AssetObjectSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNAssetObjectSerializeHandler_Create), -1);
    LNAssetObjectSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AssetObjectSerializeHandler, LNAssetObjectSerializeHandler_allocateForGetObject));

    g_class_AssetImportSettingsSerializeHandler = rb_define_class_under(g_rootModule, "AssetImportSettingsSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_AssetImportSettingsSerializeHandler, LNAssetImportSettingsSerializeHandler_allocate);
    rb_define_private_method(g_class_AssetImportSettingsSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNAssetImportSettingsSerializeHandler_Create), -1);
    LNAssetImportSettingsSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AssetImportSettingsSerializeHandler, LNAssetImportSettingsSerializeHandler_allocateForGetObject));

    g_class_AssetModelSerializeHandler = rb_define_class_under(g_rootModule, "AssetModelSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_AssetModelSerializeHandler, LNAssetModelSerializeHandler_allocate);
    rb_define_private_method(g_class_AssetModelSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNAssetModelSerializeHandler_Create), -1);
    LNAssetModelSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AssetModelSerializeHandler, LNAssetModelSerializeHandler_allocateForGetObject));

    g_class_SoundSerializeHandler = rb_define_class_under(g_rootModule, "SoundSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_SoundSerializeHandler, LNSoundSerializeHandler_allocate);
    rb_define_private_method(g_class_SoundSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSoundSerializeHandler_Create), -1);
    LNSoundSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SoundSerializeHandler, LNSoundSerializeHandler_allocateForGetObject));

    g_class_TextureSerializeHandler = rb_define_class_under(g_rootModule, "TextureSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_TextureSerializeHandler, LNTextureSerializeHandler_allocate);
    rb_define_private_method(g_class_TextureSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNTextureSerializeHandler_Create), -1);
    LNTextureSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_TextureSerializeHandler, LNTextureSerializeHandler_allocateForGetObject));

    g_class_Texture2DSerializeHandler = rb_define_class_under(g_rootModule, "Texture2DSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_Texture2DSerializeHandler, LNTexture2DSerializeHandler_allocate);
    rb_define_private_method(g_class_Texture2DSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNTexture2DSerializeHandler_Create), -1);
    LNTexture2DSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_Texture2DSerializeHandler, LNTexture2DSerializeHandler_allocateForGetObject));

    g_class_ShaderSerializeHandler = rb_define_class_under(g_rootModule, "ShaderSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_ShaderSerializeHandler, LNShaderSerializeHandler_allocate);
    rb_define_private_method(g_class_ShaderSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNShaderSerializeHandler_Create), -1);
    LNShaderSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ShaderSerializeHandler, LNShaderSerializeHandler_allocateForGetObject));

    g_class_RenderViewSerializeHandler = rb_define_class_under(g_rootModule, "RenderViewSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_RenderViewSerializeHandler, LNRenderViewSerializeHandler_allocate);
    rb_define_private_method(g_class_RenderViewSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNRenderViewSerializeHandler_Create), -1);
    LNRenderViewSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_RenderViewSerializeHandler, LNRenderViewSerializeHandler_allocateForGetObject));

    g_class_MaterialSerializeHandler = rb_define_class_under(g_rootModule, "MaterialSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_MaterialSerializeHandler, LNMaterialSerializeHandler_allocate);
    rb_define_private_method(g_class_MaterialSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNMaterialSerializeHandler_Create), -1);
    LNMaterialSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_MaterialSerializeHandler, LNMaterialSerializeHandler_allocateForGetObject));

    g_class_MeshNodeSerializeHandler = rb_define_class_under(g_rootModule, "MeshNodeSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_MeshNodeSerializeHandler, LNMeshNodeSerializeHandler_allocate);
    rb_define_private_method(g_class_MeshNodeSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNMeshNodeSerializeHandler_Create), -1);
    LNMeshNodeSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_MeshNodeSerializeHandler, LNMeshNodeSerializeHandler_allocateForGetObject));

    g_class_AnimationControllerSerializeHandler = rb_define_class_under(g_rootModule, "AnimationControllerSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_AnimationControllerSerializeHandler, LNAnimationControllerSerializeHandler_allocate);
    rb_define_private_method(g_class_AnimationControllerSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNAnimationControllerSerializeHandler_Create), -1);
    LNAnimationControllerSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AnimationControllerSerializeHandler, LNAnimationControllerSerializeHandler_allocateForGetObject));

    g_class_MeshModelSerializeHandler = rb_define_class_under(g_rootModule, "MeshModelSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_MeshModelSerializeHandler, LNMeshModelSerializeHandler_allocate);
    rb_define_private_method(g_class_MeshModelSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNMeshModelSerializeHandler_Create), -1);
    LNMeshModelSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_MeshModelSerializeHandler, LNMeshModelSerializeHandler_allocateForGetObject));

    g_class_MeshImportSettingsSerializeHandler = rb_define_class_under(g_rootModule, "MeshImportSettingsSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_MeshImportSettingsSerializeHandler, LNMeshImportSettingsSerializeHandler_allocate);
    rb_define_private_method(g_class_MeshImportSettingsSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNMeshImportSettingsSerializeHandler_Create), -1);
    LNMeshImportSettingsSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_MeshImportSettingsSerializeHandler, LNMeshImportSettingsSerializeHandler_allocateForGetObject));

    g_class_SkinnedMeshModelSerializeHandler = rb_define_class_under(g_rootModule, "SkinnedMeshModelSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_SkinnedMeshModelSerializeHandler, LNSkinnedMeshModelSerializeHandler_allocate);
    rb_define_private_method(g_class_SkinnedMeshModelSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSkinnedMeshModelSerializeHandler_Create), -1);
    LNSkinnedMeshModelSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SkinnedMeshModelSerializeHandler, LNSkinnedMeshModelSerializeHandler_allocateForGetObject));

    g_class_CollisionShapeSerializeHandler = rb_define_class_under(g_rootModule, "CollisionShapeSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_CollisionShapeSerializeHandler, LNCollisionShapeSerializeHandler_allocate);
    rb_define_private_method(g_class_CollisionShapeSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNCollisionShapeSerializeHandler_Create), -1);
    LNCollisionShapeSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_CollisionShapeSerializeHandler, LNCollisionShapeSerializeHandler_allocateForGetObject));

    g_class_BoxCollisionShapeSerializeHandler = rb_define_class_under(g_rootModule, "BoxCollisionShapeSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_BoxCollisionShapeSerializeHandler, LNBoxCollisionShapeSerializeHandler_allocate);
    rb_define_private_method(g_class_BoxCollisionShapeSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNBoxCollisionShapeSerializeHandler_Create), -1);
    LNBoxCollisionShapeSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_BoxCollisionShapeSerializeHandler, LNBoxCollisionShapeSerializeHandler_allocateForGetObject));

    g_class_AnimationCurveSerializeHandler = rb_define_class_under(g_rootModule, "AnimationCurveSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_AnimationCurveSerializeHandler, LNAnimationCurveSerializeHandler_allocate);
    rb_define_private_method(g_class_AnimationCurveSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNAnimationCurveSerializeHandler_Create), -1);
    LNAnimationCurveSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AnimationCurveSerializeHandler, LNAnimationCurveSerializeHandler_allocateForGetObject));

    g_class_KeyFrameAnimationCurveSerializeHandler = rb_define_class_under(g_rootModule, "KeyFrameAnimationCurveSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_KeyFrameAnimationCurveSerializeHandler, LNKeyFrameAnimationCurveSerializeHandler_allocate);
    rb_define_private_method(g_class_KeyFrameAnimationCurveSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNKeyFrameAnimationCurveSerializeHandler_Create), -1);
    LNKeyFrameAnimationCurveSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_KeyFrameAnimationCurveSerializeHandler, LNKeyFrameAnimationCurveSerializeHandler_allocateForGetObject));

    g_class_AnimationClipSerializeHandler = rb_define_class_under(g_rootModule, "AnimationClipSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_AnimationClipSerializeHandler, LNAnimationClipSerializeHandler_allocate);
    rb_define_private_method(g_class_AnimationClipSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNAnimationClipSerializeHandler_Create), -1);
    LNAnimationClipSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AnimationClipSerializeHandler, LNAnimationClipSerializeHandler_allocateForGetObject));

    g_class_AnimationStateSerializeHandler = rb_define_class_under(g_rootModule, "AnimationStateSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_AnimationStateSerializeHandler, LNAnimationStateSerializeHandler_allocate);
    rb_define_private_method(g_class_AnimationStateSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNAnimationStateSerializeHandler_Create), -1);
    LNAnimationStateSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_AnimationStateSerializeHandler, LNAnimationStateSerializeHandler_allocateForGetObject));

    g_class_EffectResourceSerializeHandler = rb_define_class_under(g_rootModule, "EffectResourceSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_EffectResourceSerializeHandler, LNEffectResourceSerializeHandler_allocate);
    rb_define_private_method(g_class_EffectResourceSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNEffectResourceSerializeHandler_Create), -1);
    LNEffectResourceSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_EffectResourceSerializeHandler, LNEffectResourceSerializeHandler_allocateForGetObject));

    g_class_ParticleEmitterModelSerializeHandler = rb_define_class_under(g_rootModule, "ParticleEmitterModelSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_ParticleEmitterModelSerializeHandler, LNParticleEmitterModelSerializeHandler_allocate);
    rb_define_private_method(g_class_ParticleEmitterModelSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterModelSerializeHandler_Create), -1);
    LNParticleEmitterModelSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ParticleEmitterModelSerializeHandler, LNParticleEmitterModelSerializeHandler_allocateForGetObject));

    g_class_ParticleModelSerializeHandler = rb_define_class_under(g_rootModule, "ParticleModelSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_ParticleModelSerializeHandler, LNParticleModelSerializeHandler_allocate);
    rb_define_private_method(g_class_ParticleModelSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNParticleModelSerializeHandler_Create), -1);
    LNParticleModelSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ParticleModelSerializeHandler, LNParticleModelSerializeHandler_allocateForGetObject));

    g_class_ComponentSerializeHandler = rb_define_class_under(g_rootModule, "ComponentSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_ComponentSerializeHandler, LNComponentSerializeHandler_allocate);
    rb_define_private_method(g_class_ComponentSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNComponentSerializeHandler_Create), -1);
    LNComponentSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ComponentSerializeHandler, LNComponentSerializeHandler_allocateForGetObject));

    g_class_VisualComponentSerializeHandler = rb_define_class_under(g_rootModule, "VisualComponentSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_VisualComponentSerializeHandler, LNVisualComponentSerializeHandler_allocate);
    rb_define_private_method(g_class_VisualComponentSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNVisualComponentSerializeHandler_Create), -1);
    LNVisualComponentSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_VisualComponentSerializeHandler, LNVisualComponentSerializeHandler_allocateForGetObject));

    g_class_SpriteComponentSerializeHandler = rb_define_class_under(g_rootModule, "SpriteComponentSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_SpriteComponentSerializeHandler, LNSpriteComponentSerializeHandler_allocate);
    rb_define_private_method(g_class_SpriteComponentSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSpriteComponentSerializeHandler_Create), -1);
    LNSpriteComponentSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SpriteComponentSerializeHandler, LNSpriteComponentSerializeHandler_allocateForGetObject));

    g_class_CharacterControllerSerializeHandler = rb_define_class_under(g_rootModule, "CharacterControllerSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_CharacterControllerSerializeHandler, LNCharacterControllerSerializeHandler_allocate);
    rb_define_private_method(g_class_CharacterControllerSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNCharacterControllerSerializeHandler_Create), -1);
    LNCharacterControllerSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_CharacterControllerSerializeHandler, LNCharacterControllerSerializeHandler_allocateForGetObject));

    g_class_WorldSerializeHandler = rb_define_class_under(g_rootModule, "WorldSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_WorldSerializeHandler, LNWorldSerializeHandler_allocate);
    rb_define_private_method(g_class_WorldSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNWorldSerializeHandler_Create), -1);
    LNWorldSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_WorldSerializeHandler, LNWorldSerializeHandler_allocateForGetObject));

    g_class_ComponentListSerializeHandler = rb_define_class_under(g_rootModule, "ComponentListSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_ComponentListSerializeHandler, LNComponentListSerializeHandler_allocate);
    rb_define_private_method(g_class_ComponentListSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNComponentListSerializeHandler_Create), -1);
    LNComponentListSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ComponentListSerializeHandler, LNComponentListSerializeHandler_allocateForGetObject));

    g_class_WorldObjectSerializeHandler = rb_define_class_under(g_rootModule, "WorldObjectSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_WorldObjectSerializeHandler, LNWorldObjectSerializeHandler_allocate);
    rb_define_private_method(g_class_WorldObjectSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNWorldObjectSerializeHandler_Create), -1);
    LNWorldObjectSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_WorldObjectSerializeHandler, LNWorldObjectSerializeHandler_allocateForGetObject));

    g_class_WorldObjectPreUpdateHandler = rb_define_class_under(g_rootModule, "WorldObjectPreUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_WorldObjectPreUpdateHandler, LNWorldObjectPreUpdateHandler_allocate);
    rb_define_private_method(g_class_WorldObjectPreUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNWorldObjectPreUpdateHandler_Create), -1);
    LNWorldObjectPreUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_WorldObjectPreUpdateHandler, LNWorldObjectPreUpdateHandler_allocateForGetObject));

    g_class_WorldObjectUpdateHandler = rb_define_class_under(g_rootModule, "WorldObjectUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_WorldObjectUpdateHandler, LNWorldObjectUpdateHandler_allocate);
    rb_define_private_method(g_class_WorldObjectUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNWorldObjectUpdateHandler_Create), -1);
    LNWorldObjectUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_WorldObjectUpdateHandler, LNWorldObjectUpdateHandler_allocateForGetObject));

    g_class_VisualObjectSerializeHandler = rb_define_class_under(g_rootModule, "VisualObjectSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_VisualObjectSerializeHandler, LNVisualObjectSerializeHandler_allocate);
    rb_define_private_method(g_class_VisualObjectSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNVisualObjectSerializeHandler_Create), -1);
    LNVisualObjectSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_VisualObjectSerializeHandler, LNVisualObjectSerializeHandler_allocateForGetObject));

    g_class_VisualObjectPreUpdateHandler = rb_define_class_under(g_rootModule, "VisualObjectPreUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_VisualObjectPreUpdateHandler, LNVisualObjectPreUpdateHandler_allocate);
    rb_define_private_method(g_class_VisualObjectPreUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNVisualObjectPreUpdateHandler_Create), -1);
    LNVisualObjectPreUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_VisualObjectPreUpdateHandler, LNVisualObjectPreUpdateHandler_allocateForGetObject));

    g_class_VisualObjectUpdateHandler = rb_define_class_under(g_rootModule, "VisualObjectUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_VisualObjectUpdateHandler, LNVisualObjectUpdateHandler_allocate);
    rb_define_private_method(g_class_VisualObjectUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNVisualObjectUpdateHandler_Create), -1);
    LNVisualObjectUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_VisualObjectUpdateHandler, LNVisualObjectUpdateHandler_allocateForGetObject));

    g_class_CameraSerializeHandler = rb_define_class_under(g_rootModule, "CameraSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_CameraSerializeHandler, LNCameraSerializeHandler_allocate);
    rb_define_private_method(g_class_CameraSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNCameraSerializeHandler_Create), -1);
    LNCameraSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_CameraSerializeHandler, LNCameraSerializeHandler_allocateForGetObject));

    g_class_CameraPreUpdateHandler = rb_define_class_under(g_rootModule, "CameraPreUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_CameraPreUpdateHandler, LNCameraPreUpdateHandler_allocate);
    rb_define_private_method(g_class_CameraPreUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNCameraPreUpdateHandler_Create), -1);
    LNCameraPreUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_CameraPreUpdateHandler, LNCameraPreUpdateHandler_allocateForGetObject));

    g_class_CameraUpdateHandler = rb_define_class_under(g_rootModule, "CameraUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_CameraUpdateHandler, LNCameraUpdateHandler_allocate);
    rb_define_private_method(g_class_CameraUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNCameraUpdateHandler_Create), -1);
    LNCameraUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_CameraUpdateHandler, LNCameraUpdateHandler_allocateForGetObject));

    g_class_EnvironmentLightSerializeHandler = rb_define_class_under(g_rootModule, "EnvironmentLightSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_EnvironmentLightSerializeHandler, LNEnvironmentLightSerializeHandler_allocate);
    rb_define_private_method(g_class_EnvironmentLightSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLightSerializeHandler_Create), -1);
    LNEnvironmentLightSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_EnvironmentLightSerializeHandler, LNEnvironmentLightSerializeHandler_allocateForGetObject));

    g_class_EnvironmentLightPreUpdateHandler = rb_define_class_under(g_rootModule, "EnvironmentLightPreUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_EnvironmentLightPreUpdateHandler, LNEnvironmentLightPreUpdateHandler_allocate);
    rb_define_private_method(g_class_EnvironmentLightPreUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLightPreUpdateHandler_Create), -1);
    LNEnvironmentLightPreUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_EnvironmentLightPreUpdateHandler, LNEnvironmentLightPreUpdateHandler_allocateForGetObject));

    g_class_EnvironmentLightUpdateHandler = rb_define_class_under(g_rootModule, "EnvironmentLightUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_EnvironmentLightUpdateHandler, LNEnvironmentLightUpdateHandler_allocate);
    rb_define_private_method(g_class_EnvironmentLightUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNEnvironmentLightUpdateHandler_Create), -1);
    LNEnvironmentLightUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_EnvironmentLightUpdateHandler, LNEnvironmentLightUpdateHandler_allocateForGetObject));

    g_class_DirectionalLightSerializeHandler = rb_define_class_under(g_rootModule, "DirectionalLightSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_DirectionalLightSerializeHandler, LNDirectionalLightSerializeHandler_allocate);
    rb_define_private_method(g_class_DirectionalLightSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLightSerializeHandler_Create), -1);
    LNDirectionalLightSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_DirectionalLightSerializeHandler, LNDirectionalLightSerializeHandler_allocateForGetObject));

    g_class_DirectionalLightPreUpdateHandler = rb_define_class_under(g_rootModule, "DirectionalLightPreUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_DirectionalLightPreUpdateHandler, LNDirectionalLightPreUpdateHandler_allocate);
    rb_define_private_method(g_class_DirectionalLightPreUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLightPreUpdateHandler_Create), -1);
    LNDirectionalLightPreUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_DirectionalLightPreUpdateHandler, LNDirectionalLightPreUpdateHandler_allocateForGetObject));

    g_class_DirectionalLightUpdateHandler = rb_define_class_under(g_rootModule, "DirectionalLightUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_DirectionalLightUpdateHandler, LNDirectionalLightUpdateHandler_allocate);
    rb_define_private_method(g_class_DirectionalLightUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNDirectionalLightUpdateHandler_Create), -1);
    LNDirectionalLightUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_DirectionalLightUpdateHandler, LNDirectionalLightUpdateHandler_allocateForGetObject));

    g_class_PointLightSerializeHandler = rb_define_class_under(g_rootModule, "PointLightSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_PointLightSerializeHandler, LNPointLightSerializeHandler_allocate);
    rb_define_private_method(g_class_PointLightSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNPointLightSerializeHandler_Create), -1);
    LNPointLightSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_PointLightSerializeHandler, LNPointLightSerializeHandler_allocateForGetObject));

    g_class_PointLightPreUpdateHandler = rb_define_class_under(g_rootModule, "PointLightPreUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_PointLightPreUpdateHandler, LNPointLightPreUpdateHandler_allocate);
    rb_define_private_method(g_class_PointLightPreUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNPointLightPreUpdateHandler_Create), -1);
    LNPointLightPreUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_PointLightPreUpdateHandler, LNPointLightPreUpdateHandler_allocateForGetObject));

    g_class_PointLightUpdateHandler = rb_define_class_under(g_rootModule, "PointLightUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_PointLightUpdateHandler, LNPointLightUpdateHandler_allocate);
    rb_define_private_method(g_class_PointLightUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNPointLightUpdateHandler_Create), -1);
    LNPointLightUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_PointLightUpdateHandler, LNPointLightUpdateHandler_allocateForGetObject));

    g_class_SpotLightSerializeHandler = rb_define_class_under(g_rootModule, "SpotLightSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_SpotLightSerializeHandler, LNSpotLightSerializeHandler_allocate);
    rb_define_private_method(g_class_SpotLightSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSpotLightSerializeHandler_Create), -1);
    LNSpotLightSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SpotLightSerializeHandler, LNSpotLightSerializeHandler_allocateForGetObject));

    g_class_SpotLightPreUpdateHandler = rb_define_class_under(g_rootModule, "SpotLightPreUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_SpotLightPreUpdateHandler, LNSpotLightPreUpdateHandler_allocate);
    rb_define_private_method(g_class_SpotLightPreUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSpotLightPreUpdateHandler_Create), -1);
    LNSpotLightPreUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SpotLightPreUpdateHandler, LNSpotLightPreUpdateHandler_allocateForGetObject));

    g_class_SpotLightUpdateHandler = rb_define_class_under(g_rootModule, "SpotLightUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_SpotLightUpdateHandler, LNSpotLightUpdateHandler_allocate);
    rb_define_private_method(g_class_SpotLightUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSpotLightUpdateHandler_Create), -1);
    LNSpotLightUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SpotLightUpdateHandler, LNSpotLightUpdateHandler_allocateForGetObject));

    g_class_SpriteSerializeHandler = rb_define_class_under(g_rootModule, "SpriteSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_SpriteSerializeHandler, LNSpriteSerializeHandler_allocate);
    rb_define_private_method(g_class_SpriteSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSpriteSerializeHandler_Create), -1);
    LNSpriteSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SpriteSerializeHandler, LNSpriteSerializeHandler_allocateForGetObject));

    g_class_SpritePreUpdateHandler = rb_define_class_under(g_rootModule, "SpritePreUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_SpritePreUpdateHandler, LNSpritePreUpdateHandler_allocate);
    rb_define_private_method(g_class_SpritePreUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSpritePreUpdateHandler_Create), -1);
    LNSpritePreUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SpritePreUpdateHandler, LNSpritePreUpdateHandler_allocateForGetObject));

    g_class_SpriteUpdateHandler = rb_define_class_under(g_rootModule, "SpriteUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_SpriteUpdateHandler, LNSpriteUpdateHandler_allocate);
    rb_define_private_method(g_class_SpriteUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSpriteUpdateHandler_Create), -1);
    LNSpriteUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SpriteUpdateHandler, LNSpriteUpdateHandler_allocateForGetObject));

    g_class_CameraOrbitControlComponentSerializeHandler = rb_define_class_under(g_rootModule, "CameraOrbitControlComponentSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_CameraOrbitControlComponentSerializeHandler, LNCameraOrbitControlComponentSerializeHandler_allocate);
    rb_define_private_method(g_class_CameraOrbitControlComponentSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNCameraOrbitControlComponentSerializeHandler_Create), -1);
    LNCameraOrbitControlComponentSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_CameraOrbitControlComponentSerializeHandler, LNCameraOrbitControlComponentSerializeHandler_allocateForGetObject));

    g_class_RaycasterSerializeHandler = rb_define_class_under(g_rootModule, "RaycasterSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_RaycasterSerializeHandler, LNRaycasterSerializeHandler_allocate);
    rb_define_private_method(g_class_RaycasterSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNRaycasterSerializeHandler_Create), -1);
    LNRaycasterSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_RaycasterSerializeHandler, LNRaycasterSerializeHandler_allocateForGetObject));

    g_class_RaycastResultSerializeHandler = rb_define_class_under(g_rootModule, "RaycastResultSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_RaycastResultSerializeHandler, LNRaycastResultSerializeHandler_allocate);
    rb_define_private_method(g_class_RaycastResultSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNRaycastResultSerializeHandler_Create), -1);
    LNRaycastResultSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_RaycastResultSerializeHandler, LNRaycastResultSerializeHandler_allocateForGetObject));

    g_class_WorldRenderViewSerializeHandler = rb_define_class_under(g_rootModule, "WorldRenderViewSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_WorldRenderViewSerializeHandler, LNWorldRenderViewSerializeHandler_allocate);
    rb_define_private_method(g_class_WorldRenderViewSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNWorldRenderViewSerializeHandler_Create), -1);
    LNWorldRenderViewSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_WorldRenderViewSerializeHandler, LNWorldRenderViewSerializeHandler_allocateForGetObject));

    g_class_BoxMeshSerializeHandler = rb_define_class_under(g_rootModule, "BoxMeshSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_BoxMeshSerializeHandler, LNBoxMeshSerializeHandler_allocate);
    rb_define_private_method(g_class_BoxMeshSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNBoxMeshSerializeHandler_Create), -1);
    LNBoxMeshSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_BoxMeshSerializeHandler, LNBoxMeshSerializeHandler_allocateForGetObject));

    g_class_BoxMeshPreUpdateHandler = rb_define_class_under(g_rootModule, "BoxMeshPreUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_BoxMeshPreUpdateHandler, LNBoxMeshPreUpdateHandler_allocate);
    rb_define_private_method(g_class_BoxMeshPreUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNBoxMeshPreUpdateHandler_Create), -1);
    LNBoxMeshPreUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_BoxMeshPreUpdateHandler, LNBoxMeshPreUpdateHandler_allocateForGetObject));

    g_class_BoxMeshUpdateHandler = rb_define_class_under(g_rootModule, "BoxMeshUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_BoxMeshUpdateHandler, LNBoxMeshUpdateHandler_allocate);
    rb_define_private_method(g_class_BoxMeshUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNBoxMeshUpdateHandler_Create), -1);
    LNBoxMeshUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_BoxMeshUpdateHandler, LNBoxMeshUpdateHandler_allocateForGetObject));

    g_class_PlaneMeshSerializeHandler = rb_define_class_under(g_rootModule, "PlaneMeshSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_PlaneMeshSerializeHandler, LNPlaneMeshSerializeHandler_allocate);
    rb_define_private_method(g_class_PlaneMeshSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNPlaneMeshSerializeHandler_Create), -1);
    LNPlaneMeshSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_PlaneMeshSerializeHandler, LNPlaneMeshSerializeHandler_allocateForGetObject));

    g_class_PlaneMeshPreUpdateHandler = rb_define_class_under(g_rootModule, "PlaneMeshPreUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_PlaneMeshPreUpdateHandler, LNPlaneMeshPreUpdateHandler_allocate);
    rb_define_private_method(g_class_PlaneMeshPreUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNPlaneMeshPreUpdateHandler_Create), -1);
    LNPlaneMeshPreUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_PlaneMeshPreUpdateHandler, LNPlaneMeshPreUpdateHandler_allocateForGetObject));

    g_class_PlaneMeshUpdateHandler = rb_define_class_under(g_rootModule, "PlaneMeshUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_PlaneMeshUpdateHandler, LNPlaneMeshUpdateHandler_allocate);
    rb_define_private_method(g_class_PlaneMeshUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNPlaneMeshUpdateHandler_Create), -1);
    LNPlaneMeshUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_PlaneMeshUpdateHandler, LNPlaneMeshUpdateHandler_allocateForGetObject));

    g_class_StaticMeshSerializeHandler = rb_define_class_under(g_rootModule, "StaticMeshSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_StaticMeshSerializeHandler, LNStaticMeshSerializeHandler_allocate);
    rb_define_private_method(g_class_StaticMeshSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNStaticMeshSerializeHandler_Create), -1);
    LNStaticMeshSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_StaticMeshSerializeHandler, LNStaticMeshSerializeHandler_allocateForGetObject));

    g_class_StaticMeshPreUpdateHandler = rb_define_class_under(g_rootModule, "StaticMeshPreUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_StaticMeshPreUpdateHandler, LNStaticMeshPreUpdateHandler_allocate);
    rb_define_private_method(g_class_StaticMeshPreUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNStaticMeshPreUpdateHandler_Create), -1);
    LNStaticMeshPreUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_StaticMeshPreUpdateHandler, LNStaticMeshPreUpdateHandler_allocateForGetObject));

    g_class_StaticMeshUpdateHandler = rb_define_class_under(g_rootModule, "StaticMeshUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_StaticMeshUpdateHandler, LNStaticMeshUpdateHandler_allocate);
    rb_define_private_method(g_class_StaticMeshUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNStaticMeshUpdateHandler_Create), -1);
    LNStaticMeshUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_StaticMeshUpdateHandler, LNStaticMeshUpdateHandler_allocateForGetObject));

    g_class_StaticMeshComponentSerializeHandler = rb_define_class_under(g_rootModule, "StaticMeshComponentSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_StaticMeshComponentSerializeHandler, LNStaticMeshComponentSerializeHandler_allocate);
    rb_define_private_method(g_class_StaticMeshComponentSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNStaticMeshComponentSerializeHandler_Create), -1);
    LNStaticMeshComponentSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_StaticMeshComponentSerializeHandler, LNStaticMeshComponentSerializeHandler_allocateForGetObject));

    g_class_SkinnedMeshComponentSerializeHandler = rb_define_class_under(g_rootModule, "SkinnedMeshComponentSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_SkinnedMeshComponentSerializeHandler, LNSkinnedMeshComponentSerializeHandler_allocate);
    rb_define_private_method(g_class_SkinnedMeshComponentSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNSkinnedMeshComponentSerializeHandler_Create), -1);
    LNSkinnedMeshComponentSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_SkinnedMeshComponentSerializeHandler, LNSkinnedMeshComponentSerializeHandler_allocateForGetObject));

    g_class_CollisionSerializeHandler = rb_define_class_under(g_rootModule, "CollisionSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_CollisionSerializeHandler, LNCollisionSerializeHandler_allocate);
    rb_define_private_method(g_class_CollisionSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNCollisionSerializeHandler_Create), -1);
    LNCollisionSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_CollisionSerializeHandler, LNCollisionSerializeHandler_allocateForGetObject));

    g_class_TriggerBodyComponentSerializeHandler = rb_define_class_under(g_rootModule, "TriggerBodyComponentSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_TriggerBodyComponentSerializeHandler, LNTriggerBodyComponentSerializeHandler_allocate);
    rb_define_private_method(g_class_TriggerBodyComponentSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNTriggerBodyComponentSerializeHandler_Create), -1);
    LNTriggerBodyComponentSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_TriggerBodyComponentSerializeHandler, LNTriggerBodyComponentSerializeHandler_allocateForGetObject));

    g_class_ParticleEmitterSerializeHandler = rb_define_class_under(g_rootModule, "ParticleEmitterSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_ParticleEmitterSerializeHandler, LNParticleEmitterSerializeHandler_allocate);
    rb_define_private_method(g_class_ParticleEmitterSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterSerializeHandler_Create), -1);
    LNParticleEmitterSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ParticleEmitterSerializeHandler, LNParticleEmitterSerializeHandler_allocateForGetObject));

    g_class_ParticleEmitterPreUpdateHandler = rb_define_class_under(g_rootModule, "ParticleEmitterPreUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_ParticleEmitterPreUpdateHandler, LNParticleEmitterPreUpdateHandler_allocate);
    rb_define_private_method(g_class_ParticleEmitterPreUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterPreUpdateHandler_Create), -1);
    LNParticleEmitterPreUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ParticleEmitterPreUpdateHandler, LNParticleEmitterPreUpdateHandler_allocateForGetObject));

    g_class_ParticleEmitterUpdateHandler = rb_define_class_under(g_rootModule, "ParticleEmitterUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_ParticleEmitterUpdateHandler, LNParticleEmitterUpdateHandler_allocate);
    rb_define_private_method(g_class_ParticleEmitterUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNParticleEmitterUpdateHandler_Create), -1);
    LNParticleEmitterUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ParticleEmitterUpdateHandler, LNParticleEmitterUpdateHandler_allocateForGetObject));

    g_class_LevelSerializeHandler = rb_define_class_under(g_rootModule, "LevelSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_LevelSerializeHandler, LNLevelSerializeHandler_allocate);
    rb_define_private_method(g_class_LevelSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNLevelSerializeHandler_Create), -1);
    LNLevelSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_LevelSerializeHandler, LNLevelSerializeHandler_allocateForGetObject));

    g_class_LevelStartHandler = rb_define_class_under(g_rootModule, "LevelStartHandler", rb_cObject);
    rb_define_alloc_func(g_class_LevelStartHandler, LNLevelStartHandler_allocate);
    rb_define_private_method(g_class_LevelStartHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNLevelStartHandler_Create), -1);
    LNLevelStartHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_LevelStartHandler, LNLevelStartHandler_allocateForGetObject));

    g_class_LevelStopHandler = rb_define_class_under(g_rootModule, "LevelStopHandler", rb_cObject);
    rb_define_alloc_func(g_class_LevelStopHandler, LNLevelStopHandler_allocate);
    rb_define_private_method(g_class_LevelStopHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNLevelStopHandler_Create), -1);
    LNLevelStopHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_LevelStopHandler, LNLevelStopHandler_allocateForGetObject));

    g_class_LevelPauseHandler = rb_define_class_under(g_rootModule, "LevelPauseHandler", rb_cObject);
    rb_define_alloc_func(g_class_LevelPauseHandler, LNLevelPauseHandler_allocate);
    rb_define_private_method(g_class_LevelPauseHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNLevelPauseHandler_Create), -1);
    LNLevelPauseHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_LevelPauseHandler, LNLevelPauseHandler_allocateForGetObject));

    g_class_LevelResumeHandler = rb_define_class_under(g_rootModule, "LevelResumeHandler", rb_cObject);
    rb_define_alloc_func(g_class_LevelResumeHandler, LNLevelResumeHandler_allocate);
    rb_define_private_method(g_class_LevelResumeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNLevelResumeHandler_Create), -1);
    LNLevelResumeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_LevelResumeHandler, LNLevelResumeHandler_allocateForGetObject));

    g_class_LevelUpdateHandler = rb_define_class_under(g_rootModule, "LevelUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_LevelUpdateHandler, LNLevelUpdateHandler_allocate);
    rb_define_private_method(g_class_LevelUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNLevelUpdateHandler_Create), -1);
    LNLevelUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_LevelUpdateHandler, LNLevelUpdateHandler_allocateForGetObject));

    g_class_UIEventArgsSerializeHandler = rb_define_class_under(g_rootModule, "UIEventArgsSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIEventArgsSerializeHandler, LNUIEventArgsSerializeHandler_allocate);
    rb_define_private_method(g_class_UIEventArgsSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIEventArgsSerializeHandler_Create), -1);
    LNUIEventArgsSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIEventArgsSerializeHandler, LNUIEventArgsSerializeHandler_allocateForGetObject));

    g_class_UILayoutElementSerializeHandler = rb_define_class_under(g_rootModule, "UILayoutElementSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UILayoutElementSerializeHandler, LNUILayoutElementSerializeHandler_allocate);
    rb_define_private_method(g_class_UILayoutElementSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUILayoutElementSerializeHandler_Create), -1);
    LNUILayoutElementSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UILayoutElementSerializeHandler, LNUILayoutElementSerializeHandler_allocateForGetObject));

    g_class_UIElementSerializeHandler = rb_define_class_under(g_rootModule, "UIElementSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIElementSerializeHandler, LNUIElementSerializeHandler_allocate);
    rb_define_private_method(g_class_UIElementSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIElementSerializeHandler_Create), -1);
    LNUIElementSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIElementSerializeHandler, LNUIElementSerializeHandler_allocateForGetObject));

    g_class_UITextBlockSerializeHandler = rb_define_class_under(g_rootModule, "UITextBlockSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UITextBlockSerializeHandler, LNUITextBlockSerializeHandler_allocate);
    rb_define_private_method(g_class_UITextBlockSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUITextBlockSerializeHandler_Create), -1);
    LNUITextBlockSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UITextBlockSerializeHandler, LNUITextBlockSerializeHandler_allocateForGetObject));

    g_class_UISpriteSerializeHandler = rb_define_class_under(g_rootModule, "UISpriteSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UISpriteSerializeHandler, LNUISpriteSerializeHandler_allocate);
    rb_define_private_method(g_class_UISpriteSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUISpriteSerializeHandler_Create), -1);
    LNUISpriteSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UISpriteSerializeHandler, LNUISpriteSerializeHandler_allocateForGetObject));

    g_class_UIIconSerializeHandler = rb_define_class_under(g_rootModule, "UIIconSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIIconSerializeHandler, LNUIIconSerializeHandler_allocate);
    rb_define_private_method(g_class_UIIconSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIIconSerializeHandler_Create), -1);
    LNUIIconSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIIconSerializeHandler, LNUIIconSerializeHandler_allocateForGetObject));

    g_class_UIMessageTextAreaSerializeHandler = rb_define_class_under(g_rootModule, "UIMessageTextAreaSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIMessageTextAreaSerializeHandler, LNUIMessageTextAreaSerializeHandler_allocate);
    rb_define_private_method(g_class_UIMessageTextAreaSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIMessageTextAreaSerializeHandler_Create), -1);
    LNUIMessageTextAreaSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIMessageTextAreaSerializeHandler, LNUIMessageTextAreaSerializeHandler_allocateForGetObject));

    g_class_UILayoutPanelSerializeHandler = rb_define_class_under(g_rootModule, "UILayoutPanelSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UILayoutPanelSerializeHandler, LNUILayoutPanelSerializeHandler_allocate);
    rb_define_private_method(g_class_UILayoutPanelSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUILayoutPanelSerializeHandler_Create), -1);
    LNUILayoutPanelSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UILayoutPanelSerializeHandler, LNUILayoutPanelSerializeHandler_allocateForGetObject));

    g_class_UIBoxLayoutSerializeHandler = rb_define_class_under(g_rootModule, "UIBoxLayoutSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIBoxLayoutSerializeHandler, LNUIBoxLayoutSerializeHandler_allocate);
    rb_define_private_method(g_class_UIBoxLayoutSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIBoxLayoutSerializeHandler_Create), -1);
    LNUIBoxLayoutSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIBoxLayoutSerializeHandler, LNUIBoxLayoutSerializeHandler_allocateForGetObject));

    g_class_UIStackLayoutSerializeHandler = rb_define_class_under(g_rootModule, "UIStackLayoutSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIStackLayoutSerializeHandler, LNUIStackLayoutSerializeHandler_allocate);
    rb_define_private_method(g_class_UIStackLayoutSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIStackLayoutSerializeHandler_Create), -1);
    LNUIStackLayoutSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIStackLayoutSerializeHandler, LNUIStackLayoutSerializeHandler_allocateForGetObject));

    g_class_UIGridLayoutSerializeHandler = rb_define_class_under(g_rootModule, "UIGridLayoutSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIGridLayoutSerializeHandler, LNUIGridLayoutSerializeHandler_allocate);
    rb_define_private_method(g_class_UIGridLayoutSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIGridLayoutSerializeHandler_Create), -1);
    LNUIGridLayoutSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIGridLayoutSerializeHandler, LNUIGridLayoutSerializeHandler_allocateForGetObject));

    g_class_UIControlSerializeHandler = rb_define_class_under(g_rootModule, "UIControlSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIControlSerializeHandler, LNUIControlSerializeHandler_allocate);
    rb_define_private_method(g_class_UIControlSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIControlSerializeHandler_Create), -1);
    LNUIControlSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIControlSerializeHandler, LNUIControlSerializeHandler_allocateForGetObject));

    g_class_UIButtonBaseSerializeHandler = rb_define_class_under(g_rootModule, "UIButtonBaseSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIButtonBaseSerializeHandler, LNUIButtonBaseSerializeHandler_allocate);
    rb_define_private_method(g_class_UIButtonBaseSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIButtonBaseSerializeHandler_Create), -1);
    LNUIButtonBaseSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIButtonBaseSerializeHandler, LNUIButtonBaseSerializeHandler_allocateForGetObject));

    g_class_UIButtonSerializeHandler = rb_define_class_under(g_rootModule, "UIButtonSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIButtonSerializeHandler, LNUIButtonSerializeHandler_allocate);
    rb_define_private_method(g_class_UIButtonSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIButtonSerializeHandler_Create), -1);
    LNUIButtonSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIButtonSerializeHandler, LNUIButtonSerializeHandler_allocateForGetObject));

    g_class_UIWindowSerializeHandler = rb_define_class_under(g_rootModule, "UIWindowSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIWindowSerializeHandler, LNUIWindowSerializeHandler_allocate);
    rb_define_private_method(g_class_UIWindowSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIWindowSerializeHandler_Create), -1);
    LNUIWindowSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIWindowSerializeHandler, LNUIWindowSerializeHandler_allocateForGetObject));

    g_class_UIListItemSerializeHandler = rb_define_class_under(g_rootModule, "UIListItemSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIListItemSerializeHandler, LNUIListItemSerializeHandler_allocate);
    rb_define_private_method(g_class_UIListItemSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIListItemSerializeHandler_Create), -1);
    LNUIListItemSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIListItemSerializeHandler, LNUIListItemSerializeHandler_allocateForGetObject));

    g_class_UIListItemsControlSerializeHandler = rb_define_class_under(g_rootModule, "UIListItemsControlSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIListItemsControlSerializeHandler, LNUIListItemsControlSerializeHandler_allocate);
    rb_define_private_method(g_class_UIListItemsControlSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIListItemsControlSerializeHandler_Create), -1);
    LNUIListItemsControlSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIListItemsControlSerializeHandler, LNUIListItemsControlSerializeHandler_allocateForGetObject));

    g_class_UIListBoxItemSerializeHandler = rb_define_class_under(g_rootModule, "UIListBoxItemSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIListBoxItemSerializeHandler, LNUIListBoxItemSerializeHandler_allocate);
    rb_define_private_method(g_class_UIListBoxItemSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIListBoxItemSerializeHandler_Create), -1);
    LNUIListBoxItemSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIListBoxItemSerializeHandler, LNUIListBoxItemSerializeHandler_allocateForGetObject));

    g_class_UIListBoxSerializeHandler = rb_define_class_under(g_rootModule, "UIListBoxSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_UIListBoxSerializeHandler, LNUIListBoxSerializeHandler_allocate);
    rb_define_private_method(g_class_UIListBoxSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNUIListBoxSerializeHandler_Create), -1);
    LNUIListBoxSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_UIListBoxSerializeHandler, LNUIListBoxSerializeHandler_allocateForGetObject));

    g_class_InputGestureSerializeHandler = rb_define_class_under(g_rootModule, "InputGestureSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_InputGestureSerializeHandler, LNInputGestureSerializeHandler_allocate);
    rb_define_private_method(g_class_InputGestureSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNInputGestureSerializeHandler_Create), -1);
    LNInputGestureSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_InputGestureSerializeHandler, LNInputGestureSerializeHandler_allocateForGetObject));

    g_class_KeyGestureSerializeHandler = rb_define_class_under(g_rootModule, "KeyGestureSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_KeyGestureSerializeHandler, LNKeyGestureSerializeHandler_allocate);
    rb_define_private_method(g_class_KeyGestureSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNKeyGestureSerializeHandler_Create), -1);
    LNKeyGestureSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_KeyGestureSerializeHandler, LNKeyGestureSerializeHandler_allocateForGetObject));

    g_class_InterpreterCommandSerializeHandler = rb_define_class_under(g_rootModule, "InterpreterCommandSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_InterpreterCommandSerializeHandler, LNInterpreterCommandSerializeHandler_allocate);
    rb_define_private_method(g_class_InterpreterCommandSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNInterpreterCommandSerializeHandler_Create), -1);
    LNInterpreterCommandSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_InterpreterCommandSerializeHandler, LNInterpreterCommandSerializeHandler_allocateForGetObject));

    g_class_InterpreterCommandListSerializeHandler = rb_define_class_under(g_rootModule, "InterpreterCommandListSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_InterpreterCommandListSerializeHandler, LNInterpreterCommandListSerializeHandler_allocate);
    rb_define_private_method(g_class_InterpreterCommandListSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNInterpreterCommandListSerializeHandler_Create), -1);
    LNInterpreterCommandListSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_InterpreterCommandListSerializeHandler, LNInterpreterCommandListSerializeHandler_allocateForGetObject));

    g_class_InterpreterSerializeHandler = rb_define_class_under(g_rootModule, "InterpreterSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_InterpreterSerializeHandler, LNInterpreterSerializeHandler_allocate);
    rb_define_private_method(g_class_InterpreterSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNInterpreterSerializeHandler_Create), -1);
    LNInterpreterSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_InterpreterSerializeHandler, LNInterpreterSerializeHandler_allocateForGetObject));

    g_class_InterpreterUpdateWaitHandler = rb_define_class_under(g_rootModule, "InterpreterUpdateWaitHandler", rb_cObject);
    rb_define_alloc_func(g_class_InterpreterUpdateWaitHandler, LNInterpreterUpdateWaitHandler_allocate);
    rb_define_private_method(g_class_InterpreterUpdateWaitHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNInterpreterUpdateWaitHandler_Create), -1);
    LNInterpreterUpdateWaitHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_InterpreterUpdateWaitHandler, LNInterpreterUpdateWaitHandler_allocateForGetObject));

    g_class_ApplicationSerializeHandler = rb_define_class_under(g_rootModule, "ApplicationSerializeHandler", rb_cObject);
    rb_define_alloc_func(g_class_ApplicationSerializeHandler, LNApplicationSerializeHandler_allocate);
    rb_define_private_method(g_class_ApplicationSerializeHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNApplicationSerializeHandler_Create), -1);
    LNApplicationSerializeHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ApplicationSerializeHandler, LNApplicationSerializeHandler_allocateForGetObject));

    g_class_ApplicationInitHandler = rb_define_class_under(g_rootModule, "ApplicationInitHandler", rb_cObject);
    rb_define_alloc_func(g_class_ApplicationInitHandler, LNApplicationInitHandler_allocate);
    rb_define_private_method(g_class_ApplicationInitHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNApplicationInitHandler_Create), -1);
    LNApplicationInitHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ApplicationInitHandler, LNApplicationInitHandler_allocateForGetObject));

    g_class_ApplicationUpdateHandler = rb_define_class_under(g_rootModule, "ApplicationUpdateHandler", rb_cObject);
    rb_define_alloc_func(g_class_ApplicationUpdateHandler, LNApplicationUpdateHandler_allocate);
    rb_define_private_method(g_class_ApplicationUpdateHandler, "initialize", LN_TO_RUBY_FUNC(Wrap_LNApplicationUpdateHandler_Create), -1);
    LNApplicationUpdateHandler_SetManagedTypeInfoId(LuminoRubyRuntimeManager::instance->registerTypeInfo(g_class_ApplicationUpdateHandler, LNApplicationUpdateHandler_allocateForGetObject));

}


#if 0
#include "LuminoRuby.h"
#include "RubyStructs.h"

//-----------------------------------------------------------------------------
// WrapStructs


__WRAP_STRUCTS__

__GLOBALS__

__FUNCTIONS__

void InitClasses()
{
__DEFINES__
}

//-----------------------------------------------------------------------------
// TypeInfo

void Manager::RegisterTypeInfo()
{
	// dummy
	TypeInfo t;
	t.klass = Qnil;
	t.factory = NULL;
	m_typeInfoList.push_back(t);
	
__TYPEINFO_REGISTERS__
}
#endif

